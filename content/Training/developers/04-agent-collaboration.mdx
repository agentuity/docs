---
title: "Module 4: Agent-to-Agent Collaboration"
description: Building multi-agent systems that work together
---

So far, we've built single agents that can reason, act, and remember. But what if one agent can't do everything? What if you need specialized expertise, parallel processing, or simply want to break down complex problems into manageable pieces?

Welcome to the world of multi-agent systems.

## Why Multi-Agent Systems?

According to industry research, multi-agent architectures are becoming the standard for production AI systems. As [Microsoft's Build 2025 announcement](https://blogs.microsoft.com/blog/2025/05/19/microsoft-build-2025-the-age-of-ai-agents-and-building-the-open-agentic-web/) highlighted, the future is about agents working together in an "open agentic web."

Think about how human organizations work:
- **Specialization**: Different people excel at different tasks
- **Scalability**: Teams can handle more work than individuals
- **Reliability**: If one person is unavailable, others can step in
- **Modularity**: Easy to add new team members with specific skills

The same principles apply to agent systems.

## Industry Multi-Agent Patterns

Most production multi-agent systems follow one of two patterns:

### Direct Handoff (Sequential)
Agents pass control directly to each other, like a relay race:
```
Data Fetcher → Analyzer → Report Writer → User
```

**Best for:** Linear workflows where each step depends on the previous one.

### Orchestrator Pattern (Hub-and-Spoke)
A central orchestrator manages and routes to specialized agents:
```
           ┌→ Technical Agent
User → Orchestrator →→ Sales Agent
           └→ Support Agent
```

**Best for:** Complex systems with multiple specialized agents.

## Industry Challenges vs. Agentuity's Approach

According to [Microsoft's multi-agent orchestration announcements](https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/multi-agent-orchestration-maker-controls-and-more-microsoft-copilot-studio-announcements-at-microsoft-build-2025/), most platforms require complex orchestration layers with state management, workflow engines, and coordination services. [AWS's multi-agent design patterns](https://aws.amazon.com/blogs/machine-learning/design-multi-agent-orchestration-with-reasoning-using-amazon-bedrock-and-open-source-frameworks/) show similar complexity, often requiring LangGraph or custom orchestrators.

### Agentuity's Approach: Simple Handoffs

While other platforms build complex orchestration layers, Agentuity takes a different approach: **the handoff mechanism**. It's simpler, but with clear trade-offs:

- **What it does**: Transfers control from one agent to another (like call forwarding)
- **What it doesn't do**: Parallel execution, getting responses back, complex coordination
- **Why it works**: Most real-world agent workflows are actually sequential or conditional

## The Handoff Mechanism

In Agentuity, agents communicate using the `handoff` method. This is like forwarding a phone call - the current agent passes control to another agent, along with any necessary data.

<CodeExample py={`async def run(request, response, context):
    """Basic handoff example."""

    # Receive a research request
    task = await request.data.json()

    # Decide we need help from the web search agent
    if task.get("type") == "web_research":
        # Hand off to the web search specialist
        return response.handoff(
            {"name": "web-search"},  # Target agent
            {"query": task.get("query")},  # Data to pass
            {"original_task": task}  # Metadata
        )

    # Handle other task types...
    return response.json({"result": "Task completed"})`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Basic handoff example

  const task = await request.data.json();

  // Decide we need help from the web search agent
  if (task.type === 'web_research') {
    // Hand off to the web search specialist
    return response.handoff(
      { name: 'web-search' }, // Target agent
      {
        data: JSON.stringify({ query: task.query }), // Data as string
        contentType: 'application/json',
        metadata: { original_task: task } // Metadata object
      }
    );
  }

  // Handle other task types...
  return response.json({ result: 'Task completed' });
};`} />

## Agent Resolution

Agents can find each other using either:
- **Name**: Human-readable identifier (e.g., "web-search")
- **ID**: Unique system identifier (e.g., "agent_abc123")

The context object knows about all agents in your project:

<CodeExample py={`async def run(request, response, context):
    # List all available agents
    available_agents = context.agents
    context.logger.info(f"Available agents: {[a.name for a in available_agents]}")

    # Check if a specific agent exists
    if any(agent.name == "summarizer" for agent in context.agents):
        # Agent exists, we can safely hand off
        return response.handoff(
            {"name": "summarizer"},
            {"text": "Long article to summarize..."}  # Data to pass
        )`} js={`const handler: AgentHandler = async (request, response, context) => {
  // List all available agents
  const availableAgents = context.agents;
  context.logger.info(\`Available agents: \${availableAgents.map(a => a.name)}\`);

  // Check if a specific agent exists
  if (availableAgents.some(agent => agent.name === 'summarizer')) {
    // Agent exists, we can safely hand off
    return response.handoff(
      { name: 'summarizer' },
      {
        data: JSON.stringify({ text: 'Long article to summarize...' }),
        contentType: 'application/json'
      }
    );
  }
};`} />

## Patterns That Work with Agentuity's Handoff

### 1. Sequential Chain Pattern

Perfect for pipelines where each agent completes its work and passes to the next:

<CodeExample py={`async def run(request, response, context):
    """Pipeline pattern: Each agent enriches the data."""

    data = await request.data.json()
    step = data.get("step", 1)

    if step == 1:
        # First agent: Clean the data
        data["cleaned"] = True
        data["step"] = 2
        return response.handoff({"name": "processor"}, data)

    elif step == 2:
        # Second agent: Enrich the data
        data["enriched"] = True
        data["step"] = 3
        return response.handoff({"name": "validator"}, data)

    elif step == 3:
        # Final agent: Validate and return
        data["validated"] = True
        return response.json(data)`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Pipeline pattern: Each agent enriches the data

  const data = await request.data.json();
  const step = data.step || 1;

  if (step === 1) {
    // First agent: Clean the data
    data.cleaned = true;
    data.step = 2;
    return response.handoff({ name: 'processor' }, { data: JSON.stringify(data), contentType: 'application/json' });

  } else if (step === 2) {
    // Second agent: Enrich the data
    data.enriched = true;
    data.step = 3;
    return response.handoff({ name: 'validator' }, { data: JSON.stringify(data), contentType: 'application/json' });

  } else if (step === 3) {
    // Final agent: Validate and return
    data.validated = true;
    return response.json(data);
  }
};`} />

### 2. Conditional Routing Pattern

Route to different agents based on the request type - ideal for dispatcher/router agents:

<CodeExample py={`async def run(request, response, context):
    """Router pattern: Direct to appropriate specialist."""

    task = await request.data.json()
    task_type = task.get("type", "").lower()

    # Route based on task type
    agent_map = {
        "math": "calculator-agent",
        "translation": "translator-agent",
        "search": "web-search",
        "summary": "summarizer"
    }

    target_agent = agent_map.get(task_type)

    if target_agent:
        context.logger.info(f"Routing {task_type} task to {target_agent}")
        return response.handoff(
            {"name": target_agent},
            task.get("payload", {})  # Pass payload directly as data
        )

    # Unknown task type
    return response.json({
        "error": f"Unknown task type: {task_type}",
        "available_types": list(agent_map.keys())
    })`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Router pattern: Direct to appropriate specialist

  const task = await request.data.json();
  const taskType = (task.type || '').toLowerCase();

  // Route based on task type
  const agentMap = {
    math: 'calculator-agent',
    translation: 'translator-agent',
    search: 'web-search',
    summary: 'summarizer'
  };

  const targetAgent = agentMap[taskType];

  if (targetAgent) {
    context.logger.info(\`Routing \${taskType} task to \${targetAgent}\`);
    return response.handoff(
      { name: targetAgent },
      {
        data: JSON.stringify(task.payload || {}),
        contentType: 'application/json'
      }
    );
  }

  // Unknown task type
  return response.json({
    error: \`Unknown task type: \${taskType}\`,
    available_types: Object.keys(agentMap)
  });
};`} />

### 3. Orchestrator Pattern (Smart Routing)

A central agent analyzes requests and routes to appropriate specialists:

<CodeExample py={`async def run(request, response, context):
    """Smart orchestrator that analyzes intent before routing."""

    user_prompt = await request.data.text()

    # Simple intent analysis (in production, use LLM)
    if "technical" in user_prompt.lower() or "code" in user_prompt.lower():
        return response.handoff(
            {"name": "technical-expert"},
            {"query": user_prompt, "type": "technical"}
        )
    elif "price" in user_prompt.lower() or "cost" in user_prompt.lower():
        return response.handoff(
            {"name": "sales-expert"},
            {"query": user_prompt, "type": "sales"}
        )
    elif "help" in user_prompt.lower() or "problem" in user_prompt.lower():
        return response.handoff(
            {"name": "support-expert"},
            {"query": user_prompt, "type": "support"}
        )
    else:
        return response.text("I can help with technical, sales, or support questions. How can I assist you?")`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Smart orchestrator that analyzes intent before routing

  const userPrompt = await request.data.text();

  // Simple intent analysis (in production, use LLM)
  if (userPrompt.toLowerCase().includes('technical') || userPrompt.toLowerCase().includes('code')) {
    return response.handoff(
      { name: 'technical-expert' },
      {
        data: JSON.stringify({ query: userPrompt, type: 'technical' }),
        contentType: 'application/json'
      }
    );
  } else if (userPrompt.toLowerCase().includes('price') || userPrompt.toLowerCase().includes('cost')) {
    return response.handoff(
      { name: 'sales-expert' },
      {
        data: JSON.stringify({ query: userPrompt, type: 'sales' }),
        contentType: 'application/json'
      }
    );
  } else if (userPrompt.toLowerCase().includes('help') || userPrompt.toLowerCase().includes('problem')) {
    return response.handoff(
      { name: 'support-expert' },
      {
        data: JSON.stringify({ query: userPrompt, type: 'support' }),
        contentType: 'application/json'
      }
    );
  } else {
    return response.text('I can help with technical, sales, or support questions. How can I assist you?');
  }
};`} />

### 4. Understanding Handoff Flow

Understanding that handoff is a one-way transfer is crucial. The final agent in the chain responds to the original client:

```
Client Request → Agent A → (handoff) → Agent B → Response to Client
                    ↓
                 (exits)
```

This is different from traditional RPC where Agent A would wait for Agent B's response.

## Understanding Handoff Constraints

Agentuity's handoff has built-in safety features and important constraints to understand:

<CodeExample py={`async def run(request, response, context):
    # CONSTRAINT 1: Can't handoff to yourself (loop detection)
    # This will raise an error:
    # return response.handoff({"name": context.agent.name}, data)

    # CONSTRAINT 2: Handoff is one-way (no response back)
    # Wrong expectation:
    # result = await response.handoff({"name": "helper"}, data)  # NO!
    # Right approach:
    return response.handoff({"name": "helper"}, data)  # Helper responds to client

    # CONSTRAINT 3: Only see agents in your project
    # Agents are isolated by project for security

    # FEATURE: Metadata persists through handoffs
    metadata = request.metadata or {}
    metadata["chain"] = metadata.get("chain", []) + [context.agent.name]
    return response.handoff(
        {"name": "next-agent"},
        data,
        metadata  # Pass context forward
    )`} js={`const handler: AgentHandler = async (request, response, context) => {
  // CONSTRAINT 1: Can't handoff to yourself (loop detection)
  // This will raise an error:
  // return response.handoff({ name: context.agent.name }, args);

  // CONSTRAINT 2: Handoff is one-way (no response back)
  // Wrong expectation:
  // const result = await response.handoff({ name: 'helper' }, args); // NO!
  // Right approach:
  return response.handoff({ name: 'helper' }, {
    data: JSON.stringify(data),
    contentType: 'application/json'
  }); // Helper responds to client

  // CONSTRAINT 3: Only see agents in your project
  // Agents are isolated by project for security

  // FEATURE: Metadata persists through handoffs
  const metadata = request.metadata || {};
  metadata.chain = (metadata.chain || []).concat(context.agent.name);
  return response.handoff(
    { name: 'next-agent' },
    {
      data: JSON.stringify(data),
      contentType: 'application/json',
      metadata  // Pass context forward
    }
  );
};`} />

## Agentuity's Built-in Features

Agentuity provides powerful built-in features for multi-agent systems:

<CodeExample py={`async def run(request, response, context):
    # Use context.sessionId for automatic request tracking
    context.logger.info(f"Processing request {context.sessionId} in {context.agent.name}")

    # Built-in OpenTelemetry tracing (automatic spans)
    # Each handoff creates a new span in the trace

    # Use agent metadata for debugging
    context.logger.debug(f"Agent ID: {context.agent.id}")
    context.logger.debug(f"Project ID: {context.projectId}")

    # Track the chain of agents
    metadata = request.metadata or {}
    agent_chain = metadata.get("agent_chain", [])
    agent_chain.append(context.agent.name)

    # Log the full chain for debugging
    context.logger.info(f"Agent chain: {' -> '.join(agent_chain)}")

    return response.handoff(
        {"name": "next-agent"},
        processed_data,
        {"agent_chain": agent_chain, "original_session_id": context.sessionId}
    )`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Use context.sessionId for automatic request tracking
  context.logger.info(\`Processing request \${context.sessionId} in \${context.agent.name}\`);

  // Built-in OpenTelemetry tracing (automatic spans)
  // Each handoff creates a new span in the trace

  // Use agent metadata for debugging
  context.logger.debug(\`Agent ID: \${context.agent.id}\`);
  context.logger.debug(\`Project ID: \${context.projectId}\`);

  // Track the chain of agents
  const metadata = request.metadata || {};
  const agentChain = metadata.agent_chain || [];
  agentChain.push(context.agent.name);

  // Log the full chain for debugging
  context.logger.info(\`Agent chain: \${agentChain.join(' -> ')}\`);

  return response.handoff(
    { name: 'next-agent' },
    {
      data: JSON.stringify(processedData),
      contentType: 'application/json',
      metadata: { agent_chain: agentChain, original_session_id: context.sessionId }
    }
  );
};`} />

## Lab: Build a Research Orchestrator System

Create a three-agent system using the orchestrator pattern with specialized agents:

1. **orchestrator**: Receives research requests and routes to specialists
2. **web-search**: Searches the web and passes results to summarizer
3. **summarizer**: Creates final research summary

### The Orchestrator Agent

This agent analyzes requests and delegates to appropriate specialists:

<CodeExample py={`async def run(request, response, context):
    """Research orchestrator that routes to specialist agents."""

    research_request = await request.data.json()
    query = research_request.get("query", "")
    research_type = research_request.get("type", "general")

    context.logger.info(f"Orchestrating research for: {query}")

    # Route based on research type
    if research_type == "web" or "search" in query.lower():
        # Route to web search specialist
        return response.handoff(
            {"name": "web-search"},
            {"query": query, "max_results": 5},
            {"orchestrator": "research-orchestrator", "original_type": research_type}
        )
    elif research_type == "summary" or "summarize" in query.lower():
        # Route directly to summarizer if we have content
        content = research_request.get("content", "")
        if content:
            return response.handoff(
                {"name": "summarizer"},
                {"content": content, "query": query},
                {"orchestrator": "research-orchestrator"}
            )

    # Default: explain what we can do
    return response.json({
        "message": "I can help with web research or summarization.",
        "examples": [
            {"type": "web", "query": "latest AI developments"},
            {"type": "summary", "content": "text to summarize", "query": "key points"}
        ]
    })`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Research orchestrator that routes to specialist agents

  const researchRequest = await request.data.json();
  const query = researchRequest.query || '';
  const researchType = researchRequest.type || 'general';

  context.logger.info(\`Orchestrating research for: \${query}\`);

  // Route based on research type
  if (researchType === 'web' || query.toLowerCase().includes('search')) {
    // Route to web search specialist
    return response.handoff(
      { name: 'web-search' },
      {
        data: JSON.stringify({ query, max_results: 5 }),
        contentType: 'application/json',
        metadata: { orchestrator: 'research-orchestrator', original_type: researchType }
      }
    );
  } else if (researchType === 'summary' || query.toLowerCase().includes('summarize')) {
    // Route directly to summarizer if we have content
    const content = researchRequest.content || '';
    if (content) {
      return response.handoff(
        { name: 'summarizer' },
        {
          data: JSON.stringify({ content, query }),
          contentType: 'application/json',
          metadata: { orchestrator: 'research-orchestrator' }
        }
      );
    }
  }

  // Default: explain what we can do
  return response.json({
    message: 'I can help with web research or summarization.',
    examples: [
      { type: 'web', query: 'latest AI developments' },
      { type: 'summary', content: 'text to summarize', query: 'key points' }
    ]
  });
};`} />

### The Web Search Agent

A specialist that searches the web and automatically forwards to summarizer:

<CodeExample py={`async def run(request, response, context):
    """Specialist agent for web searches."""

    search_params = await request.data.json()
    query = search_params.get("query")
    max_results = search_params.get("max_results", 5)

    context.logger.info(f"Searching web for: {query}")

    # Simulate web search (in production, use actual search API)
    search_results = [
        {
            "title": f"Result {i+1} for {query}",
            "snippet": f"This is a relevant snippet about {query} with detailed information...",
            "url": f"https://example.com/article-{i+1}",
            "relevance_score": 0.9 - (i * 0.1)
        }
        for i in range(max_results)
    ]

    # Automatically hand off to summarizer for final processing
    return response.handoff(
        {"name": "summarizer"},
        {
            "content": search_results,
            "original_query": query,
            "source": "web_search"
        },
        {"previous_agent": "web-search", "search_count": len(search_results)}
    )`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Specialist agent for web searches

  const searchParams = await request.data.json();
  const query = searchParams.query;
  const maxResults = searchParams.max_results || 5;

  context.logger.info(\`Searching web for: \${query}\`);

  // Simulate web search (in production, use actual search API)
  const searchResults = Array.from({ length: maxResults }, (_, i) => ({
    title: \`Result \${i + 1} for \${query}\`,
    snippet: \`This is a relevant snippet about \${query} with detailed information...\`,
    url: \`https://example.com/article-\${i + 1}\`,
    relevance_score: 0.9 - (i * 0.1)
  }));

  // Automatically hand off to summarizer for final processing
  return response.handoff(
    { name: 'summarizer' },
    {
      data: JSON.stringify({
        content: searchResults,
        original_query: query,
        source: 'web_search'
      }),
      contentType: 'application/json',
      metadata: { previous_agent: 'web-search', search_count: searchResults.length }
    }
  );
};`} />

### The Summarizer Agent

Takes search results and creates a final research summary:

<CodeExample py={`async def run(request, response, context):
    """Specialist agent for summarizing research content."""

    summary_request = await request.data.json()
    content = summary_request.get("content", [])
    original_query = summary_request.get("original_query", "")
    source = summary_request.get("source", "unknown")

    context.logger.info(f"Summarizing {len(content)} items for query: {original_query}")

    # Process different content types
    if source == "web_search" and isinstance(content, list):
        # Handle web search results
        summary_parts = []
        for i, item in enumerate(content[:3]):  # Top 3 results
            if isinstance(item, dict):
                title = item.get("title", "")
                snippet = item.get("snippet", "")
                url = item.get("url", "")
                relevance = item.get("relevance_score", 0)
                summary_parts.append({
                    "rank": i + 1,
                    "title": title,
                    "summary": snippet,
                    "source_url": url,
                    "relevance": relevance
                })

        final_summary = {
            "query": original_query,
            "summary": f"Research Summary for '{original_query}'",
            "key_findings": summary_parts,
            "total_sources": len(content),
            "research_completed_at": datetime.now().isoformat(),
            "agent_chain": ["orchestrator", "web-search", "summarizer"]
        }
    else:
        # Handle direct text content
        final_summary = {
            "query": original_query,
            "summary": f"Summary of content for '{original_query}'",
            "content_length": len(str(content)),
            "processed_at": datetime.now().isoformat(),
            "agent_chain": ["orchestrator", "summarizer"]
        }

    # Return the final research summary to the user
    return response.json(final_summary)`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Specialist agent for summarizing research content

  const summaryRequest = await request.data.json();
  const content = summaryRequest.content || [];
  const originalQuery = summaryRequest.original_query || '';
  const source = summaryRequest.source || 'unknown';

  context.logger.info(\`Summarizing \${Array.isArray(content) ? content.length : 1} items for query: \${originalQuery}\`);

  // Process different content types
  let finalSummary;

  if (source === 'web_search' && Array.isArray(content)) {
    // Handle web search results
    const summaryParts = content.slice(0, 3).map((item, i) => ({
      rank: i + 1,
      title: item.title || '',
      summary: item.snippet || '',
      source_url: item.url || '',
      relevance: item.relevance_score || 0
    }));

    finalSummary = {
      query: originalQuery,
      summary: \`Research Summary for '\${originalQuery}'\`,
      key_findings: summaryParts,
      total_sources: content.length,
      research_completed_at: new Date().toISOString(),
      agent_chain: ['orchestrator', 'web-search', 'summarizer']
    };
  } else {
    // Handle direct text content
    finalSummary = {
      query: originalQuery,
      summary: \`Summary of content for '\${originalQuery}'\`,
      content_length: String(content).length,
      processed_at: new Date().toISOString(),
      agent_chain: ['orchestrator', 'summarizer']
    };
  }

  // Return the final research summary to the user
  return response.json(finalSummary);
};`} />

## Testing Your Research Orchestrator

Test the research orchestrator system:

```bash
# Test web research routing
curl -X POST https://your-project.agentuity.com/agents/orchestrator \
  -H "Content-Type: application/json" \
  -d '{
    "type": "web",
    "query": "latest developments in AI agents"
  }'

# Test direct summarization routing
curl -X POST https://your-project.agentuity.com/agents/orchestrator \
  -H "Content-Type: application/json" \
  -d '{
    "type": "summary",
    "query": "key points",
    "content": "Long text content to be summarized..."
  }'
```

Expected flow for web research:
1. `orchestrator` analyzes request and routes to web-search
2. `web-search` finds results and forwards to summarizer
3. `summarizer` creates final research summary and responds to client

## Key Takeaways

- **Multi-agent systems** enable specialization, scalability, and modularity
- **Handoff mechanism** allows agents to delegate tasks in a simple, sequential manner
- **Orchestration patterns** include sequential chains, conditional routing, and smart orchestration
- **Constraints matter**: Handoffs are one-way, agents can't call themselves, and responses go directly to clients
- **Agentuity simplifies** multi-agent coordination with built-in agent resolution and communication

## What's Next?

Now that you can build multi-agent systems, Module 5 will cover **Guardrails & Observability** - how to ensure your agent teams behave safely and predictably in production.

Questions to consider:
- How do you prevent agents from taking harmful actions?
- How do you track what decisions agents are making?
- How do you ensure compliance and audit requirements?

Continue to [Module 5: Guardrails & Observability →](./05-guardrails-evals-observability)