---
title: "Module 2: The Anatomy of an Agent"
description: Understanding how agents work - planning, reasoning, tools, and memory
---

Now that you've built your first agent, let's dive deeper to understand what makes agents tick. We'll explore the core components that transform a simple script into an autonomous, intelligent system.

## The Agent Lifecycle

Every agent interaction follows a predictable lifecycle, from receiving a trigger to returning a response. Understanding this flow is crucial for building effective agents.

<Mermaid chart="
graph TD
    A[Trigger Event<br/>HTTP, Cron, Email, etc.] --> B[Parse Request<br/>Extract data and metadata]
    B --> C[Agent Handler<br/>Your agent/run function executes]
    C --> D[Process Logic<br/>Business logic and decisions]
    D --> E[Access Storage<br/>KV, Vector, Object store]
    E --> F[Generate Response<br/>JSON, text, binary, etc. or handoff to another agent]
    F --> G[Return to Caller<br/>Client receives result]
" />

Let's explore each phase:

### 1. Trigger Events

Agents spring into action when triggered. Agentuity supports multiple trigger types:

| Trigger Type | Description | Use Case |
|-------------|-------------|----------|
| **webhook** | HTTP endpoint call | REST APIs, external integrations |
| **cron** | Scheduled execution | Batch processing, periodic tasks |
| **manual** | Console/CLI invocation | Testing, one-off tasks |
| **agent** | Called by another agent | Multi-agent workflows |
| **sms** | SMS message received | Text-based interactions |
| **email** | Email received | Email automation |
| **queue** | Message queue event | Async processing |

Each trigger provides different metadata and context:

<CodeExample py={`async def run(request, response, context):
    # Identify the trigger type
    trigger = request.trigger
    
    if trigger == "webhook":
        # Handle HTTP request
        data = await request.data.json()
        context.logger.info(f"Webhook triggered with data: {data}")
    
    elif trigger == "cron":
        # Handle scheduled execution
        context.logger.info(f"Cron job running at {datetime.now()}")
        # No input data for cron triggers
    
    elif trigger == "agent":
        # Handle agent-to-agent call
        calling_agent = request.metadata.get("source_agent")
        context.logger.info(f"Called by agent: {calling_agent}")
    
    return response.json({
        "trigger_type": trigger,
        "processed_at": datetime.now().isoformat()
    })`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Identify the trigger type
  const trigger = request.trigger;
  
  if (trigger === 'webhook') {
    // Handle HTTP request
    const data = await request.data.json();
    context.logger.info(\`Webhook triggered with data: \${JSON.stringify(data)}\`);
  
  } else if (trigger === 'cron') {
    // Handle scheduled execution
    context.logger.info(\`Cron job running at \${new Date().toISOString()}\`);
    // No input data for cron triggers
  
  } else if (trigger === 'agent') {
    // Handle agent-to-agent call
    const callingAgent = request.metadata.get('source_agent');
    context.logger.info(\`Called by agent: \${callingAgent}\`);
  }
  
  return response.json({
    trigger_type: trigger,
    processed_at: new Date().toISOString()
  });
};`} />

### 2. Request and Response Handling

Every agent receives a request and must return a response. The request contains the trigger data and metadata, while the response can be in various formats:

<CodeExample py={`async def run(request, response, context):
    # Access request data in different formats
    
    # JSON data (most common)
    json_data = await request.data.json()
    
    # Plain text
    text_data = await request.data.text()
    
    # Binary data
    binary_data = await request.data.binary()
    
    # Base64 encoded
    base64_data = await request.data.base64()
    
    # Response options
    
    # JSON response (most common)
    return response.json({"result": "success"})
    
    # Text response
    # return response.text("Hello, World!")
    
    # HTML response
    # return response.html("<h1>Hello</h1>")
    
    # Binary response (for files)
    # return response.binary(file_bytes)
    
    # Redirect to another agent
    # return response.handoff({"name": "other-agent"}, data, metadata={})`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Access request data in different formats
  
  // JSON data (most common)
  const jsonData = await request.data.json();
  
  // Plain text
  const textData = await request.data.text();
  
  // Binary data
  const binaryData = await request.data.binary();
  
  // Base64 encoded
  const base64Data = await request.data.base64();
  
  // Response options
  
  // JSON response (most common)
  return response.json({ result: 'success' });
  
  // Text response
  // return response.text('Hello, World!');
  
  // HTML response
  // return response.html('<h1>Hello</h1>');
  
  // Binary response (for files)
  // return response.binary(fileBytes);
  
  // Redirect to another agent
  // return response.handoff({ name: 'other-agent' }, { data: jsonData, contentType: 'application/json' });
};`} />

### 3. The Agent Context

The context object is your agent's gateway to Agentuity's services. It provides access to storage, logging, tracing, and more:

<CodeExample py={`async def run(request, response, context):
    # Logging at different levels
    context.logger.debug("Debug information")
    context.logger.info("General information")
    context.logger.warn("Warning message")
    context.logger.error("Error occurred")
    
    # Access metadata
    agent_id = context.agent.id
    agent_name = context.agent.name
    project_id = context.projectId
    session_id = context.sessionId
    
    # Key-Value storage
    await context.kv.set("cache", "key", {"data": "value"})
    result = await context.kv.get("cache", "key")
    
    # Vector storage for semantic search
    await context.vector.upsert("docs", [{
        "key": "doc1",
        "document": "AI agents are autonomous systems",
        "metadata": {"category": "intro"}
    }])
    
    # Object storage for files
    await context.objectstore.put("files", "report.pdf", pdf_bytes)
    
    return response.json({
        "agent": agent_name,
        "session": session_id
    })`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Logging at different levels
  context.logger.debug('Debug information');
  context.logger.info('General information');
  context.logger.warn('Warning message');
  context.logger.error('Error occurred');
  
  // Access metadata
  const agentId = context.agent.id;
  const agentName = context.agent.name;
  const projectId = context.projectId;
  const sessionId = context.sessionId;
  
  // Key-Value storage
  await context.kv.set('cache', 'key', JSON.stringify({ data: 'value' }));
  const result = await context.kv.get('cache', 'key');
  
  // Vector storage for semantic search
  await context.vector.upsert('docs', {
    key: 'doc1',
    document: 'AI agents are autonomous systems',
    metadata: { category: 'intro' }
  });
  
  // Object storage for files
  await context.objectstore.put('files', 'report.pdf', pdfBytes);
  
  return response.json({
    agent: agentName,
    session: sessionId
  });
};`} />

## Planning and Reasoning: The Agent's Brain

What separates agents from simple scripts is their ability to plan and reason. While Agentuity provides the infrastructure, you implement the intelligence.

### The Planning Phase

Planning is how agents break down complex requests into actionable steps. According to [OpenAI's practical guide to building agents](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf), providing smaller, clearer steps from dense resources helps minimize ambiguity and helps the model better follow instructions. Effective agent planning involves:

1. **Intent Recognition**: Understanding what the user actually wants
2. **Task Decomposition**: Breaking complex requests into smaller steps
3. **Resource Assessment**: Determining what tools and data are needed
4. **Execution Strategy**: Deciding the order and approach for each step

Modern agents use LLMs for dynamic planning rather than hard-coded decision trees, allowing them to adapt their approach based on context and available resources.

### The Reasoning Loop

The reasoning loop is where agents continuously evaluate and adapt their approach. [Stanford's research on ReAct agents](https://arxiv.org/abs/2210.03629) shows that combining reasoning and acting in iterative loops significantly improves agent performance.

The basic pattern follows:
1. **Observe**: Analyze current state and available information
2. **Think**: Reason about the best next action
3. **Act**: Execute the chosen action
4. **Reflect**: Evaluate the results and learn
5. **Repeat**: Continue until goal is achieved or constraints are met

This iterative approach allows agents to handle uncertainty and recover from errors - key capabilities that distinguish agents from simple scripts.

## Tool Invocation: Extending Agent Capabilities

Agents become powerful when they can use external tools and services:

<CodeExample py={`import httpx
import os
from typing import Dict, Any

async def use_web_search(query: str, context) -> Dict[str, Any]:
    """Search the web using a real API."""
    try:
        # Example using a hypothetical search API
        api_key = os.getenv("SEARCH_API_KEY")
        if not api_key:
            context.logger.warn("No search API key found")
            return {"error": "Search not available"}

        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.searxng.org/search",
                params={"q": query, "format": "json"}
            )
            return response.json()
    except Exception as e:
        context.logger.error(f"Search failed: {str(e)}")
        return {"error": "Search failed"}

async def call_another_agent(agent_name: str, data: dict, context) -> Dict[str, Any]:
    """Call another agent within the same project."""
    try:
        agent = await context.getAgent({"name": agent_name})
        result = await agent.run({
            "data": data,
            "contentType": "application/json"
        })
        return await result.data.json()
    except Exception as e:
        context.logger.error(f"Agent call failed: {str(e)}")
        return {"error": "Agent call failed"}

async def run(request, response, context):
    data = await request.data.json()
    tool = data.get("tool")

    if tool == "search":
        result = await use_web_search(data["query"], context)
    elif tool == "delegate":
        result = await call_another_agent(data["agent"], data["task"], context)
    else:
        result = {"error": "Unknown tool"}

    return response.json(result)`} js={`async function useWebSearch(query: string, context: any): Promise<any> {
  try {
    // Example using a hypothetical search API
    const apiKey = process.env.SEARCH_API_KEY;
    if (!apiKey) {
      context.logger.warn('No search API key found');
      return { error: 'Search not available' };
    }

    const response = await fetch('https://api.searxng.org/search?' +
      new URLSearchParams({ q: query, format: 'json' }));
    return await response.json();
  } catch (error) {
    context.logger.error(\`Search failed: \${error}\`);
    return { error: 'Search failed' };
  }
}

async function callAnotherAgent(agentName: string, data: any, context: any): Promise<any> {
  try {
    const agent = await context.getAgent({ name: agentName });
    const result = await agent.run({
      data,
      contentType: 'application/json'
    });
    return await result.data.json();
  } catch (error) {
    context.logger.error(\`Agent call failed: \${error}\`);
    return { error: 'Agent call failed' };
  }
}

const handler: AgentHandler = async (request, response, context) => {
  const data = await request.data.json();
  const tool = data.tool;

  let result;
  if (tool === 'search') {
    result = await useWebSearch(data.query, context);
  } else if (tool === 'delegate') {
    result = await callAnotherAgent(data.agent, data.task, context);
  } else {
    result = { error: 'Unknown tool' };
  }

  return response.json(result);
};`} />

## Memory Patterns: How Agents Remember

Memory enables agents to learn and maintain state across interactions. The duration and type of memory depends on your use case and TTL settings.

### Session Memory
For temporary data that should expire:

<CodeExample py={`from datetime import datetime

async def run(request, response, context):
    session_id = request.metadata.get("session_id")

    # Store temporary session data with TTL
    await context.kv.set(
        "sessions",
        session_id,
        {
            "messages": [],
            "user_preferences": {},
            "started_at": datetime.now().isoformat()
        },
        {"ttl": 3600}  # Expires in 1 hour
    )

    # Retrieve session data
    session_data = await context.kv.get("sessions", session_id)
    if session_data.exists:
        data = await session_data.data.json()
        context.logger.info(f"Session active for {len(data['messages'])} messages")`} js={`const handler: AgentHandler = async (request, response, context) => {
  const sessionId = request.metadata.get('session_id');

  // Store temporary session data with TTL
  await context.kv.set(
    'sessions',
    sessionId,
    JSON.stringify({
      messages: [],
      context: {},
      timestamp: new Date().toISOString()
    }),
    { ttl: 3600 } // Expires in 1 hour
  );
};`} />

### Persistent Memory
For data that should survive restarts:

<CodeExample py={`async def run(request, response, context):
    user_id = request.metadata.get("user_id")

    # Store user preferences permanently (no TTL)
    await context.kv.set(
        "user_profiles",
        user_id,
        {
            "name": "Alice",
            "preferences": {"format": "concise"},
            "created_at": datetime.now().isoformat()
        }
        # No TTL = permanent storage
    )

    # Store large files in object storage
    await context.objectstore.put(
        "user_documents",
        f"{user_id}/resume.pdf",
        pdf_bytes
    )`} js={`const handler: AgentHandler = async (request, response, context) => {
  const userId = request.metadata.get('user_id');

  // Store user preferences permanently (no TTL)
  await context.kv.set(
    'user_profiles',
    userId,
    {
      name: 'Alice',
      preferences: { format: 'concise' },
      created_at: new Date().toISOString()
    }
    // No TTL = permanent storage
  );

  // Store large files in object storage
  await context.objectstore.put(
    'user_documents',
    \`\${userId}/resume.pdf\`,
    pdfBytes
  );
};`} />

### Searchable Memory
For semantic search and knowledge retrieval:

<CodeExample py={`async def run(request, response, context):
    # Store searchable knowledge
    await context.vector.upsert("knowledge", [{
        "key": "user_feedback_001",
        "document": "Users prefer concise responses with examples",
        "metadata": {
            "learned_from": "user_feedback",
            "confidence": 0.85,
            "category": "response_style"
        }
    }])

    # Search for relevant knowledge
    results = await context.vector.search(
        "knowledge",
        "How should I format my responses?",
        limit=5
    )

    # Use the knowledge to improve responses
    if results:
        context.logger.info(f"Found {len(results)} relevant insights")
        for result in results:
            context.logger.info(f"Insight: {result.document}")`} js={`const handler: AgentHandler = async (request, response, context) => {
  // Store searchable knowledge
  await context.vector.upsert('knowledge', [{
    key: 'user_feedback_001',
    document: 'Users prefer concise responses with examples',
    metadata: {
      learned_from: 'user_feedback',
      confidence: 0.85,
      category: 'response_style'
    }
  }]);

  // Search for relevant knowledge
  const results = await context.vector.search(
    'knowledge',
    'How should I format my responses?',
    { limit: 5 }
  );

  // Use the knowledge to improve responses
  if (results.length > 0) {
    context.logger.info(\`Found \${results.length} relevant insights\`);
    results.forEach(result => {
      context.logger.info(\`Insight: \${result.document}\`);
    });
  }
};`} />

## Framework Awareness: Choosing the Right Tool

<Callout type="info">
Agentuity is framework-agnostic. You can use any AI framework or build custom agents from scratch.
</Callout>

### Popular Agent Frameworks

Different frameworks excel at different tasks. Here's when to use each:

| Framework | Best For | Language Support | Agentuity Integration |
|-----------|----------|------------------|----------------------|
| **LangChain** | Complex chains, RAG applications | Python, TypeScript | Native SDK support |
| **CrewAI** | Multi-agent teams, role-based systems | Python | Container deployment |
| **AutoGen** | Research, conversational AI | Python | Direct deployment |
| **Custom** | Specific requirements, full control | Python, TypeScript, Bun | Full platform features |

### Framework Comparison Example

Here's the same agent built with different approaches:

<CodeExample py={`# Vanilla Python Agent
async def run(request, response, context):
    data = await request.data.json()
    # Direct implementation
    result = process_data(data)
    return response.json(result)

# LangChain Agent
from langchain.agents import initialize_agent
from langchain.llms import OpenAI

async def run(request, response, context):
    llm = OpenAI()
    agent = initialize_agent(tools, llm, agent="zero-shot")
    result = agent.run(await request.data.text())
    return response.text(result)

# CrewAI Agent
from crewai import Agent, Task, Crew

async def run(request, response, context):
    researcher = Agent(role="Researcher", goal="Find information")
    writer = Agent(role="Writer", goal="Create content")
    
    crew = Crew(agents=[researcher, writer])
    result = crew.kickoff(await request.data.json())
    return response.json(result)`} js={`// Vanilla TypeScript Agent
const handler: AgentHandler = async (request, response, context) => {
  const data = await request.data.json();
  // Direct implementation
  const result = processData(data);
  return response.json(result);
};

// LangChain Agent
import { initializeAgentExecutor } from 'langchain/agents';
import { OpenAI } from 'langchain/llms/openai';

const handler: AgentHandler = async (request, response, context) => {
  const llm = new OpenAI();
  const agent = await initializeAgentExecutor(tools, llm, 'zero-shot');
  const result = await agent.call({ input: await request.data.text() });
  return response.text(result.output);
};

// Custom Multi-Agent System
const handler: AgentHandler = async (request, response, context) => {
  const researcher = new Agent('Researcher', 'Find information');
  const writer = new Agent('Writer', 'Create content');
  
  const researchResult = await researcher.execute(data);
  const writeResult = await writer.execute(researchResult);
  return response.json(writeResult);
};`} />

### When to Use Which Framework

| Framework | Use When You Need | Avoid When You Need |
|-----------|-------------------|-------------------|
| **LangChain** | Complex reasoning chains, RAG applications, extensive data integrations | Simple agents, minimal dependencies, lightweight solutions |
| **CrewAI** | Multi-agent teams, role-based collaboration, specialized workflows | Single-agent tasks, simple request-response patterns |
| **AutoGen** | Conversational AI, research applications, experimental workflows | Production deployments, strict performance requirements |
| **Custom** | Full control, specific requirements, optimized performance | Rapid prototyping, standard use cases, extensive tooling needs |

## Lab: Building a Weather Agent with Multiple Triggers

Let's build an agent that demonstrates different behaviors based on how it's triggered. This weather agent will show you how the same code can serve different purposes:

<CodeExample py={`from datetime import datetime

async def run(request, response, context):
    """Weather agent with different trigger behaviors."""

    trigger = request.trigger
    context.logger.info(f"Weather agent triggered via: {trigger}")

    if trigger == "webhook":
        # Manual requests for specific cities
        try:
            data = await request.data.json()
            city = data.get("city", "London")
        except:
            city = await request.data.text() or "London"

        context.logger.info(f"Manual weather request for: {city}")

        # Check cache first (10 minutes TTL)
        cache_key = f"weather_{city.lower()}"
        cached = await context.kv.get("weather_cache", cache_key)

        if cached.exists:
            weather = await cached.data.json()
            context.logger.info(f"Returning cached weather for {city}")
            return response.json({
                **weather,
                "cached": True,
                "cache_age_minutes": 5  # Mock age
            })

        # Mock weather data (in production, call real API)
        weather = {
            "city": city,
            "temperature": 22,
            "description": "partly cloudy",
            "humidity": 65,
            "timestamp": datetime.now().isoformat()
        }

        # Cache for 10 minutes
        await context.kv.set("weather_cache", cache_key, weather, {"ttl": 600})

        return response.json({**weather, "cached": False})

    elif trigger == "cron":
        # Batch update for major cities
        cities = ["London", "New York", "Tokyo", "Sydney"]
        context.logger.info(f"Cron job: Updating weather for {len(cities)} cities")

        weather_data = {}
        for city in cities:
            # Mock weather data
            weather_data[city] = {
                "temperature": 20 + hash(city) % 15,  # Mock variation
                "description": "sunny",
                "updated": datetime.now().isoformat()
            }

        # Store daily weather report
        await context.kv.set("weather_reports", "daily", weather_data, {"ttl": 86400})

        return response.json({
            "task": "weather_update",
            "cities_updated": len(cities),
            "timestamp": datetime.now().isoformat()
        })

    elif trigger == "manual":
        # DevMode testing - show available commands
        return response.json({
            "message": "Weather Agent DevMode",
            "commands": [
                "Test webhook: POST {\"city\": \"Paris\"}",
                "Test cron: Use simulate button in DevMode"
            ],
            "current_time": datetime.now().isoformat()
        })

    else:
        return response.json({
            "error": f"Unsupported trigger: {trigger}",
            "supported": ["webhook", "cron", "manual"]
        })`} js={`const handler: AgentHandler = async (request, response, context) => {
  const trigger = request.trigger;
  context.logger.info(\`Weather agent triggered via: \${trigger}\`);

  if (trigger === 'webhook') {
    // Manual requests for specific cities
    let city = 'London';
    try {
      const data = await request.data.json();
      city = data.city || 'London';
    } catch {
      city = await request.data.text() || 'London';
    }

    context.logger.info(\`Manual weather request for: \${city}\`);

    // Check cache first (10 minutes TTL)
    const cacheKey = \`weather_\${city.toLowerCase()}\`;
    const cached = await context.kv.get('weather_cache', cacheKey);

    if (cached.exists) {
      const weather = await cached.data.json();
      context.logger.info(\`Returning cached weather for \${city}\`);
      return response.json({
        ...weather,
        cached: true,
        cache_age_minutes: 5  // Mock age
      });
    }

    // Mock weather data (in production, call real API)
    const weather = {
      city,
      temperature: 22,
      description: 'partly cloudy',
      humidity: 65,
      timestamp: new Date().toISOString()
    };

    // Cache for 10 minutes
    await context.kv.set('weather_cache', cacheKey, weather, { ttl: 600 });

    return response.json({ ...weather, cached: false });

  } else if (trigger === 'cron') {
    // Batch update for major cities
    const cities = ['London', 'New York', 'Tokyo', 'Sydney'];
    context.logger.info(\`Cron job: Updating weather for \${cities.length} cities\`);

    const weatherData: Record<string, any> = {};
    cities.forEach(city => {
      // Mock weather data with variation
      weatherData[city] = {
        temperature: 20 + (city.length % 15),  // Mock variation
        description: 'sunny',
        updated: new Date().toISOString()
      };
    });

    // Store daily weather report
    await context.kv.set('weather_reports', 'daily', weatherData, { ttl: 86400 });

    return response.json({
      task: 'weather_update',
      cities_updated: cities.length,
      timestamp: new Date().toISOString()
    });

  } else if (trigger === 'manual') {
    // DevMode testing - show available commands
    return response.json({
      message: 'Weather Agent DevMode',
      commands: [
        'Test webhook: POST {"city": "Paris"}',
        'Test cron: Use simulate button in DevMode'
      ],
      current_time: new Date().toISOString()
    });

  } else {
    return response.json({
      error: \`Unsupported trigger: \${trigger}\`,
      supported: ['webhook', 'cron', 'manual']
    });
  }
};`} />

### Testing Your Weather Agent

<Callout type="info">
DevMode makes it easy to test all trigger types. You can simulate webhooks, test manual triggers, and even simulate cron jobs through the interface.
</Callout>

#### What This Agent Demonstrates

- **Webhook trigger**: Handles real-time weather requests with caching
- **Cron trigger**: Batch updates for multiple cities
- **Manual trigger**: DevMode testing and debugging interface
- **Caching strategy**: Uses TTL to balance freshness and performance
- **Error handling**: Graceful fallbacks for different input types

Try calling this agent with different cities and watch how it caches responses for efficiency!

<CodeExample py={`def welcome():
    """Configure test scenarios for different trigger types."""
    return {
        "welcome": "Multi-Trigger Agent Test Suite",
        "prompts": [
            # Webhook trigger tests
            {
                "data": {"action": "store", "key": "test", "value": "data"},
                "contentType": "application/json"
            },
            {
                "data": {"action": "retrieve", "key": "test"},
                "contentType": "application/json"
            },
            # Simulate what a cron trigger would do
            {
                "data": {"_simulate_cron": True},
                "contentType": "application/json"
            },
            # Simulate agent-to-agent communication
            {
                "data": {"message": "Hello from another agent", "source_agent": "agent_123"},
                "contentType": "application/json"
            }
        ]
    }`} js={`export const welcome = () => {
    return {
        welcome: "Multi-Trigger Agent Test Suite",
        prompts: [
            // Webhook trigger tests
            {
                data: JSON.stringify({ action: "store", key: "test", value: "data" }),
                contentType: "application/json"
            },
            {
                data: JSON.stringify({ action: "retrieve", key: "test" }),
                contentType: "application/json"
            },
            // Simulate what a cron trigger would do
            {
                data: JSON.stringify({ _simulate_cron: true }),
                contentType: "application/json"
            },
            // Simulate agent-to-agent communication
            {
                data: JSON.stringify({ message: "Hello from another agent", source_agent: "agent_123" }),
                contentType: "application/json"
            }
        ]
    };
};`} />

#### Testing in DevMode

1. **Start DevMode:**
```bash
agentuity dev
```

2. **Open the DevMode interface** and click the pre-configured prompts to test different scenarios

3. **Monitor the execution** in the Logs and Sessions tabs

#### Configuring Cron Triggers for Production

For actual scheduled execution, configure cron triggers through the [Agentuity Console](https://app.agentuity.com):

1. Navigate to your agent in the Console
2. Click on **"Add Trigger"** and select **"Cron Job"**
3. Configure the schedule using cron syntax (e.g., `0 * * * *` for hourly)
4. Set the Content Type and optional Payload
5. Enable the trigger and save

<Callout type="info">
Learn more about configuring triggers in the [Agent Configuration Guide](/Cloud/agents).
</Callout>

## Performance Considerations

Building efficient agents requires thinking about performance from the start:

### Cost Optimization

Effective cost optimization strategies include:

- **Cache frequently used data** in KV storage to reduce repeated processing
- **Batch operations** when possible to minimize API calls
- **Use appropriate LLM models** - use reasoning models (like GPT-4) only when you need complex reasoning
- **Consider fast inference providers** - Groq offers high-speed inference for many models
- **Implement early exits** in reasoning loops to avoid unnecessary iterations

### Latency vs. Capability Trade-offs

| Approach | Latency | Capability | Use Case |
|----------|---------|------------|----------|
| Simple rules | &lt;100ms | Low | Basic routing |
| Small LLM | 200-500ms | Medium | Classification |
| Large LLM | 1-3s | High | Complex reasoning |
| Multi-agent | 3-10s | Very High | Research tasks |

<CodeExample py={`async def run(request, response, context):
    data = await request.data.json()
    complexity = assess_complexity(data)
    
    if complexity == "simple":
        # Use rules-based approach
        result = apply_rules(data)
        return response.json(result)
    
    elif complexity == "medium":
        # Use small, fast model
        result = await small_model_process(data)
        return response.json(result)
    
    else:
        # Use full agent capabilities
        result = await full_agent_process(data, context)
        return response.json(result)`} js={`const handler: AgentHandler = async (request, response, context) => {
  const data = await request.data.json();
  const complexity = assessComplexity(data);
  
  if (complexity === 'simple') {
    // Use rules-based approach
    const result = applyRules(data);
    return response.json(result);
  
  } else if (complexity === 'medium') {
    // Use small, fast model
    const result = await smallModelProcess(data);
    return response.json(result);
  
  } else {
    // Use full agent capabilities
    const result = await fullAgentProcess(data, context);
    return response.json(result);
  }
};`} />

## Key Takeaways

- **Agents follow a lifecycle**: Trigger → Plan → Reason → Execute → Remember → Respond
- **Multiple trigger types**: Choose the right trigger for your use case
- **Context is powerful**: It provides access to all Agentuity services
- **Frameworks are tools**: Pick the right one for your needs, or go custom
- **Memory patterns matter**: Session data (TTL), persistent data (no TTL), searchable knowledge (Vector)
- **Performance matters**: Balance capability with cost and latency

## What's Next?

You now understand the core components that make agents work. In the next module, we'll dive deep into memory systems - how agents remember, learn, and improve over time.

But first, experiment with the weather agent:
- Test it with different cities
- Try the caching behavior with repeated requests
- Add new cities to the cron batch update
- Modify the cache TTL and observe the difference

Remember: The anatomy you've learned here is the foundation. The intelligence you add on top is what makes your agents unique.

---

**Ready for Module 3?** [Agent Memory](./03-agent-memory)