---
title: "Module 2: The Anatomy of an Agent"
description: Understanding the core components that make agents work - triggers, requests, logging, and storage
---

Now that you've built your first agent, let's dive deeper to understand what makes agents tick. In this module, you'll learn the fundamental building blocks every agent shares, then see them combined in a real-world weather agent.

## The Agent Lifecycle

Every agent interaction follows a predictable lifecycle, from receiving a trigger to returning a response. Understanding this flow is crucial for building effective agents.

<Mermaid chart="
graph TD
    A[Trigger Event<br/>HTTP, Cron, Email, etc.] --> B[Parse Request<br/>Extract data and metadata]
    B --> C[Agent Handler<br/>Your agent/run function executes]
    C --> D[Process Logic<br/>Business logic and decisions]
    D --> E[Access Storage<br/>KV, Vector, Object store]
    E --> F[Generate Response<br/>JSON, text, binary, etc. or handoff to another agent]
    F --> G[Return to Caller<br/>Client receives result]
" />

Agents follow this lifecycle regardless of complexity—from simple greeting agents to more complex multi-step (or multi-agent) solutions. Let's explore each phase to understand what makes this lifecycle powerful.

## Planning and Reasoning: The Agent's Brain

What separates agents from simple scripts is their ability to plan and reason. While Agentuity provides the infrastructure (triggers, storage, logging), you implement the logic to make your agent(s) do something useful.

### The Planning Phase

Planning is how agents break down complex requests into actionable steps. According to [OpenAI's practical guide to building agents](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf), providing smaller, clearer steps from dense resources helps minimize ambiguity and helps the model better follow instructions.

Effective agent planning involves:

1. **Intent Recognition**: Understanding what the user actually wants
2. **Task Decomposition**: Breaking complex requests into smaller steps
3. **Resource Assessment**: Determining what tools and data are needed
4. **Execution Strategy**: Deciding the order and approach for each step

As a result, agents use LLMs to adapt their approach based on context and available resources, rather than use hard-coded logic (i.e. decision trees).

### The Reasoning Loop

The reasoning loop is where agents continuously evaluate and adapt their approach. [Stanford's research on ReAct agents](https://arxiv.org/abs/2210.03629) shows that combining reasoning and acting in iterative loops significantly improves agent performance.

The basic pattern follows:
1. **Observe** - Analyze current state and available information
2. **Think** - Reason about the best next action
3. **Act** - Execute the chosen action
4. **Reflect** - Evaluate the results and learn
5. **Repeat** - Continue until goal is achieved or constraints are met

This iterative approach allows agents to handle uncertainty and recover from errors—key capabilities that distinguish agents from simple scripts.

You'll implement these patterns in a basic way, using the anatomy concepts you'll learn next: triggers to determine when to start, logging to track decisions, storage to maintain state, and responses to deliver results.

## Core Components of Agent Anatomy

Now that you understand the theory, let's dive into the practical components. Every agent is built from the same fundamental building blocks:

### 1. Triggers

Agents spring into action when triggered. Agentuity supports multiple trigger types:

| Trigger Type | Description | Use Case |
|-------------|-------------|----------|
| **webhook** | HTTP endpoint call | REST APIs, external integrations |
| **cron** | Scheduled execution | Batch processing, periodic tasks |
| **manual** | DevMode/CLI invocation | Testing, one-off tasks |
| **agent** | Called by another agent | Multi-agent workflows |
| **sms** | SMS message received | Text-based interactions |
| **email** | Email received | Email automation |
| **queue** | Message queue event | Async processing |

But these triggers are not mutually exclusive. Agents on Agentuity can be triggered *by multiple triggers*, and can behave differently based on the trigger.

For example, a weather agent might use the following triggers:
- **Webhook**: Return weather for a user-requested location
- **Cron**: Update cached weather data for monitoring dashboards
- **Manual**: Test behavior (locally, via DevMode) during development

### 2. Request and Response

Every agent receives a **request** containing data and metadata, and must return a **response**.

**Request Data Formats:**
- `request.data.json()` - Parse JSON data
- `request.data.text()` - Get plain text
- `request.data.binary()` - Get binary data
- `request.data.email()`, `request.data.pdf()`, etc. - Specialized formats
- *(and many more...)*

**Request Metadata:**
- `request.metadata` - Property returning the full metadata dict/object
- `request.get(key, default)` - Convenience method for accessing metadata values
- `request.trigger` - Property identifying how the agent was invoked

**Response Formats:**
- `response.json(data)` - Most common, structured data
- `response.text(data)` - Plain text
- `response.html(data)` - HTML content
- `response.empty()` - No content (useful for webhooks or to handle cases where no "actual" response is needed)
- `response.binary(data)` - Binary data
- Media-specific: `pdf()`, `png()`, `jpeg()`, `mp3()`, etc.

### 3. The Agent Context

The `context` object is your agent's way to access core Agentuity services, including:

**Storage & Data:**
- `context.kv` - Key-value storage for caching and state
- `context.vector` - Vector storage for semantic search
- `context.objectstore` - Object storage for files

**Observability:**
- `context.logger` - Structured logging with levels (info, warn, error, debug)
- `context.tracer` - built-in OpenTelemetry tracing

**Communication:**
- `context.getAgent()` - Access other agents for multi-agent workflows

**Metadata:**
- `context.agent` - Current agent info (id, name)
- `context.sessionId` - Current session identifier
- `context.projectId` - Current project identifier

<Callout type="info">
See the [JavaScript SDK API Reference](/SDKs/javascript/api-reference) or [Python SDK API Reference](/SDKs/python/api-reference) for complete details.
</Callout>

### 4. Storage for State and Memory

Agentuity provides three storage APIs that enable different memory patterns:

- **Session memory (KV with TTL)** - Temporary data that expires (e.g., 5-minute cache)
- **Persistent memory (KV without TTL)** - Data that survives restarts
- **Searchable memory (Vector)** - Semantic search and knowledge retrieval
- **File storage (Object)** - Binary files, documents, images, and media

We'll explore memory patterns in depth in **Module 3: Agent Memory**.

### 5. Framework Awareness

<Callout type="info">
Agentuity is framework-agnostic. Use any AI framework (LangChain, CrewAI, Vercel AI SDK, etc.) or build custom agents from scratch. The anatomy concepts work with all of them. See [Templates](/Introduction/templates) for starter examples.
</Callout>

Different frameworks excel at different tasks, but they all use the same Agentuity SDK anatomy:
- All receive `request`, `response`, `context` parameters
- All access triggers, data, logging, and storage the same way
- All return responses in standard formats

As a result, you can choose your framework *based on your use case*, not platform constraints. Plus, you can use multiple frameworks in the same project, or even run agents on different frameworks in the same project.

## Build Agent Anatomy Step-by-Step

Now let's get hands-on. Each step below focuses on one core concept, with simple code you can run immediately in DevMode.

### Step 1: Understanding Triggers

<TutorialStep number={1} title="Understanding Triggers" estimatedTime="3 min">

Every agent needs to know *how* it was triggered. The same agent code can behave differently based on whether it was called via HTTP, scheduled by cron, invoked manually, and more.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step1-understanding-triggers.ts", lang: "ts", title: "TypeScript" },
  { path: "/examples/training/02-anatomy/step1-understanding-triggers.py", lang: "python", title: "Python" }
]} />

**What this demonstrates:**
- Accessing the trigger type via `request.trigger`
- Conditional logic based on trigger
- Different responses for different trigger types

**Try it:**
1. Run this agent in DevMode (creates a `manual` trigger)
2. Send a webhook request to test `webhook` trigger
3. Notice how `request.trigger` changes the response

</TutorialStep>

### Step 2: Working with Request Data

<TutorialStep number={2} title="Working with Request Data" estimatedTime="4 min">

Agents receive data in various formats—JSON, text, binary. The SDK provides methods to handle each format and access metadata about the request.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step2-request-data.ts", lang: "ts", title: "TypeScript" },
  { path: "/examples/training/02-anatomy/step2-request-data.py", lang: "python", title: "Python" }
]} />

**What this demonstrates:**
- Content type detection via `request.data.contentType` (TypeScript) or `request.data.content_type` (Python)
- Parsing different data formats (JSON, text, binary)
- Accessing metadata using multiple approaches:
  - `request.get(key, default)` - SDK convenience method (recommended)
  - `request.metadata` property - Returns the full metadata dict/object
  - Direct property/dict access for specific use cases

**Try it:**
1. Send JSON data: `{"name": "Alice", "action": "greet"}`
2. Send plain text: `"Hello, agent!"`
3. Check the logs to see how content type detection works
4. Notice the commented examples showing different ways to access metadata

</TutorialStep>

### Step 3: Structured Logging

<TutorialStep number={3} title="Structured Logging" estimatedTime="4 min">

Effective logging is crucial for debugging and monitoring. Use appropriate log levels and structured data to make your logs searchable and actionable.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step3-structured-logging.ts", lang: "ts", title: "TypeScript" },
  { path: "/examples/training/02-anatomy/step3-structured-logging.py", lang: "python", title: "Python" }
]} />

**What this demonstrates:**
- Using different log levels (`info`, `warn`, `error`, `debug`)
- Including structured context in logs
- Conditional logging based on task type

**Try it:**
1. Send `{"task": "normal"}` - see INFO logs
2. Send `{"task": "risky"}` - see WARN logs
3. Send `{"task": "error"}` - see ERROR logs
4. Check the Console Logs tab to see structured data

**Best Practice:** Include context in every log (agent ID, session ID, request details) to help with debugging later.

</TutorialStep>

### Step 4: Introduction to KV Storage

<TutorialStep number={4} title="Introduction to KV Storage" estimatedTime="5 min">

Key-value storage lets agents cache data, manage state, and avoid redundant work. This is a simple caching pattern—check cache first, compute if needed, then store with TTL.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step4-kv-caching.ts", lang: "ts", title: "TypeScript" },
  { path: "/examples/training/02-anatomy/step4-kv-caching.py", lang: "python", title: "Python" }
]} />

**What this demonstrates:**
- Checking cache with `context.kv.get()`
- Cache hit vs. cache miss handling
- Storing data with TTL using `context.kv.set()`

**Try it:**
1. Send `{"query": "hello"}` - first request computes and caches
2. Send `{"query": "hello"}` again - returns from cache
3. Send `{"query": "world"}` - different key, fresh computation
4. Wait 5 minutes and retry - cache expired, recomputes

**Key Concepts:**
- **Bucket**: First parameter (`'demo-cache'`) - organizes related keys
- **Key**: Second parameter (unique identifier for the data)
- **TTL**: Time-to-live in seconds (data expires automatically)
- **No TTL**: Omit TTL for permanent storage

<Callout type="info">
We'll explore advanced memory patterns (session, persistent, vector) in [**Module 3: Agent Memory**](/Training/developers/03-agent-memory).
</Callout>

</TutorialStep>

### Step 5: Response Formats

<TutorialStep number={5} title="Response Formats" estimatedTime="3 min">

Agents can return responses in various formats depending on who's calling them—JSON for APIs, HTML for browsers, text for simple integrations, or empty for webhooks.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step5-response-formats.ts", lang: "ts", title: "TypeScript" },
  { path: "/examples/training/02-anatomy/step5-response-formats.py", lang: "python", title: "Python" }
]} />

**What this demonstrates:**
- Returning JSON with `response.json()`
- Returning text with `response.text()`
- Returning HTML with `response.html()`
- Returning empty response with `response.empty()`

**Try it:**
1. Send `{"format": "json"}` - structured data response
2. Send `{"format": "text"}` - plain text response
3. Send `{"format": "html"}` - view in browser
4. Send `{"format": "empty"}` - no response body (useful for webhooks or to handle cases where no "actual" response is needed)

</TutorialStep>

## Lab: Try It All Together

You've learned the core anatomy concepts through focused steps. Now let's see them combined in a real-world agent that uses:
- **Multiple triggers** (cron, manual, webhook, etc.) with different behaviors
- **External API integration** (National Weather Service)
- **Smart caching strategies** (different TTL based on trigger)
- **Structured logging** throughout
- **Best practices for error handling**

### What the Weather Agent Does

The weather agent demonstrates **trigger-based behavior**—the same agent code serves different purposes based on how it's triggered:

**Cron Trigger (Monitoring Mode):**
- Runs automatically on schedule
- Fetches weather for multiple cities
- Caches data with 1-hour TTL
- Returns bulk report with all cities

**Manual Trigger (On-Demand Mode):**
- Responds to user requests
- Fetches weather for specific location (based on user request)
- Caches with 5-minute TTL (for quick repeat queries)
- Returns single location result

### Key Implementation: Trigger-Based Routing

<CodeExample py={`# Different behavior based on trigger type
async def run(request: AgentRequest, response: AgentResponse, context: AgentContext):
    if request.trigger == "cron":
        # Bulk monitoring mode
        context.logger.info("Running scheduled weather monitoring")
        return await monitor_multiple_cities(context)
    else:
        # On-demand single query
        data = await request.data.json()
        location = data.get("location", "San Francisco, CA")
        return await get_single_weather(location, context)`} js={`// Different behavior based on trigger type
export default async function Agent(request: AgentRequest, response: AgentResponse, context: AgentContext) {
  if (request.trigger === 'cron') {
    // Bulk monitoring mode
    context.logger.info('Running scheduled weather monitoring');
    return await monitorMultipleCities(context);
  } else {
    // On-demand single query
    const data = await request.data.json();
    const location = data.location || 'San Francisco, CA';
    return await getSingleWeather(location, context);
  }
}`} />

### Key Implementation: External API Integration

<CodeExample py={`# NWS API two-step process with proper error handling
async def fetch_nws_weather(lat: float, lon: float, location_name: str, context: AgentContext):
    try:
        # Step 1: Get grid coordinates from lat/lon
        points_url = f"https://api.weather.gov/points/{lat},{lon}"

        async with aiohttp.ClientSession() as session:
            async with session.get(points_url, headers={"User-Agent": USER_AGENT},
                                 timeout=aiohttp.ClientTimeout(total=10)) as points_response:
                if points_response.status != 200:
                    raise Exception(f"NWS points API error: {points_response.status}")

                points_data = await points_response.json()
                grid_props = points_data.get("properties", {})

                # Extract and validate grid data
                grid_id = grid_props.get("gridId")
                grid_x = grid_props.get("gridX")
                grid_y = grid_props.get("gridY")

                if not all([grid_id, grid_x, grid_y]):
                    raise Exception("Invalid grid data from NWS points API")

            # Step 2: Get forecast using grid coordinates
            forecast_url = f"https://api.weather.gov/gridpoints/{grid_id}/{grid_x},{grid_y}/forecast"
            # ... fetch and process forecast data

    except Exception as e:
        context.logger.error(f"Weather API failed for {location_name}: {e}")
        raise`} js={`// NWS API two-step process with proper error handling
async function fetchNWSWeather(lat: number, lon: number, locationName: string, context: AgentContext): Promise<WeatherResult> {
  try {
    // Step 1: Get grid coordinates from lat/lon
    const pointsUrl = \`https://api.weather.gov/points/\${lat},\${lon}\`;

    const pointsResponse = await fetch(pointsUrl, {
      headers: { 'User-Agent': USER_AGENT },
      signal: AbortSignal.timeout(10000)  // 10 second timeout
    });

    if (!pointsResponse.ok) {
      throw new Error(\`NWS points API failed: \${pointsResponse.status}\`);
    }

    const pointsData = await pointsResponse.json() as NWSPointsResponse;
    const gridProps = pointsData.properties;

    // Validate and extract grid properties
    if (!gridProps || gridProps.gridId === undefined) {
      throw new Error('Could not extract grid information from NWS API');
    }

    // Step 2: Get forecast using grid coordinates
    const forecastUrl = \`https://api.weather.gov/gridpoints/\${gridProps.gridId}/\${gridProps.gridX},\${gridProps.gridY}/forecast\`;
    // ... fetch and process forecast data

  } catch (error) {
    context.logger.error(\`Weather API failed for \${locationName}: \${error}\`);
    throw new Error(\`Weather service unavailable: \${error instanceof Error ? error.message : 'Unknown error'}\`);
  }
}`} />

### Key Implementation: Smart Caching Strategies

<CodeExample py={`# Different caching strategies based on trigger
async def handle_manual_trigger(request: AgentRequest, response: AgentResponse, context: AgentContext):
    # Parse location and create cache key
    location_query = await request.data.text() or "San Francisco"
    cache_key = f"city_{location_query.lower().replace(' ', '_')}"

    # Check cache first (5 minutes for manual requests)
    cached = await context.kv.get("weather", cache_key)
    if cached.exists:
        cached_weather = await cached.data.json()
        context.logger.info(f"Returning cached weather for {location_query}")
        return response.json(cached_weather)

    # Fetch fresh data and cache with shorter TTL
    weather = await fetch_nws_weather(coordinates["lat"], coordinates["lon"], location_query, context)
    await context.kv.set("weather", cache_key, weather, {"ttl": 300})  # 5 minutes

    return response.json(weather)

async def handle_cron_trigger(response: AgentResponse, context: AgentContext):
    # Bulk processing with longer cache (1 hour for monitoring)
    for city in MONITORED_CITIES:
        weather = await fetch_nws_weather(city["lat"], city["lon"], city["name"], context)
        await context.kv.set("weather", f"city_{city['name'].lower()}", weather, {"ttl": 3600})
        context.logger.info(f"Cached weather for {city['name']}: {weather['temperature']}°F")`} js={`// Different caching strategies based on trigger
async function handleManualTrigger(request: AgentRequest, response: AgentResponse, context: AgentContext) {
  // Parse location and create cache key
  const locationQuery = await request.data.text() || 'San Francisco';
  const cacheKey = \`city_\${locationQuery.toLowerCase().replace(/\\s+/g, '_')}\`;

  // Check cache first (5 minutes for manual requests)
  const cached = await context.kv.get('weather', cacheKey);
  if (cached.exists) {
    const cachedWeather = await cached.data.json() as WeatherResult;
    context.logger.info(\`Returning cached weather for \${locationQuery}\`);
    return response.json(cachedWeather);
  }

  // Fetch fresh data and cache with shorter TTL
  const weather = await fetchNWSWeather(coordinates.lat, coordinates.lon, locationQuery, context);
  await context.kv.set('weather', cacheKey, weather, { ttl: 300 }); // 5 minutes

  return response.json(weather);
}

async function handleCronTrigger(response: AgentResponse, context: AgentContext) {
  // Bulk processing with longer cache (1 hour for monitoring)
  for (const city of MONITORED_CITIES) {
    const weather = await fetchNWSWeather(city.lat, city.lon, city.name, context);
    await context.kv.set('weather', \`city_\${city.name.toLowerCase()}\`, weather, { ttl: 3600 });
    context.logger.info(\`Cached weather for \${city.name}: \${weather.temperature}°F\`);
  }
}`} />

### Build This Agent Yourself

Ready to implement this agent? Follow our complete examples:

<div className="flex flex-wrap gap-3 mb-6">
  <a href="https://github.com/agentuity/examples/tree/main/training/02-weather-agent-ts" target="_blank" rel="noopener noreferrer"
     className="inline-flex items-center gap-2 px-4 py-3 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors no-underline text-sm font-medium">
    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.30 3.297-1.30.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
    TypeScript
  </a>
  <a href="https://github.com/agentuity/examples/tree/main/training/02_weather_agent_py" target="_blank" rel="noopener noreferrer"
     className="inline-flex items-center gap-2 px-4 py-3 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors no-underline text-sm font-medium">
    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.30 3.297-1.30.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
    Python
  </a>
</div>

### What This Agent Demonstrates

- **Trigger-based behavior**: Same agent code behaves differently based on trigger type
- **External API integration**: Real National Weather Service API calls with proper error handling
- **Smart caching strategies**: Different TTL based on use case (cron vs manual)
- **Production patterns**: Timeouts, defensive typing, comprehensive logging
- **AI enhancement**: Optional AI-powered weather interpretation

The complete examples show you how to build real agents that integrate external APIs and use multiple triggers with intelligent caching and error handling.

### Testing Your Weather Agent

1. **Start DevMode:**
```bash
agentuity dev
```

2. **Test the weather agent** with different city names (San Francisco, New York, Los Angeles, Chicago)
3. **Monitor the execution** in the *Logs* and *Sessions* tabs to see caching behavior
4. **Try the same request twice** to see cache hits

#### Configuring Cron Triggers for Production

For actual scheduled execution, configure cron triggers through the [Agentuity Console](https://app.agentuity.com):

1. Navigate to your agent in the Console
2. Click on **"Add Trigger"** and select **"Cron Job"**
3. Configure the schedule using cron syntax (e.g., `0 * * * *` for hourly)
4. Set the *Content Type* and optional *Payload*
5. Enable the trigger and save

<Callout type="info">
Learn more about configuring triggers in the [Agent Configuration Guide](/Cloud/agents).
</Callout>

## Key Takeaways

- **Triggers determine behavior**: Same agent, different responses based on how it's called (webhook, cron, manual)
- **Request handling is flexible**: SDK provides `json()`, `text()`, `binary()` methods for all formats
- **Logging is essential**: Structured logs with appropriate levels help debugging and monitoring
- **KV storage enables caching**: Simple `get/set` with TTL prevents redundant work
- **Responses adapt to context**: `json()` for APIs, `html()` for browsers, `empty()` for webhooks
- **The weather agent shows it all**: See these concepts combined in production code

## What's Next?

You now understand agent anatomy—the building blocks every agent shares. In **Module 3: Agent Memory**, we'll dive deep into how agents remember, learn, and maintain state across interactions.

**Before moving on:**
1. Complete all 5 tutorial steps
2. Build and test the weather agent
3. Experiment with different triggers and cache TTLs
4. Review the logs to see patterns emerge

Remember: Anatomy is the foundation. The logic you add on top is what makes your agents unique.

---

**Ready for Module 3?** [Agent Memory](./03-agent-memory)
