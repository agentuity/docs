---
title: Database
description: Relational database storage using Bun's native SQL APIs
---

Database storage provides relational database capabilities using [Bun's native SQL APIs](https://bun.com/docs/runtime/sql). Use it for structured data that benefits from queries, joins, and transactions.

## When to Use Database Storage

| Storage Type | Best For |
|--------------|----------|
| **Database** | Structured data, complex queries, transactions, relational data |
| [Key-Value](/Services/Storage/key-value) | Fast lookups, caching, configuration |
| [Vector](/Services/Storage/vector) | Semantic search, embeddings, RAG |
| [Object (S3)](/Services/Storage/object) | Files, images, documents, media |
| [Durable Streams](/Services/Storage/durable-streams) | Large exports, audit logs |

<Callout type="info" title="Credentials Auto-Injected">
When you create a database with `agentuity cloud db create`, the `DATABASE_URL` is automatically added to your `.env` file. During deployment, credentials are injected automatically.
</Callout>

## Creating a Database

Create a database from the CLI with optional name and description:

```bash
# Create with default settings
agentuity cloud db create

# Create with name and description
agentuity cloud db create --name "users-db" --description "Primary user data store"
```

The name and description help identify databases in the dashboard when managing multiple databases.

<Callout type="tip" title="Same Code Everywhere">
Database access uses Bun's native SQL API directly. The same `import { sql } from "bun"` code works identically in agents, routes, and standalone scripts with no wrapper needed.
</Callout>

## Quick Start

```typescript
import { sql } from "bun";

// Query with automatic SQL injection protection
const users = await sql`SELECT * FROM users WHERE active = ${true}`;

// Insert data
await sql`INSERT INTO users (name, email) VALUES (${"Alice"}, ${"alice@example.com"})`;

// Update data
await sql`UPDATE users SET active = ${false} WHERE id = ${userId}`;

// Delete data
await sql`DELETE FROM users WHERE id = ${userId}`;
```

<Callout type="warn" title="SQL Injection Prevention">
Always use template literal parameters (`${value}`) for dynamic values. Never concatenate strings into queries.
</Callout>

## Using in Agents

```typescript
import { createAgent } from '@agentuity/runtime';
import { sql } from "bun";

const agent = createAgent('UserQuery', {
  handler: async (ctx, input) => {
    const users = await sql`
      SELECT * FROM users
      WHERE active = ${true}
      AND created_at > ${input.since}
      ORDER BY created_at DESC
      LIMIT 10
    `;

    ctx.logger.info("Query results", { count: users.length });
    return { users };
  },
});
```

## Using in Routes

```typescript
import { createRouter } from '@agentuity/runtime';
import { sql } from "bun";

const router = createRouter();

router.get('/users', async (c) => {
  const limit = parseInt(c.req.query('limit') || '10');
  const users = await sql`
    SELECT id, name, email FROM users
    ORDER BY created_at DESC
    LIMIT ${limit}
  `;
  return c.json({ users });
});

router.post('/users', async (c) => {
  const body = await c.req.json();
  const result = await sql`
    INSERT INTO users (name, email)
    VALUES (${body.name}, ${body.email})
    RETURNING id, name, email
  `;
  return c.json({ user: result[0] }, 201);
});

export default router;
```

## Transactions

Use transactions for operations that must succeed or fail together:

```typescript
import { createAgent } from '@agentuity/runtime';
import { sql } from "bun";

const agent = createAgent('MoneyTransfer', {
  handler: async (ctx, input) => {
    const { fromAccount, toAccount, amount } = input;

    try {
      await sql.begin(async (tx) => {
        await tx`UPDATE accounts SET balance = balance - ${amount} WHERE id = ${fromAccount}`;
        await tx`UPDATE accounts SET balance = balance + ${amount} WHERE id = ${toAccount}`;
        await tx`INSERT INTO transfers (from_id, to_id, amount) VALUES (${fromAccount}, ${toAccount}, ${amount})`;
      });

      ctx.logger.info("Transfer completed", { fromAccount, toAccount, amount });
      return { success: true };
    } catch (error) {
      ctx.logger.error("Transfer failed", { error: error.message });
      return { error: "Transfer failed" };
    }
  },
});
```

## Supported Databases

Bun's SQL API supports PostgreSQL, MySQL, and SQLite:

```typescript
import { SQL } from "bun";

// PostgreSQL (default, uses DATABASE_URL)
const users = await sql`SELECT * FROM users`;

// Custom PostgreSQL connection
const postgres = new SQL("postgres://user:pass@localhost:5432/mydb");

// MySQL
const mysql = new SQL("mysql://user:pass@localhost:3306/mydb");

// SQLite
const sqlite = new SQL("sqlite://data/app.db");
```

## Bun SQL Documentation

For complete API documentation including dynamic queries, bulk inserts, savepoints, array operations, error handling, and connection pooling, see the [Bun SQL documentation](https://bun.com/docs/runtime/sql).

## Resilient Postgres Client

The `@agentuity/postgres` package provides a connection-resilient PostgreSQL client built for serverless environments. It handles connection drops, cold starts, and automatic reconnection.

```bash
bun add @agentuity/postgres
```

```typescript
import { postgres } from '@agentuity/postgres';

// Create client (uses DATABASE_URL by default)
const sql = postgres();

// Queries automatically retry on connection errors
const users = await sql`SELECT * FROM users WHERE active = ${true}`;

// Transactions
const tx = await sql.begin();
await tx`INSERT INTO users (name) VALUES (${'Alice'})`;
await tx.commit();
```

### Configuration

```typescript
import { postgres } from '@agentuity/postgres';

const sql = postgres({
  url: 'postgres://user:pass@localhost:5432/mydb',

  // Reconnection
  reconnect: {
    maxAttempts: 10,
    initialDelayMs: 100,
    maxDelayMs: 30000,
  },

  // Callbacks
  onclose: (error) => console.log('Connection closed', error),
  onreconnected: () => console.log('Reconnected!'),
});
```

**Key features:**

- **Automatic reconnection**: Exponential backoff with jitter on connection drops
- **Query retry**: Retries queries on retryable errors (connection reset, timeout)
- **Transaction support**: Full transaction and savepoint support with `sql.begin()`
- **Graceful shutdown**: Skips reconnection on SIGTERM/SIGINT for clean process exit
- **Connection stats**: Track connection health via `sql.stats`

<Callout type="tip" title="When to Use">
Use `@agentuity/postgres` when you need resilient connections in serverless environments, especially with Neon or similar providers that have cold start latency.
</Callout>

## Drizzle ORM Integration

The `@agentuity/drizzle` package provides type-safe database access with [Drizzle ORM](https://orm.drizzle.team/) and automatic reconnection.

```bash
bun add @agentuity/drizzle
```

```typescript
import { createPostgresDrizzle, eq } from '@agentuity/drizzle';
import * as schema from './schema';

// Create database instance (uses DATABASE_URL by default)
const { db, client, close } = createPostgresDrizzle({ schema });

// Type-safe queries with schema inference
const activeUsers = await db.select().from(schema.users).where(eq(schema.users.active, true));

// Access connection stats via the underlying client
console.log(client.stats);

// Clean up when done
await close();
```

**Key features:**

- **Type-safe queries**: Full TypeScript inference from your Drizzle schema
- **Resilient connection**: Built on `@agentuity/postgres` for automatic reconnection
- **Convenient re-exports**: Common Drizzle utilities (`eq`, `and`, `pgTable`, etc.) available from a single import
- **Auth integration**: Works with `@agentuity/auth` via `drizzleAdapter`

```typescript
import { createPostgresDrizzle, eq } from '@agentuity/drizzle';
import * as schema from './schema';

const { db, close } = createPostgresDrizzle({
  schema,
  logger: true,  // Enable query logging
  reconnect: {
    maxAttempts: 5,
    initialDelayMs: 100,
  },
  onReconnected: () => console.log('Reconnected to database'),
});

// Drizzle infers the joined type
const usersWithPosts = await db
  .select()
  .from(schema.users)
  .leftJoin(schema.posts, eq(schema.users.id, schema.posts.authorId));

// Insert with returning
const [newUser] = await db
  .insert(schema.users)
  .values({ name: 'Alice', email: 'alice@example.com' })
  .returning();
```

<Callout type="info" title="Drizzle Schema">
Define your schema in a separate file and use `drizzle-kit` for migrations. See the [Drizzle documentation](https://orm.drizzle.team/docs/sql-schema-declaration) for schema syntax.
</Callout>

## Next Steps

- [Key-Value Storage](/Services/Storage/key-value): Fast caching and session data
- [Object Storage (S3)](/Services/Storage/object): File and media storage
- [Vector Storage](/Services/Storage/vector): Semantic search and embeddings
- [Durable Streams](/Services/Storage/durable-streams): Streaming large data exports
