---
title: Queues
description: Publish messages for async processing, webhooks, and event-driven workflows
---

Queues enable asynchronous message processing for background tasks, webhooks, and event-driven workflows. Publish messages from agents and consume them with workers or webhook destinations.

## When to Use Queues

| Pattern | Best For |
|---------|----------|
| **Queues** | Background jobs, webhooks, event-driven processing, decoupled services |
| [Durable Streams](/Services/Storage/durable-streams) | Large exports, audit logs, streaming data |
| [Key-Value](/Services/Storage/key-value) | Fast lookups, caching, configuration |

**Use queues when you need to:**
- Process tasks asynchronously (email sending, report generation)
- Decouple services with reliable message delivery
- Deliver webhooks to external endpoints
- Handle bursty workloads with rate limiting
- Retry failed operations with exponential backoff

## Queue Types

| Type | Behavior |
|------|----------|
| `worker` | Each message is processed by exactly one consumer. Use for background jobs. |
| `pubsub` | Messages are broadcast to all subscribers. Use for event notifications. |

## Publishing Messages

Publish messages from agents using `ctx.queue.publish()`:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('OrderProcessor', {
  handler: async (ctx, input) => {
    // Queue an email to be sent asynchronously
    const result = await ctx.queue.publish('email-queue', {
      to: input.customerEmail,
      subject: 'Order Confirmed',
      orderId: input.orderId,
    });

    ctx.logger.info('Email queued', { messageId: result.id });

    return { success: true, messageId: result.id };
  },
});
```

### Publish Options

```typescript
const agent = createAgent('TaskScheduler', {
  handler: async (ctx, input) => {
    await ctx.queue.publish('task-queue', input.task, {
      // Attach metadata for filtering or routing
      metadata: { priority: 'high', region: 'us-west' },

      // Guarantee ordering for messages with the same key
      partitionKey: input.customerId,

      // Prevent duplicate messages
      idempotencyKey: `task-${input.taskId}-v1`,

      // Auto-expire after 1 hour
      ttl: 3600,
    });

    return { queued: true };
  },
});
```

| Option | Description |
|--------|-------------|
| `metadata` | Key-value pairs for routing or filtering |
| `partitionKey` | Messages with the same key are processed in order |
| `idempotencyKey` | Prevents duplicate messages if the same key is published again |
| `ttl` | Time-to-live in seconds before the message expires |

### Publish Result

```typescript
interface QueuePublishResult {
  id: string;         // Unique message ID (msg_...)
  offset: number;     // Sequential position in the queue
  publishedAt: string; // ISO 8601 timestamp
}
```

## Error Handling

```typescript
import { QueueNotFoundError, QueueValidationError } from '@agentuity/runtime';

const agent = createAgent('SafePublisher', {
  handler: async (ctx, input) => {
    try {
      await ctx.queue.publish('notifications', input.notification);
      return { success: true };
    } catch (error) {
      if (error instanceof QueueNotFoundError) {
        ctx.logger.error('Queue does not exist', { queue: 'notifications' });
        return { success: false, error: 'Queue not found' };
      }
      if (error instanceof QueueValidationError) {
        ctx.logger.error('Invalid message', { field: error.field });
        return { success: false, error: 'Validation failed' };
      }
      throw error;
    }
  },
});
```

## Queue Management

Create and manage queues using the CLI or `@agentuity/server` package.

### CLI Commands

```bash
# Create a worker queue
agentuity cloud queue create --name order-processing --type worker

# Create a pubsub queue for broadcasting
agentuity cloud queue create --name events --type pubsub

# List all queues
agentuity cloud queue list

# Get queue details and stats
agentuity cloud queue get order-processing

# Pause/resume processing
agentuity cloud queue pause order-processing
agentuity cloud queue resume order-processing

# Delete a queue
agentuity cloud queue delete order-processing
```

### Programmatic Management

Use `@agentuity/server` for full queue management in routes or standalone scripts:

```typescript
import { createQueue, listQueues, deleteQueue } from '@agentuity/server';

// Create a queue
const queue = await createQueue(client, {
  name: 'order-processing',
  queue_type: 'worker',
  settings: {
    default_max_retries: 5,
    default_visibility_timeout_seconds: 60,
  },
});

// List queues
const { queues } = await listQueues(client);

// Delete a queue
await deleteQueue(client, 'old-queue');
```

## Consuming Messages

### Webhook Destinations

Configure a webhook destination to automatically deliver messages to an HTTP endpoint:

```typescript
import { createDestination } from '@agentuity/server';

await createDestination(client, 'order-processing', {
  destination_type: 'http',
  config: {
    url: 'https://api.example.com/webhook/orders',
    method: 'POST',
    headers: { 'X-API-Key': 'secret' },
    timeout_ms: 30000,
    retry_policy: {
      max_attempts: 5,
      initial_backoff_ms: 1000,
      max_backoff_ms: 60000,
      backoff_multiplier: 2.0,
    },
  },
});
```

### Pull-Based Consumption

For workers that pull messages:

```typescript
import { receiveMessage, ackMessage, nackMessage } from '@agentuity/server';

// Receive a message (blocks until available or timeout)
const message = await receiveMessage(client, 'order-processing');

if (message) {
  try {
    // Process the message
    await processOrder(message.payload);

    // Acknowledge success
    await ackMessage(client, 'order-processing', message.id);
  } catch (error) {
    // Negative acknowledge - message returns to queue for retry
    await nackMessage(client, 'order-processing', message.id);
  }
}
```

## Dead Letter Queue

Messages that exceed the retry limit are moved to the dead letter queue (DLQ). Inspect and replay failed messages:

```bash
# List failed messages
agentuity cloud queue dlq order-processing

# Replay a message back to the queue
agentuity cloud queue dlq replay order-processing --message-id msg_abc123

# Purge all DLQ messages
agentuity cloud queue dlq purge order-processing
```

Programmatically:

```typescript
import { createApp, createAgentContext } from '@agentuity/runtime';
import { listDeadLetterMessages, replayDeadLetterMessage } from '@agentuity/server';

await createApp();
const ctx = createAgentContext();

// List failed messages
const { messages } = await listDeadLetterMessages(client, 'order-processing');

for (const msg of messages) {
  ctx.logger.warn('Failed message', {
    id: msg.id,
    reason: msg.failure_reason,
    attempts: msg.delivery_attempts,
  });

  // Replay back to the queue
  await replayDeadLetterMessage(client, 'order-processing', msg.id);
}
```

This example uses `createAgentContext()` for logging and tracing. See [Running Agents Without HTTP](/Agents/standalone-execution) for more on standalone execution.

## HTTP Ingestion Sources

Create public HTTP endpoints to ingest data into queues from external services:

```typescript
import { createSource } from '@agentuity/server';

const source = await createSource(client, 'webhook-queue', {
  name: 'stripe-webhooks',
  description: 'Receives Stripe payment events',
  auth_type: 'header',
  auth_value: 'Bearer whsec_...',
});

// External services POST to this URL
console.log(`Webhook URL: ${source.url}`);
```

| Auth Type | Description |
|-----------|-------------|
| `none` | No authentication |
| `basic` | HTTP Basic Auth (`username:password`) |
| `header` | Custom header value (`Bearer token`) |

## Queue Settings

Configure queue behavior when creating or updating:

| Setting | Default | Description |
|---------|---------|-------------|
| `default_ttl_seconds` | null | Message expiration (null = never) |
| `default_visibility_timeout_seconds` | 30 | Processing timeout before message returns to queue |
| `default_max_retries` | 5 | Attempts before moving to DLQ |
| `default_retry_backoff_ms` | 1000 | Initial retry delay |
| `default_retry_max_backoff_ms` | 60000 | Maximum retry delay |
| `default_retry_multiplier` | 2.0 | Exponential backoff multiplier |
| `max_in_flight_per_client` | 10 | Concurrent messages per consumer |
| `retention_seconds` | 2592000 | How long to keep acknowledged messages (30 days) |

## Validation Limits

| Limit | Value |
|-------|-------|
| Queue name length | 1-256 characters |
| Queue name format | Lowercase letters, digits, underscores, hyphens. Must start with letter or underscore. |
| Payload size | 1 MB max |
| Partition key length | 256 characters max |
| Idempotency key length | 256 characters max |
| Batch size | 1000 messages max |

## Best Practices

- **Use idempotency keys** for operations that shouldn't be duplicated (payments, emails)
- **Set appropriate TTLs** for time-sensitive messages
- **Use partition keys** when message ordering matters within a group
- **Monitor DLQ** regularly to catch and fix processing failures
- **Configure webhook retry policies** to handle transient failures gracefully

## Next Steps

- [Durable Streams](/Services/Storage/durable-streams): Streaming storage for large exports
- [Key-Value Storage](/Services/Storage/key-value): Fast caching and configuration
- [Background Tasks](/Learn/Cookbook/Patterns/background-tasks): Patterns for async processing
- [Webhook Handler](/Learn/Cookbook/Patterns/webhook-handler): Receiving external webhooks
