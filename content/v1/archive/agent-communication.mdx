---
title: Agent Communication
description: Learn how to build multi-agent systems with effective communication patterns
---

# Agent Communication

TODO: no handoff, inter-project/org feature in v1?

Build complex agentic systems by creating specialized agents that communicate and collaborate to achieve goals.

## Overview

In advanced agentic systems, agents work together by delegating tasks, sharing data, and coordinating workflows. The recommended approach is to build agents with highly specialized roles and use agent-to-agent communication to achieve the overall goal.

For example, instead of building one large "customer support" agent, you might build:
- A **routing agent** that classifies the request
- A **knowledge agent** that searches documentation
- A **response agent** that generates customer-friendly answers
- A **sentiment agent** that analyzes customer tone

Each agent focuses on one task and communicates with others as needed.

## Basic Agent Calling

Agents call other agents using the context object's agent registry. The SDK provides type-safe access to all agents in your project.

### Calling an Agent

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const coordinatorAgent = createAgent({
  schema: {
    input: z.object({ text: z.string() }),
    output: z.object({ result: z.string() })
  },
  handler: async (ctx, input) => {
    // Call another agent
    const enriched = await ctx.agent.enrichmentAgent.run({
      text: input.text
    });

    // Use the result
    return { result: enriched.enrichedText };
  }
});
```

When both agents have schemas, the call is fully type-safe. TypeScript validates the input type and infers the output type automatically.

For detailed information about the agent calling API, see [Core Concepts](/SDK/core-concepts#agent-communication).

## Communication Patterns

Different workflows require different communication patterns. This section covers the most common patterns for coordinating multiple agents.

### Sequential Workflows

Sequential execution processes data through a series of agents, where each agent depends on the output of the previous agent.

```typescript
const pipelineAgent = createAgent({
  handler: async (ctx, input) => {
    // Step 1: Validate input
    const validated = await ctx.agent.validatorAgent.run({
      data: input.rawData
    });

    // Step 2: Enrich with additional data
    const enriched = await ctx.agent.enrichmentAgent.run({
      data: validated.cleanData
    });

    // Step 3: Analyze the enriched data
    const analyzed = await ctx.agent.analysisAgent.run({
      data: enriched.enrichedData
    });

    return analyzed;
  }
});
```

**When to use:**
- Data transformation pipelines
- Multi-step validation or processing
- Workflows where each step depends on the previous result

**Error handling:**
Errors propagate automatically. If `validatorAgent` throws an error, `enrichmentAgent` and `analysisAgent` never execute.

### Parallel Execution

Parallel execution runs multiple agents simultaneously when their operations are independent.

```typescript
const searchAgent = createAgent({
  handler: async (ctx, input) => {
    // Execute all searches in parallel
    const [webResults, dbResults, vectorResults] = await Promise.all([
      ctx.agent.webSearchAgent.run({ query: input.query }),
      ctx.agent.databaseAgent.run({ query: input.query }),
      ctx.agent.vectorSearchAgent.run({ query: input.query })
    ]);

    // Merge and rank results
    return {
      results: mergeResults(webResults, dbResults, vectorResults)
    };
  }
});
```

**When to use:**
- Independent data fetching operations
- Multiple validation checks
- Gathering data from different sources
- Operations that can run concurrently

**Performance benefit:**
If each agent takes 1 second, sequential execution takes 3 seconds, but parallel execution takes only 1 second.

### Conditional Routing

Use an LLM to classify user intent and route to the appropriate agent:

```typescript
import { groq } from '@ai-sdk/groq';
import { generateObject } from 'ai';
import { z } from 'zod';

const IntentSchema = z.object({
  agentType: z.enum(['support', 'sales', 'technical', 'billing']),
  confidence: z.number().min(0).max(1),
  reasoning: z.string()
});

const routerAgent = createAgent({
  schema: {
    input: z.object({ userMessage: z.string() })
  },
  handler: async (ctx, input) => {
    // Classify intent with Groq (fast inference via AI Gateway)
    const intent = await generateObject({
      model: groq('llama-3.3-70b'), // Groq (fast inference via AI Gateway) for quick classification
      schema: IntentSchema,
      system: 'You are a request classifier. Analyze the user message and determine which agent should handle it. Return the agent type, confidence score, and brief reasoning.',
      prompt: input.userMessage,
      temperature: 0.0 // Deterministic output for routing decisions
    });

    ctx.logger.info('Intent classified', {
      type: intent.object.agentType,
      confidence: intent.object.confidence
    });

    // Route based on classified intent
    switch (intent.object.agentType) {
      case 'support':
        return await ctx.agent.supportAgent.run({
          message: input.userMessage,
          context: intent.object.reasoning
        });

      case 'sales':
        return await ctx.agent.salesAgent.run({
          message: input.userMessage,
          context: intent.object.reasoning
        });

      case 'technical':
        return await ctx.agent.technicalAgent.run({
          message: input.userMessage,
          context: intent.object.reasoning
        });

      case 'billing':
        return await ctx.agent.billingAgent.run({
          message: input.userMessage,
          context: intent.object.reasoning
        });
    }
  }
});
```

**When to use:**
- Natural language user inputs
- Multiple potential routing paths
- Need to understand nuanced intent
- Adaptive routing based on context

## Advanced Workflows

### Multi-Stage Pipelines

Build complex pipelines with checkpoints and conditional branching:

```typescript
const contentModerationAgent = createAgent({
  handler: async (ctx, input) => {
    // Stage 1: Initial screening
    const screening = await ctx.agent.screeningAgent.run({
      content: input.text
    });

    if (!screening.passed) {
      return {
        approved: false,
        reason: 'Failed initial screening',
        flags: screening.flags
      };
    }

    // Stage 2: Detailed analysis (parallel)
    const [sentiment, toxicity, pii] = await Promise.all([
      ctx.agent.sentimentAgent.run({ text: input.text }),
      ctx.agent.toxicityAgent.run({ text: input.text }),
      ctx.agent.piiDetectionAgent.run({ text: input.text })
    ]);

    // Stage 3: Final decision
    const decision = await ctx.agent.decisionAgent.run({
      screening,
      sentiment,
      toxicity,
      pii
    });

    return decision;
  }
});
```

This pattern combines sequential and parallel execution with conditional logic for sophisticated workflows.

### Fan-Out/Fan-In

Distribute work to multiple agents and aggregate the results:

```typescript
const documentAnalysisAgent = createAgent({
  schema: {
    input: z.object({
      document: z.string(),
      sections: z.array(z.string())
    })
  },
  handler: async (ctx, input) => {
    // Fan-out: Analyze each section in parallel
    const sectionAnalyses = await Promise.all(
      input.sections.map(section =>
        ctx.agent.sectionAnalyzer.run({ text: section })
      )
    );

    // Fan-in: Aggregate results
    const summary = await ctx.agent.summaryAgent.run({
      analyses: sectionAnalyses
    });

    return {
      sections: sectionAnalyses,
      summary: summary.overall
    };
  }
});
```

**Handling partial failures:**

```typescript
const results = await Promise.allSettled(
  input.items.map(item =>
    ctx.agent.processingAgent.run({ item })
  )
);

const successful = results
  .filter(r => r.status === 'fulfilled')
  .map(r => r.value);

const failed = results
  .filter(r => r.status === 'rejected')
  .map(r => r.reason);

if (failed.length > 0) {
  ctx.logger.warn('Some operations failed', { failed });
}

return { successful, failed: failed.length };
```

## Error Handling Strategies

### Cascading Failures

By default, errors propagate through the call chain, stopping execution immediately:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // If validatorAgent throws, execution stops here
    const validated = await ctx.agent.validatorAgent.run(input);

    // This line never executes if validation fails
    const processed = await ctx.agent.processorAgent.run(validated);

    return processed;
  }
});
```

This is the recommended pattern for critical operations where later steps cannot proceed without earlier results.

### Graceful Degradation

For optional operations, catch errors and continue with reduced functionality:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    let enrichedData = input.data;

    // Try to enrich, but continue if it fails
    try {
      const enrichment = await ctx.agent.enrichmentAgent.run({
        data: input.data
      });
      enrichedData = enrichment.data;
    } catch (error) {
      ctx.logger.warn('Enrichment failed, using original data', {
        error: error instanceof Error ? error.message : String(error)
      });
    }

    // Process with enriched data (or original if enrichment failed)
    return await ctx.agent.processorAgent.run({
      data: enrichedData
    });
  }
});
```

**When to use graceful degradation:**
- Optional external API calls
- Caching operations (fall back to database)
- Non-critical enrichment services
- Analytics or logging operations

### Retry Strategies

Implement retry logic for unreliable operations:

```typescript
async function callWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      // Exponential backoff
      const delay = delayMs * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  throw new Error('Retry failed');
}

const agent = createAgent({
  handler: async (ctx, input) => {
    // Retry unreliable external agent call
    const result = await callWithRetry(() =>
      ctx.agent.externalServiceAgent.run(input)
    );

    return result;
  }
});
```

### Fallback Strategies

Provide alternative paths when primary agents fail:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    try {
      // Try primary agent
      return await ctx.agent.primaryAgent.run(input);
    } catch (error) {
      ctx.logger.warn('Primary agent failed, using fallback', { error });

      // Fall back to alternative agent
      return await ctx.agent.fallbackAgent.run(input);
    }
  }
});
```

## Data Flow & Transformation

### Output to Input Mapping

Transform agent outputs to match the expected input of downstream agents:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Agent 1 returns { analysisResult: {...} }
    const analysis = await ctx.agent.analysisAgent.run({
      text: input.text
    });

    // Agent 2 expects { data: {...}, metadata: {...} }
    const processed = await ctx.agent.processingAgent.run({
      data: analysis.analysisResult,
      metadata: {
        timestamp: new Date().toISOString(),
        source: 'analysis-agent'
      }
    });

    return processed;
  }
});
```

### Schema Compatibility

Ensure type safety across agent boundaries using schemas:

```typescript
// enrichmentAgent output schema
const enrichmentOutputSchema = z.object({
  enrichedText: z.string(),
  metadata: z.object({
    sentiment: z.number(),
    keywords: z.array(z.string())
  })
});

// analysisAgent input schema (compatible with enrichment output)
const analysisInputSchema = z.object({
  enrichedText: z.string(),
  metadata: z.object({
    sentiment: z.number(),
    keywords: z.array(z.string())
  })
});
```

When schemas are compatible, TypeScript validates the connection at compile time.

### Transformation Pipelines

Build pipelines that progressively transform data:

```typescript
const transformationAgent = createAgent({
  handler: async (ctx, input) => {
    // Raw text → Structured data
    const structured = await ctx.agent.parserAgent.run({
      text: input.rawText
    });

    // Structured data → Validated data
    const validated = await ctx.agent.validatorAgent.run({
      data: structured.parsed
    });

    // Validated data → Enriched data
    const enriched = await ctx.agent.enrichmentAgent.run({
      data: validated.clean
    });

    // Enriched data → Final output
    const final = await ctx.agent.formatterAgent.run({
      data: enriched.enriched
    });

    return final;
  }
});
```

## Real-World Examples

### Search + Summarize + Analyze Workflow

```typescript
const researchAgent = createAgent({
  schema: {
    input: z.object({ query: z.string() }),
    output: z.object({
      summary: z.string(),
      insights: z.array(z.string()),
      sources: z.array(z.string())
    })
  },
  handler: async (ctx, input) => {
    // Step 1: Search for relevant information
    const searchResults = await ctx.agent.searchAgent.run({
      query: input.query,
      limit: 10
    });

    // Step 2: Summarize findings (parallel)
    const summaries = await Promise.all(
      searchResults.results.map(result =>
        ctx.agent.summaryAgent.run({ text: result.content })
      )
    );

    // Step 3: Analyze and extract insights
    const analysis = await ctx.agent.analysisAgent.run({
      summaries: summaries.map(s => s.summary),
      originalQuery: input.query
    });

    return {
      summary: analysis.overallSummary,
      insights: analysis.keyInsights,
      sources: searchResults.results.map(r => r.url)
    };
  }
});
```

### Multi-Step Approval System

```typescript
const approvalAgent = createAgent({
  schema: {
    input: z.object({
      request: z.any(),
      requester: z.string()
    })
  },
  handler: async (ctx, input) => {
    // Step 1: Validate request format
    const validation = await ctx.agent.validatorAgent.run({
      request: input.request
    });

    if (!validation.valid) {
      return {
        approved: false,
        reason: 'Invalid request format',
        errors: validation.errors
      };
    }

    // Step 2: Check user permissions
    const permissions = await ctx.agent.permissionsAgent.run({
      userId: input.requester,
      action: input.request.action
    });

    if (!permissions.allowed) {
      return {
        approved: false,
        reason: 'Insufficient permissions'
      };
    }

    // Step 3: Risk assessment (parallel checks)
    const [financialRisk, securityRisk, complianceCheck] = await Promise.all([
      ctx.agent.financialRiskAgent.run(input.request),
      ctx.agent.securityRiskAgent.run(input.request),
      ctx.agent.complianceAgent.run(input.request)
    ]);

    // Step 4: Final approval decision
    const decision = await ctx.agent.decisionAgent.run({
      request: input.request,
      permissions,
      financialRisk,
      securityRisk,
      complianceCheck
    });

    return decision;
  }
});
```

### Data Enrichment Pipeline

```typescript
const dataEnrichmentAgent = createAgent({
  handler: async (ctx, input) => {
    // Start with raw user data
    let userData = input.userData;

    // Parallel enrichment from multiple sources
    const [
      demographicData,
      behavioralData,
      preferenceData
    ] = await Promise.all([
      ctx.agent.demographicAgent.run({ userId: userData.id }),
      ctx.agent.behavioralAgent.run({ userId: userData.id }),
      ctx.agent.preferenceAgent.run({ userId: userData.id })
    ]);

    // Merge all data
    const merged = {
      ...userData,
      demographics: demographicData,
      behavior: behavioralData,
      preferences: preferenceData
    };

    // Generate insights from enriched data
    const insights = await ctx.agent.insightsAgent.run({
      enrichedData: merged
    });

    // Store for future use
    try {
      await ctx.kv.set('enriched-users', userData.id, {
        data: merged,
        insights: insights,
        updatedAt: new Date().toISOString()
      }, { ttl: 86400 }); // 24 hours
    } catch (error) {
      ctx.logger.warn('Failed to cache enriched data', { error });
    }

    return {
      enrichedData: merged,
      insights: insights
    };
  }
});
```

## Subagent Communication

For parent-child agent hierarchies, the SDK provides specialized patterns. Subagents are useful when agents share a common domain or need coordinated access control.

### Quick Example

```typescript
// Call a subagent from anywhere
const result = await ctx.agent.team.members.run({
  action: 'list'
});

// From a subagent, access the parent
if (ctx.parent) {
  const parentResult = await ctx.parent.run({
    action: 'validate'
  });
}
```

For comprehensive coverage of subagent patterns, validation strategies, and best practices, see the [Subagents](/Guides/subagents) guide.

## Best Practices

### Keep Agents Focused

Each agent should have a single, well-defined responsibility:

```typescript
// Good - focused agents
const validatorAgent = createAgent({ /* validates data */ });
const enrichmentAgent = createAgent({ /* enriches data */ });
const analysisAgent = createAgent({ /* analyzes data */ });

// Bad - monolithic agent doing everything
const megaAgent = createAgent({
  handler: async (ctx, input) => {
    // Validates, enriches, analyzes all in one place
  }
});
```

Focused agents are easier to test, reuse, and maintain.

### Use Schemas for Type Safety

Define schemas for all agents to enable type-safe communication:

```typescript
const sourceAgent = createAgent({
  schema: {
    output: z.object({
      data: z.string(),
      metadata: z.object({ timestamp: z.string() })
    })
  },
  handler: async (ctx, input) => {
    return {
      data: 'result',
      metadata: { timestamp: new Date().toISOString() }
    };
  }
});

const consumerAgent = createAgent({
  schema: {
    input: z.object({
      data: z.string(),
      metadata: z.object({ timestamp: z.string() })
    })
  },
  handler: async (ctx, input) => {
    // TypeScript knows the exact shape of input
    const result = await ctx.agent.sourceAgent.run({});

    // This is type-safe - TypeScript validates compatibility
    return await processData(result);
  }
});
```

### Handle Errors Appropriately

Choose the right error handling strategy for each operation:

**Fail-fast** for critical operations:
```typescript
// No try-catch - let errors propagate
const validated = await ctx.agent.validatorAgent.run(input);
```

**Graceful degradation** for optional operations:
```typescript
try {
  await ctx.agent.optionalAgent.run(input);
} catch (error) {
  ctx.logger.warn('Optional operation failed', { error });
}
```

### Monitor Performance

Use logging and tracing to monitor multi-agent workflows:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    const startTime = Date.now();

    ctx.logger.info('Starting multi-agent workflow', {
      sessionId: ctx.sessionId
    });

    const result = await ctx.agent.processingAgent.run(input);

    ctx.logger.info('Workflow completed', {
      duration: Date.now() - startTime,
      sessionId: ctx.sessionId
    });

    return result;
  }
});
```

### Leverage Shared Context

Agent calls execute within the same session context, sharing state:

```typescript
const coordinatorAgent = createAgent({
  handler: async (ctx, input) => {
    // Store data in thread state
    ctx.thread.state.set('startTime', Date.now());
    ctx.thread.state.set('userId', input.userId);

    // Called agents can access the same thread state
    const result = await ctx.agent.processingAgent.run(input);

    // All agents share the same sessionId
    ctx.logger.info('Session ID:', ctx.sessionId);

    return result;
  }
});
```

Use this for:
- Tracking context across agent calls
- Sharing authentication/authorization data
- Maintaining conversation state
- Coordinating distributed workflows

### Fallback and Error Handling for Classification

When using LLM-based routing, handle classification failures gracefully:

```typescript
const routerAgent = createAgent({
  handler: async (ctx, input) => {
    try {
      const intent = await generateObject({
        model: groq('llama-3.3-70b'),
        schema: IntentSchema,
        prompt: input.userMessage,
        temperature: 0.0
      });

      // Route based on intent
      switch (intent.object.agentType) {
        case 'support':
          return await ctx.agent.supportAgent.run({
            message: input.userMessage,
            context: intent.object.reasoning
          });

        case 'sales':
          return await ctx.agent.salesAgent.run({
            message: input.userMessage,
            context: intent.object.reasoning
          });

        case 'technical':
          return await ctx.agent.technicalAgent.run({
            message: input.userMessage,
            context: intent.object.reasoning
          });
      }
    } catch (error) {
      ctx.logger.error('Intent classification failed', {
        error: error instanceof Error ? error.message : String(error)
      });

      // Fallback to default agent
      return await c.agent.defaultAgent.run({
        message: input.userMessage
      });
    }
  }
});
```

This ensures your system remains functional even when classification fails.

## Next Steps

- [Subagents](/Guides/subagents): Parent-child agent hierarchies and coordination patterns
- [Schema Validation](/Guides/schema-validation): Type-safe schemas for agent inputs and outputs
- [Events](/Guides/events): Monitor agent lifecycle and execution
- [Error Handling](/SDK/error-handling): Comprehensive error handling strategies
- [Core Concepts](/SDK/core-concepts): Detailed agent communication API reference
