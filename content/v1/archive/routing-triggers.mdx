---
title: Routing & Triggers
description: Define HTTP endpoints, scheduled jobs, email handlers, SMS receivers, and more - all from within your agent code
---

Routes define how your application responds to different HTTP requests and triggers. The SDK provides HTTP routing and specialized routes for email, WebSocket, scheduled jobs, and other event sources.

<Callout type="info" title="Infrastructure as Code">
All triggers are defined in your codebase (`route.ts` files) and are automatically discovered by the SDK. This provides:

- **Version control** - Routes are tracked in git alongside your agent code
- **Type safety** - TypeScript validates route configurations at compile time
- **Code review** - Changes to triggers are visible in pull requests
- **Testability** - Routes can be unit tested like any other code
- **UI visibility** - Configured routes are displayed in the Agentuity dashboard for monitoring
- **Built-in infrastructure** - Routes automatically include load balancing, monitoring, and error tracking

No manual UI configuration required. Define routes directly in your agent code, deploy, and they're immediately available.
</Callout>

## HTTP Routes

Routes are created using `createRouter()` and map URL patterns to handler functions.

### Basic Routes

```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.get('/', async (c) => {
  return c.json({ message: 'Hello' });
});

router.post('/users', async (c) => {
  const body = await c.req.json();
  return c.json({ created: true, data: body });
});

export default router;
```

### HTTP Methods

The router supports standard HTTP methods: `get`, `post`, `put`, `patch`, `delete`, `options`.

```typescript
router.get('/data', async (c) => c.json({ action: 'read' }));
router.post('/data', async (c) => c.json({ action: 'create' }));
router.put('/data', async (c) => c.json({ action: 'update' }));
router.delete('/data', async (c) => c.json({ action: 'delete' }));
```

### Route Parameters

Capture variable segments in URLs using `:paramName`:

```typescript
// Single parameter
router.get('/users/:id', async (c) => {
  const id = c.req.param('id');
  return c.json({ userId: id });
});

// Multiple parameters
router.get('/posts/:year/:month/:slug', async (c) => {
  const year = c.req.param('year');
  const month = c.req.param('month');
  const slug = c.req.param('slug');
  return c.json({ year, month, slug });
});
```

### Query Parameters

Access query strings using `c.req.query()`:

```typescript
router.get('/search', async (c) => {
  const query = c.req.query('q');
  const page = c.req.query('page') || '1';
  const limit = c.req.query('limit') || '10';

  return c.json({ query, page, limit });
});
// URL: /search?q=hello&page=2
// Returns: { "query": "hello", "page": "2", "limit": "10" }
```

**Route parameters vs query strings:**
- **Route parameters** (`:id`): Part of the URL structure, typically required
- **Query strings** (`?page=2`): Optional filters or settings

### Calling Agents from Routes

Routes can invoke agents using the agent registry:

```typescript
router.post('/process', async (c) => {
  const input = await c.req.json();

  const result = await c.agent.processorAgent.run({
    data: input.data
  });

  return c.json(result);
});
```

### Validation

Use `zValidator` middleware to validate request input:

```typescript
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';

const schema = z.object({
  name: z.string().min(1),
  email: z.string().email()
});

router.post('/users',
  zValidator('json', schema),
  async (c) => {
    const data = c.req.valid('json'); // Type-safe, validated data
    return c.json({ success: true, data });
  }
);
```

## Specialized Routes

Define triggers for email, SMS, scheduled jobs, WebSocket connections, and real-time streams - all from within your agent code. These specialized routes enable your agents to respond to diverse event sources without any UI configuration.

### Email Routes

Handle incoming emails sent to a specific address.

**Signature:** `router.email(address: string, handler: EmailHandler): Router`

```typescript
router.email('support@example.com', async (email, c) => {
  c.logger.info('Email received', {
    from: email.fromEmail(),
    subject: email.subject()
  });

  const result = await c.agent.emailProcessor.run({
    sender: email.fromEmail() || 'unknown',
    content: email.text() || email.html() || ''
  });

  return c.json({ processed: true });
});
```

**Email object structure:**
```typescript
interface Email {
  // Sender information
  fromEmail(): string | null;
  fromName(): string | null;

  // Recipient information
  to(): string | null;              // All recipients (comma-separated)
  toEmail(): string | null;         // First recipient email
  toName(): string | null;          // First recipient name

  // Message content
  subject(): string | null;
  text(): string | null;
  html(): string | null;

  // Attachments
  attachments(): Array<{
    filename: string;
    contentType: string;
  }>;

  // Metadata
  date(): Date | null;
  messageId(): string | null;
  headers(): Headers;
}
```

### WebSocket Routes

Create WebSocket endpoints for real-time bidirectional communication.

**Signature:** `router.websocket(path: string, handler: WebSocketHandler): Router`

```typescript
router.websocket('/chat', (c) => (ws) => {
  ws.onOpen((event) => {
    c.logger.info('WebSocket connected');
    ws.send(JSON.stringify({ type: 'connected' }));
  });

  ws.onMessage(async (event) => {
    const message = JSON.parse(event.data);

    const response = await c.agent.chatAgent.run({
      message: message.text
    });

    ws.send(JSON.stringify({ type: 'response', data: response }));
  });

  ws.onClose((event) => {
    c.logger.info('WebSocket disconnected');
  });
});
```

**WebSocket connection methods:**
- `onOpen(handler)`: Called when connection opens
- `onMessage(handler)`: Called when message received
- `onClose(handler)`: Called when connection closes
- `send(data)`: Send data to client

### Server-Sent Events (SSE)

Create SSE endpoints for server-to-client streaming.

**Signature:** `router.sse(path: string, handler: SSEHandler): Router`

```typescript
router.sse('/updates', (c) => async (stream) => {
  await stream.write({ type: 'connected' });

  // Stream agent progress updates
  const updates = await c.agent.longRunningAgent.run({ task: 'process' });

  for (const update of updates) {
    await stream.write({
      type: 'progress',
      data: update
    });
  }

  stream.onAbort(() => {
    c.logger.info('Client disconnected');
  });
});
```

**SSE stream methods:**
- `write(data)`: Send data as JSON
- `writeSSE(message)`: Send raw SSE message with event/id
- `onAbort(handler)`: Called when client disconnects
- `close()`: Close the stream

### Stream Routes

Create HTTP streaming endpoints for piping data streams.

**Signature:** `router.stream(path: string, handler: StreamHandler): Router`

```typescript
router.stream('/data', async (c) => {
  const stream = new ReadableStream({
    async start(controller) {
      const data = await c.agent.dataGenerator.run({ query: 'all' });

      for (const chunk of data) {
        controller.enqueue(
          new TextEncoder().encode(JSON.stringify(chunk) + '\n')
        );
      }

      controller.close();
    }
  });

  return stream;
});
```

### Cron Routes

Schedule recurring jobs using cron syntax.

**Signature:** `router.cron(schedule: string, handler: CronHandler): Router`

```typescript
// Run daily at 9am
router.cron('0 9 * * *', async (c) => {
  c.logger.info('Running daily report');

  const report = await c.agent.reportGenerator.run({
    type: 'daily',
    date: new Date().toISOString()
  });

  await c.kv.set('reports', `daily-${Date.now()}`, report);

  return c.json({ success: true });
});

// Run every 5 minutes
router.cron('*/5 * * * *', async (c) => {
  await c.agent.healthCheck.run({});
  return c.json({ checked: true });
});
```

**Cron schedule format:**
```
┌───────────── minute (0-59)
│ ┌───────────── hour (0-23)
│ │ ┌───────────── day of month (1-31)
│ │ │ ┌───────────── month (1-12)
│ │ │ │ ┌───────────── day of week (0-6, Sunday=0)
│ │ │ │ │
* * * * *
```

**More examples:**
- `0 9 * * *` - Daily at 9am
- `*/5 * * * *` - Every 5 minutes
- `0 0 * * 0` - Weekly on Sunday at midnight
- `0 0 1 * *` - Monthly on the 1st at midnight

### SMS Routes

Handle incoming SMS messages sent to a specific phone number.

**Signature:** `router.sms(params: { number: string }, handler: SMSHandler): Router`

```typescript
router.sms({ number: '+12345678900' }, async (c) => {
  const body = await c.req.json();

  c.logger.info('SMS received', {
    from: body.from,
    message: body.text
  });

  const response = await c.agent.smsBot.run({
    sender: body.from,
    message: body.text
  });

  return c.json({ reply: response });
});
```

Phone numbers must use E.164 format (e.g., `+12345678900`).

## Route Organization

### Agent Route Pattern

Each agent typically has two files that work together:

**agent.ts:**
```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ message: z.string() }),
    output: z.string()
  },
  handler: async (ctx, input) => {
    return `Received: ${input.message}`;
  }
});

export default agent;
```

**route.ts:**
```typescript
import { createRouter } from '@agentuity/runtime';
import { zValidator } from '@hono/zod-validator';
import agent from './agent';

const router = createRouter();

// GET route for easy testing
router.get('/', async (c) => {
  const result = await c.agent.myAgent.run({ message: 'Test' });
  return c.text(result);
});

// POST route with validation
router.post('/',
  zValidator('json', agent.inputSchema!),
  async (c) => {
    const data = c.req.valid('json');
    const result = await c.agent.myAgent.run(data);
    return c.text(result);
  }
);

export default router;
```

The GET route provides an easy way to test the agent in a browser, while the POST route is the primary endpoint with input validation.

### Request Context

The context object (`c`) provides access to request data and Agentuity services:

**Note:** Route handlers use Hono Context (often called `c`), which is different from the AgentContext used in agent handlers. See the [Context Types Guide](/v1/Guides/context-types) for details.

**Request data:**
```typescript
c.req.json()           // Parse JSON body
c.req.text()           // Get text body
c.req.param('id')      // Get route parameter
c.req.query('page')    // Get query string
c.req.header('Auth')   // Get request header
```

**Responses:**
```typescript
c.json(data)           // Send JSON response
c.text(string)         // Send text response
c.html(markup)         // Send HTML response
c.redirect(url)        // Redirect to URL
```

**Agentuity services:**
```typescript
c.agent.name.run()     // Call another agent
c.kv.get/set/delete()  // Key-value storage
c.vector.search()      // Vector database
c.logger.info()        // Structured logging
c.objectstore.*        // Object storage
```

## Best Practices

### Validate All Input

Always validate request input using schemas:

```typescript
// Define schema
const schema = z.object({
  email: z.string().email(),
  age: z.number().min(0)
});

// Use in route
router.post('/endpoint',
  zValidator('json', schema),
  async (c) => {
    const data = c.req.valid('json'); // Guaranteed valid
    // ...
  }
);
```

### Use Structured Logging

Use `c.logger` (not `console.log`) for searchable, traceable logs:

```typescript
c.logger.info('User created', { userId, timestamp: Date.now() });
c.logger.error('Failed to process', { error: err.message });
```

### Export Router as Default

Route files must export the router as the default export:

```typescript
const router = createRouter();
// ... define routes ...
export default router;
```

### Route Order Matters

Register specific routes before generic ones:

```typescript
// Correct order
router.get('/users/admin', adminHandler);
router.get('/users/:id', userHandler);

// Wrong - :id matches everything including "admin"
router.get('/users/:id', userHandler);
router.get('/users/admin', adminHandler); // Never reached
```
