---
title: App Configuration
description: Configure your Agentuity project
---

Agentuity projects use minimal configuration. Most setup happens in code, not config files.

## agentuity.json

The project configuration file:

```json
{
  "name": "my-project",
  "orgId": "org_...",
  "projectId": "proj_..."
}
```

No agent definitions, no trigger configurations. Those live in your code.

## app.ts

The app entry point configures your application:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

export default app.server;
```

### With Options

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp({
  // CORS configuration
  cors: {
    origin: ['https://myapp.com'],
    credentials: true,
  },

  // Custom storage implementations (optional)
  services: {
    keyvalue: myCustomKV,
    vector: myCustomVector,
  },
});

// App-level event listeners
app.addEventListener('agent.started', (event, agent, ctx) => {
  app.logger.info('Agent started', { name: agent.metadata.name });
});

app.addEventListener('agent.completed', (event, agent, ctx) => {
  app.logger.info('Agent completed', { session: ctx.sessionId });
});

export default app.server;
```

## Environment Variables

```bash
# Required
AGENTUITY_SDK_KEY=...        # API key for Agentuity services

# Optional
AGENTUITY_LOG_LEVEL=info     # trace, debug, info, warn, error
AGENTUITY_PORT=3500          # Dev server port (default: 3500)

# LLM Provider Keys (optional; if using your own API keys instead of the AI Gateway)
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
```

<Callout type="info" title="AI Gateway">
If you don't set provider API keys, LLM requests are routed through the Agentuity AI Gateway using your SDK key. This provides unified billing and monitoring.
</Callout>

## Infrastructure as Code

Unlike traditional platforms, Agentuity defines infrastructure in your route files:

```typescript
// src/agents/scheduler/route.ts
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

// Cron job - runs every hour
router.cron('0 * * * *', async (c) => {
  await c.agent.scheduler.run({ task: 'cleanup' });
  return c.text('OK');
});

// Email trigger
router.email('support@mycompany.com', async (email, c) => {
  const result = await c.agent.emailHandler.run({
    from: email.fromEmail(),
    subject: email.subject(),
    body: email.text(),
  });
  return c.text('Processed');
});

export default router;
```

This approach means:
- **Deployments are self-contained** — rolling back restores exact configuration
- **Version control** — your infrastructure changes are tracked in Git
- **No config drift** — what's in code is what runs

## Next Steps

- [HTTP Routes](/Building/Routes-Triggers/http-routes) — Define HTTP endpoints
- [Cron Jobs](/Building/Routes-Triggers/cron) — Schedule recurring tasks
- [AI Gateway](/Building/Agents/ai-gateway) — Configure LLM providers
