---
title: App Configuration
description: Configure your Agentuity project
---

Agentuity projects use minimal configuration. Most setup happens in code, not config files.

## agentuity.json

The project configuration file:

```json
{
  "name": "my-project",
  "orgId": "org_...",
  "projectId": "proj_..."
}
```

No agent definitions, no trigger configurations. Those live in your code.

## app.ts

The app entry point configures your application:

```typescript
import { createApp } from '@agentuity/runtime';

const { server, logger } = await createApp();

logger.debug('Running %s', server.url);
```

### With Lifecycle Hooks

Use `setup` to initialize resources (databases, clients) and `shutdown` to clean up:

```typescript
import { createApp } from '@agentuity/runtime';

const { server, logger } = await createApp({
  setup: async () => {
    // Initialize resources, return app state
    // Available in agents via ctx.app
    const db = await connectDatabase();
    return { db };
  },
  shutdown: async (state) => {
    // Clean up resources
    await state.db.close();
  },
});

logger.debug('Running %s', server.url);
```

### With Custom Services

```typescript
import { createApp } from '@agentuity/runtime';

const { server, logger } = await createApp({
  // CORS configuration
  cors: {
    origin: ['https://myapp.com'],
    credentials: true,
  },

  // Custom storage implementations (optional)
  services: {
    keyvalue: myCustomKV,
    vector: myCustomVector,
  },
});
```

### Event Listeners

Listen for agent and session lifecycle events:

```typescript
import { createApp } from '@agentuity/runtime';

const app = await createApp();

app.addEventListener('agent.started', (event, agent, ctx) => {
  app.logger.info('Agent started', { name: agent.metadata.name });
});

app.addEventListener('agent.completed', (event, agent, ctx) => {
  app.logger.info('Agent completed', { session: ctx.sessionId });
});
```

## Build Configuration

For advanced build customization, create an `agentuity.config.ts` file in your project root:

```typescript
import type { BuildPhase, BuildContext, BuildConfig } from '@agentuity/cli';

export default function config(phase: BuildPhase, context: BuildContext): BuildConfig {
  return {};
}
```

<Callout type="info" title="Optional">
Most projects don't need build configuration. Use this when adding Bun plugins (like Tailwind CSS), excluding packages from bundling, or defining build-time constants.
</Callout>

See [Build Configuration](/v1/Reference/CLI/build-configuration) for all options and examples.

## Environment Variables

```bash
# Required
AGENTUITY_SDK_KEY=...        # API key for Agentuity services

# Optional
AGENTUITY_LOG_LEVEL=info     # trace, debug, info, warn, error
AGENTUITY_PORT=3500          # Dev server port (default: 3500)

# LLM Provider Keys (optional; if using your own API keys instead of the AI Gateway)
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...

# Frontend-accessible (exposed to browser)
AGENTUITY_PUBLIC_API_URL=... # Any AGENTUITY_PUBLIC_* vars are bundled into frontend
```

<Callout type="info" title="AI Gateway">
If you don't set provider API keys, LLM requests are routed through the Agentuity AI Gateway using your SDK key. This provides unified billing and monitoring.
</Callout>

<Callout type="warning" title="Public Environment Variables">
Environment variables prefixed with `AGENTUITY_PUBLIC_` are exposed to the frontend bundle and visible in the browser. Never put secrets or API keys in `AGENTUITY_PUBLIC_*` variables.
</Callout>

## Infrastructure as Code

Unlike traditional platforms, Agentuity defines infrastructure in your route files:

```typescript
// src/api/index.ts
import { createRouter } from '@agentuity/runtime';
import scheduler from '@agent/scheduler';
import emailHandler from '@agent/email-handler';

const router = createRouter();

// Cron job - runs every hour
router.cron('0 * * * *', async (c) => {
  await scheduler.run({ task: 'cleanup' });
  return c.text('OK');
});

// Email trigger
router.email('support@mycompany.com', async (email, c) => {
  const result = await emailHandler.run({
    from: email.fromEmail(),
    subject: email.subject(),
    body: email.text(),
  });
  return c.text('Processed');
});

export default router;
```

This approach means:
- **Deployments are self-contained**: rolling back restores exact configuration
- **Version control**: your infrastructure changes are tracked in Git
- **No config drift**: what's in code is what runs

## Next Steps

- [HTTP Routes](/v1/Build/Routes/http): Define HTTP endpoints
- [Cron Jobs](/v1/Build/Routes/cron): Schedule recurring tasks
- [AI Gateway](/v1/Build/Agents/ai-gateway): Configure LLM providers
