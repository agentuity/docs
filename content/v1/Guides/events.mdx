---
title: Events
description: Lifecycle hooks for monitoring and extending agent behavior
---

Events provide lifecycle hooks for monitoring and extending agent behavior at three scopes: agent-level for individual executions, app-level for global tracking, and thread/session for state management. Use events for logging, metrics collection, analytics, and error tracking. All event listeners execute sequentially and support async operations.

For more on sessions and threads, see [Core Concepts](/Introduction/core-concepts). For additional event examples, see the [Examples](/Examples) page.

## Agent Events

Agent events track the execution lifecycle of individual agents. Three events are available: `started` (when execution begins), `completed` (when execution finishes successfully), and `errored` (when an error occurs). Register listeners using `agent.addEventListener()` for agent-specific monitoring and validation.

### Basic Agent Events

Track agent execution with lifecycle events:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ task: z.string() }),
    output: z.object({ result: z.string() })
  },
  handler: async (ctx, input) => {
    ctx.logger.info('Processing task', { task: input.task });

    // Simulate processing
    await new Promise(resolve => setTimeout(resolve, 100));

    return { result: `Completed: ${input.task}` };
  }
});

// Track when agent starts
agent.addEventListener('started', (eventName, agent, ctx) => {
  ctx.state.set('startTime', Date.now());
  ctx.logger.info('Agent started', {
    agentName: agent.metadata.name,
    sessionId: ctx.sessionId
  });
});

// Track successful completion
agent.addEventListener('completed', (eventName, agent, ctx) => {
  const startTime = ctx.state.get('startTime') as number;
  const duration = Date.now() - startTime;

  ctx.logger.info('Agent completed', {
    agentName: agent.metadata.name,
    duration,
    sessionId: ctx.sessionId
  });
});

// Track errors
agent.addEventListener('errored', (eventName, agent, ctx, error) => {
  const startTime = ctx.state.get('startTime') as number;
  const duration = Date.now() - startTime;

  ctx.logger.error('Agent failed', {
    agentName: agent.metadata.name,
    duration,
    error: error.message,
    sessionId: ctx.sessionId
  });
});

export default agent;
```

**Key Points:**
- Event listeners receive the event name, agent instance, and context
- `errored` listeners also receive the error object
- Use `ctx.state` to share data between event listeners
- Events execute sequentially in registration order

### Agent Validation with Events

Use the `completed` event to validate output quality without blocking execution:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ query: z.string() }),
    output: z.object({
      answer: z.string(),
      confidence: z.number()
    })
  },
  handler: async (ctx, input) => {
    // Process query and return result
    return {
      answer: `Answer to: ${input.query}`,
      confidence: 0.85
    };
  }
});

// Validate output quality in completed event
agent.addEventListener('completed', (eventName, agent, ctx) => {
  // Access the validated output from context state
  const output = ctx.state.get('_evalOutput') as { answer: string; confidence: number };

  // Check confidence threshold
  if (output.confidence < 0.7) {
    ctx.logger.warn('Low confidence output detected', {
      confidence: output.confidence,
      threshold: 0.7,
      agentName: agent.metadata.name
    });
  }

  // Check answer length
  if (output.answer.length < 10) {
    ctx.logger.warn('Suspiciously short answer', {
      answerLength: output.answer.length,
      agentName: agent.metadata.name
    });
  }
});

export default agent;
```

**Key Points:**
- Validated input/output stored in `ctx.state` as `_evalInput` and `_evalOutput`
- Event listeners should log warnings, not throw errors
- Keep validation logic lightweight to avoid blocking

For automated quality testing, see the [Evaluations Guide](/Guides/evaluations), which uses events internally to run after agent execution.

## App-Level Events

App-level events track all agents, sessions, and threads globally. These events fire automatically for all agent executions and lifecycle changes. Register app-level listeners in `app.ts` using `app.addEventListener()`.

Available app-level events:
- `agent.started`, `agent.completed`, `agent.errored` - Track all agent executions
- `session.started`, `session.completed` - Track session lifecycle
- `thread.created`, `thread.destroyed` - Track thread lifecycle

**Event Bubbling:** When an agent event fires, both the agent-level listeners and app-level listeners execute. This allows for both specific and global monitoring.

### Global Agent Tracking

Track all agent executions across your application:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// Track execution counts per agent
const executionCounts = new Map<string, number>();

app.addEventListener('agent.started', (eventName, agent, ctx) => {
  const agentName = agent.metadata.name || 'unknown';
  const count = executionCounts.get(agentName) || 0;
  executionCounts.set(agentName, count + 1);

  app.logger.info('Agent execution started', {
    agent: agentName,
    executionCount: count + 1,
    session: ctx.sessionId
  });
});

app.addEventListener('agent.completed', (eventName, agent, ctx) => {
  app.logger.info('Agent execution completed', {
    agent: agent.metadata.name,
    session: ctx.sessionId
  });
});

app.addEventListener('agent.errored', (eventName, agent, ctx, error) => {
  app.logger.error('Agent execution failed', {
    agent: agent.metadata.name,
    error: error.message,
    stack: error.stack,
    session: ctx.sessionId
  });
});

export default app.server;
```

**Key Points:**
- App-level events provide global visibility into all executions
- Use for cross-cutting concerns like analytics and monitoring
- Event handlers have access to agent metadata and context

### Session & Thread Lifecycle

Monitor session and thread creation and completion:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// Track active sessions
const activeSessions = new Map<string, { startTime: number; requestCount: number }>();

app.addEventListener('session.started', (eventName, session) => {
  activeSessions.set(session.id, {
    startTime: Date.now(),
    requestCount: 0
  });

  app.logger.info('Session started', {
    sessionId: session.id,
    threadId: session.thread.id
  });
});

app.addEventListener('session.completed', (eventName, session) => {
  const sessionData = activeSessions.get(session.id);

  if (sessionData) {
    const duration = Date.now() - sessionData.startTime;

    app.logger.info('Session completed', {
      sessionId: session.id,
      duration,
      requestCount: sessionData.requestCount
    });

    activeSessions.delete(session.id);
  }
});

app.addEventListener('thread.created', (eventName, thread) => {
  app.logger.info('Thread created', {
    threadId: thread.id
  });
});

app.addEventListener('thread.destroyed', (eventName, thread) => {
  app.logger.info('Thread destroyed', {
    threadId: thread.id
  });
});

export default app.server;
```

**Key Points:**
- Sessions and threads have their own lifecycle events
- Track session duration and request counts
- Threads are destroyed after 1 hour of inactivity

## Thread & Session Events

Thread and session instances provide their own event listeners for cleanup and state management.

**Thread Events:**
- `destroyed` - Fired when `thread.destroy()` is called or thread expires

**Session Events:**
- `completed` - Fired when session is saved

Register listeners directly on thread or session instances within agent handlers.

For detailed session and thread management patterns, see the [Sessions & Threads Guide](/Guides/sessions-threads).

### Thread Cleanup

Clean up resources when threads are destroyed:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Register cleanup handler on first access
    if (!ctx.thread.state.has('cleanupRegistered')) {
      ctx.thread.addEventListener('destroyed', (eventName, thread) => {
        ctx.logger.info('Cleaning up thread resources', {
          threadId: thread.id,
          messageCount: thread.state.get('messageCount') || 0
        });

        // Clean up any thread-specific resources
        thread.state.clear();
      });

      ctx.thread.state.set('cleanupRegistered', true);
    }

    // Track messages in this thread
    const messageCount = (ctx.thread.state.get('messageCount') as number) || 0;
    ctx.thread.state.set('messageCount', messageCount + 1);

    return { processed: true };
  }
});

export default agent;
```

**Key Points:**
- Thread `destroyed` event fires when thread expires or is manually destroyed
- Use for cleanup of thread-scoped resources
- Access thread state in event listeners

### Session State Persistence

Save session state when sessions complete:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ action: z.string() })
  },
  handler: async (ctx, input) => {
    // Register session completion handler once
    if (!ctx.session.state.has('persistenceRegistered')) {
      ctx.session.addEventListener('completed', async (eventName, session) => {
        // Save session metrics to KV storage
        const metrics = {
          totalRequests: session.state.get('totalRequests') || 0,
          lastAction: session.state.get('lastAction'),
          duration: Date.now() - (session.state.get('startTime') as number || Date.now())
        };

        await ctx.kv.set('session-metrics', session.id, metrics, {
          ttl: 86400 // 24 hours
        });

        ctx.logger.info('Session metrics saved', {
          sessionId: session.id,
          metrics
        });
      });

      ctx.session.state.set('persistenceRegistered', true);
      ctx.session.state.set('startTime', Date.now());
    }

    // Track session activity
    const totalRequests = (ctx.session.state.get('totalRequests') as number) || 0;
    ctx.session.state.set('totalRequests', totalRequests + 1);
    ctx.session.state.set('lastAction', input.action);

    return { success: true };
  }
});

export default agent;
```

**Key Points:**
- Session `completed` event fires when session is saved
- Use for persisting session data to storage
- Register event listeners once using a flag in session state

## Common Patterns

### Request Timing & Performance Monitoring

Track agent execution time and identify slow operations:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Process request
    await new Promise(resolve => setTimeout(resolve, 1200));
    return { result: 'completed' };
  }
});

agent.addEventListener('started', (eventName, agent, ctx) => {
  ctx.state.set('performanceStart', performance.now());
});

agent.addEventListener('completed', (eventName, agent, ctx) => {
  const startTime = ctx.state.get('performanceStart') as number;
  const duration = performance.now() - startTime;

  // Log slow executions
  if (duration > 1000) {
    ctx.logger.warn('Slow agent execution detected', {
      agentName: agent.metadata.name,
      duration,
      threshold: 1000,
      sessionId: ctx.sessionId
    });
  }

  ctx.logger.info('Agent execution time', {
    agentName: agent.metadata.name,
    duration
  });
});

export default agent;
```

### Error Tracking & Aggregation

Capture and aggregate errors across all agents:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// Track error counts by type
const errorCounts = new Map<string, number>();

app.addEventListener('agent.errored', async (eventName, agent, ctx, error) => {
  const errorType = error.name || 'UnknownError';
  const count = errorCounts.get(errorType) || 0;
  errorCounts.set(errorType, count + 1);

  // Log detailed error information
  app.logger.error('Agent error captured', {
    agentName: agent.metadata.name,
    errorType,
    errorMessage: error.message,
    errorCount: count + 1,
    sessionId: ctx.sessionId,
    stack: error.stack
  });

  // Store error log in KV storage
  const errorLog = {
    timestamp: new Date().toISOString(),
    agentName: agent.metadata.name,
    errorType,
    message: error.message,
    sessionId: ctx.sessionId
  };

  const errorKey = `error-${Date.now()}-${Math.random().toString(36).slice(2)}`;
  await ctx.kv.set('error-logs', errorKey, errorLog, {
    ttl: 604800 // 7 days
  });
});

export default app.server;
```

### Analytics & Usage Tracking

Track agent usage patterns and session metrics:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// Track agent invocations
app.addEventListener('agent.completed', async (eventName, agent, ctx) => {
  const agentName = agent.metadata.name || 'unknown';
  const today = new Date().toISOString().split('T')[0];
  const metricsKey = `agent-metrics-${today}-${agentName}`;

  // Get current count
  const result = await ctx.kv.get('analytics', metricsKey);
  let count = 0;

  if (result.exists) {
    const data = await result.data.json();
    count = data.count || 0;
  }

  // Increment and store
  await ctx.kv.set('analytics', metricsKey, {
    count: count + 1,
    agentName,
    date: today
  }, {
    ttl: 2592000 // 30 days
  });
});

// Track session durations
app.addEventListener('session.completed', async (eventName, session) => {
  const startTime = session.state.get('sessionStart') as number;

  if (startTime) {
    const duration = Date.now() - startTime;

    app.logger.info('Session analytics', {
      sessionId: session.id,
      duration,
      requestCount: session.state.get('requestCount') || 0
    });
  }
});

export default app.server;
```

### Audit Logging

Log all agent executions for compliance and debugging:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

app.addEventListener('agent.started', async (eventName, agent, ctx) => {
  const auditLog = {
    timestamp: new Date().toISOString(),
    event: 'agent.started',
    agentName: agent.metadata.name,
    agentId: agent.metadata.id,
    sessionId: ctx.sessionId,
    agentVersion: agent.metadata.version
  };

  // Store in object storage for long-term retention
  const logKey = `${auditLog.timestamp}-${ctx.sessionId}-${agent.metadata.name}.json`;

  await ctx.objectstore.put('audit-logs', logKey, auditLog, {
    contentType: 'application/json',
    metadata: {
      sessionId: ctx.sessionId,
      agentName: agent.metadata.name,
      timestamp: auditLog.timestamp
    }
  });
});

app.addEventListener('agent.completed', async (eventName, agent, ctx) => {
  const auditLog = {
    timestamp: new Date().toISOString(),
    event: 'agent.completed',
    agentName: agent.metadata.name,
    sessionId: ctx.sessionId
    // Note: Do not log full input/output for privacy
  };

  const logKey = `${auditLog.timestamp}-${ctx.sessionId}-${agent.metadata.name}-completed.json`;

  await ctx.objectstore.put('audit-logs', logKey, auditLog, {
    contentType: 'application/json'
  });
});

export default app.server;
```

**Key Points:**
- Store audit logs in object storage for long-term retention
- Include timestamps, agent metadata, and session IDs
- Avoid logging sensitive data (full input/output)
- Use metadata for filtering and searching

See the [API Reference](/api-reference#key-value-storage) for complete documentation on storage APIs (KV, Vector, ObjectStore) and streaming.

## Best Practices

<Callout type="info">
**Event Handler Guidelines**

- **Keep handlers lightweight** - Event listeners should complete quickly to avoid blocking execution
- **Use `ctx.waitUntil()`** - For non-blocking background work, use `ctx.waitUntil()` to defer processing until after the response is sent
- **Don't modify request flow** - Event handlers should not throw errors to stop execution or modify the response
- **Sequential execution** - Event listeners execute in registration order, one at a time
- **Error handling** - Errors in event handlers are logged but don't stop execution or affect other listeners
- **Use appropriate scope** - Use app-level events for cross-cutting concerns, agent-level events for agent-specific logic
- **Avoid side effects** - Event handlers should primarily observe and log, not modify state that affects business logic
</Callout>

### Using waitUntil in Events

Use `ctx.waitUntil()` to perform heavy work without blocking the response:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    return { result: 'processed' };
  }
});

agent.addEventListener('completed', (eventName, agent, ctx) => {
  // Use waitUntil for non-blocking background work
  ctx.waitUntil(async () => {
    // Simulate sending metrics to external service
    await new Promise(resolve => setTimeout(resolve, 500));

    ctx.logger.info('Metrics sent to external service', {
      agentName: agent.metadata.name,
      sessionId: ctx.sessionId
    });
  });

  // This logs immediately
  ctx.logger.info('Agent completed (handler finished)', {
    agentName: agent.metadata.name
  });
});

export default agent;
```

**Key Points:**
- `waitUntil()` executes after the response is sent to the client
- Use for analytics, metrics, or external API calls
- Prevents blocking the user-facing response
- Multiple `waitUntil()` calls can run concurrently

## Event Execution Order

Events execute in a predictable sequence:

1. Agent `started` event fires
2. App `agent.started` event fires
3. Agent handler executes
4. Agent `completed` event fires (or `errored` if exception occurs)
5. App `agent.completed` event fires (or `agent.errored`)

All event listeners execute sequentially. If an agent-level `completed` listener and an app-level `agent.completed` listener are both registered, the agent-level listener executes first.

### Event Order Demonstration

Observe event execution order with timestamps:

```typescript
import { createAgent } from '@agentuity/runtime';
import { createApp } from '@agentuity/runtime';

// In app.ts
const app = createApp();

app.addEventListener('agent.started', (eventName, agent, ctx) => {
  console.log(`[${Date.now()}] App: agent.started - ${agent.metadata.name}`);
});

app.addEventListener('agent.completed', (eventName, agent, ctx) => {
  console.log(`[${Date.now()}] App: agent.completed - ${agent.metadata.name}`);
});

export default app.server;

// In agent.ts
const agent = createAgent({
  handler: async (ctx, input) => {
    console.log(`[${Date.now()}] Agent: handler executing`);
    await new Promise(resolve => setTimeout(resolve, 100));
    return { result: 'done' };
  }
});

agent.addEventListener('started', (eventName, agent, ctx) => {
  console.log(`[${Date.now()}] Agent: started event`);
});

agent.addEventListener('completed', (eventName, agent, ctx) => {
  console.log(`[${Date.now()}] Agent: completed event`);
});

export default agent;
```

**Expected Output:**
```
[1234567890] Agent: started event
[1234567891] App: agent.started
[1234567892] Agent: handler executing
[1234567992] Agent: completed event
[1234567993] App: agent.completed
```

**Key Points:**
- Agent-level events fire before app-level events
- All listeners execute sequentially (blocking)
- Handler execution occurs between `started` and `completed` events
- Event timing is predictable and deterministic
