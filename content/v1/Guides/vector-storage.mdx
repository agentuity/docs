---
title: Vector Storage
description: Semantic search and retrieval for knowledge bases, RAG systems, and agent memory
---

# Vector Storage

Vector storage enables semantic search for your agents, allowing them to find information by meaning rather than keywords. Use it for knowledge bases, RAG systems, and persistent agent memory.

## When to Use Vector Storage

Vector storage enables semantic search for your agents, allowing them to find information by meaning rather than keywords. Ideal for knowledge bases, RAG systems, and persistent agent memory.

Choose the right storage for your use case:

- **Vector Storage**: Semantic search, embeddings, similarity matching
- **[Key-Value Storage](/Guides/key-value-storage)**: Fast lookups, simple data, temporary state
- **[Object Storage](/Guides/object-storage)**: Large files, media, backups

## Understanding Vector Storage

Vector storage works by converting text into high-dimensional numerical representations (embeddings) that capture semantic meaning. When you search, the system finds documents with similar meanings rather than just keyword matches.

**Key use cases:**
- Knowledge bases and documentation search
- Long-term memory across agent sessions
- RAG systems combining retrieval with AI generation
- Semantic similarity search

## Managing Vector Instances

### Viewing Vector Storage in the Cloud Console

Navigate to **Services > Vector** in the Agentuity Cloud Console to view all your vector storage instances. The interface shows:

- **Database Name**: The identifier for your vector storage
- **Projects**: Which projects are using this storage
- **Agents**: Which agents have access
- **Size**: Storage utilization

You can filter instances by name using the search box and create new vector storage instances with the **Create Storage** button.

TODO: Add screenshot of Vector Storage Overview

### Creating Vector Storage

You can create vector storage either through the Cloud Console or programmatically in your agent code.

#### Via Cloud Console

Navigate to **Services > Vector** and click **Create Storage**. Choose a descriptive name that reflects the storage purpose (e.g., `knowledge-base`, `agent-memory`, `product-catalog`).

#### Via SDK

Vector storage is created automatically when your agent first calls `ctx.vector.upsert()` with an instance name:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Storage 'knowledge-base' is auto-created if it doesn't exist
    await ctx.vector.upsert('knowledge-base', {
      key: 'doc-1',
      document: 'Agentuity is an agent-native cloud platform',
      metadata: { category: 'platform' }
    });

    return { success: true };
  }
});
```

## Vector Storage API

All vector operations are accessed through `ctx.vector` in your agent handler. The API provides type-safe methods for upserting, searching, retrieving, and deleting vectors.

### Upserting Documents

The `upsert` operation inserts new documents or updates existing ones. You can provide either text (which gets automatically converted to embeddings) or pre-computed embeddings.

**Key Requirement:**
- All documents require a `key` field as a unique identifier

**Idempotent Behavior:**
The upsert operation is idempotent - upserting with an existing key updates the existing vector rather than creating a duplicate. The same internal vector ID is reused, ensuring your vector storage remains clean and efficient.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Upsert documents with text (automatic embedding)
    const results = await ctx.vector.upsert(
      'knowledge-base',
      {
        key: 'doc-1',
        document: 'Agentuity is an agent-native cloud platform',
        metadata: { category: 'platform', source: 'docs' }
      },
      {
        key: 'doc-2',
        document: 'Vector storage enables semantic search capabilities',
        metadata: { category: 'features', source: 'docs' }
      }
    );

    // Returns array of {key, id} mappings
    // results = [
    //   { key: 'doc-1', id: 'internal-id-123' },
    //   { key: 'doc-2', id: 'internal-id-456' }
    // ]

    return { insertedCount: results.length };
  }
});
```

**Upsert with Pre-computed Embeddings:**

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Upsert with pre-computed embeddings
    const embeddingResults = await ctx.vector.upsert(
      'custom-embeddings',
      {
        key: 'embedding-1',
        embeddings: [0.1, 0.2, 0.3, 0.4],
        metadata: { id: 'doc-1', type: 'custom' }
      }
    );

    return { success: true };
  }
});
```

**Return Value:**
- Returns `VectorUpsertResult[]` - array of `{ key: string, id: string }` objects
- The `key` matches your provided key
- The `id` is the internal vector ID assigned by the service

### Searching Vector Storage

Search operations find semantically similar documents based on a text query. You can control the number of results, similarity threshold, and filter by metadata.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Basic semantic search
    const results = await ctx.vector.search('knowledge-base', {
      query: 'What is an agent platform?',
      limit: 5,
      similarity: 0.7,
      metadata: { category: 'platform' }
    });

    // Process results
    const formattedResults = results.map(result => ({
      content: result.metadata?.text,
      source: result.metadata?.source,
      similarity: result.similarity
    }));

    return { results: formattedResults };
  }
});
```

**Search Parameters:**
- `query` (required): Text query to search for
- `limit` (optional): Maximum number of results to return
- `similarity` (optional): Minimum similarity threshold (0.0-1.0)
- `metadata` (optional): Filter results by metadata key-value pairs

**Search Results:**
Each result includes:
- `id`: Internal vector ID
- `key`: Your unique key
- `similarity`: Score from 0.0-1.0 (1.0 = perfect match)
- `metadata`: Your stored metadata object

**Type Safety with Generics:**

```typescript
interface DocumentMetadata {
  title: string;
  category: string;
  source: string;
  text: string;
}

const agent = createAgent({
  handler: async (ctx, input) => {
    // Specify metadata type for type-safe access
    const results = await ctx.vector.search<DocumentMetadata>('knowledge-base', {
      query: input.question,
      limit: 3,
      similarity: 0.7
    });

    // TypeScript knows the shape of metadata
    const titles = results.map(r => r.metadata?.title);
    const categories = results.map(r => r.metadata?.category);

    return { titles, categories };
  }
});
```

### Retrieving Vectors by Key

The `get` method retrieves a specific vector directly using its key, without performing a similarity search. Returns a discriminated union for type-safe null checking.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Direct lookup by key
    const result = await ctx.vector.get('knowledge-base', 'doc-1');

    if (result.exists) {
      // TypeScript knows result.data exists here
      console.log(`Found: ${result.data.id}`);
      console.log(`Key: ${result.data.key}`);
      console.log('Metadata:', result.data.metadata);
    } else {
      console.log('Vector not found');
    }

    return { found: result.exists };
  }
});
```

**Type-Safe with Discriminated Union:**

The `get` method returns a discriminated union that TypeScript can narrow based on the `exists` property:

```typescript
interface UserPreferences {
  theme: string;
  language: string;
}

const agent = createAgent({
  handler: async (ctx, input) => {
    const result = await ctx.vector.get<UserPreferences>('user-prefs', input.userId);

    // Type-safe access
    if (result.exists) {
      // TypeScript knows result.data is available
      const theme = result.data.metadata?.theme;
      const language = result.data.metadata?.language;
      return { theme, language };
    }

    // Handle not found
    return { theme: 'default', language: 'en' };
  }
});
```

**Common Use Cases:**

```typescript
// 1. Check if a vector exists before updating
const existing = await ctx.vector.get('products', 'product-123');
if (existing.exists) {
  // Update with merged metadata
  await ctx.vector.upsert('products', {
    key: 'product-123',
    document: 'Updated product description',
    metadata: {
      ...(existing.data.metadata ?? {}),
      lastUpdated: Date.now()
    }
  });
}

// 2. Retrieve full metadata after search
const searchResults = await ctx.vector.search('products', {
  query: 'office chair',
  limit: 5
});

// Get complete details for the top result
if (searchResults[0]) {
  const fullDetails = await ctx.vector.get('products', searchResults[0].key);
  if (fullDetails.exists) {
    console.log('Full metadata:', fullDetails.data.metadata);
  }
}
```

**When to use `get` vs `search`:**
- Use `get` when you know the exact key (like a database primary key lookup)
- Use `search` when finding vectors by semantic similarity
- `get` is faster for single lookups since it doesn't compute similarities
- `get` returns `{ exists: false }` if the key is not found

### Batch Retrieval with getMany()

The `getMany` method retrieves multiple vectors by their keys in a single operation. Returns a `Map` for efficient lookups.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Retrieve multiple documents at once
    const keys = ['doc-1', 'doc-2', 'doc-3'];
    const resultMap = await ctx.vector.getMany('knowledge-base', ...keys);

    // resultMap is a Map<string, VectorSearchResultWithDocument<T>>
    const documents = [];
    for (const [key, result] of resultMap) {
      documents.push({
        key,
        content: result.document,
        metadata: result.metadata
      });
    }

    return {
      requestedCount: keys.length,
      foundCount: resultMap.size,
      documents
    };
  }
});
```

**Use Cases:**

```typescript
// 1. Fetch user's saved documents
const agent = createAgent({
  handler: async (ctx, input) => {
    const savedKeys = input.userSavedDocIds; // ['faq-1', 'guide-5', 'tutorial-3']
    const docs = await ctx.vector.getMany('docs', ...savedKeys);

    return {
      savedDocs: Array.from(docs.values()).map(d => ({
        title: d.metadata?.title,
        summary: d.metadata?.summary
      }))
    };
  }
});

// 2. Hydrate search results with full content
const agent = createAgent({
  handler: async (ctx, input) => {
    // First, search for relevant documents
    const searchResults = await ctx.vector.search('kb', {
      query: input.question,
      limit: 10
    });

    // Then batch-fetch full details for top 3
    const topKeys = searchResults.slice(0, 3).map(r => r.key);
    const fullDocs = await ctx.vector.getMany('kb', ...topKeys);

    return {
      results: Array.from(fullDocs.values()).map(doc => ({
        content: doc.document,
        metadata: doc.metadata,
        similarity: searchResults.find(r => r.key === doc.key)?.similarity
      }))
    };
  }
});
```

**Key Points:**
- Returns `Map<string, VectorSearchResultWithDocument<T>>` for efficient key-based lookups
- Only includes vectors that were found (missing keys are absent from the Map)
- More efficient than calling `get()` multiple times
- Results include full document content and embeddings

### Checking Storage Existence

The `exists` method checks if a vector storage instance exists without retrieving any data.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Check before expensive operations
    const hasKnowledgeBase = await ctx.vector.exists('knowledge-base');

    if (!hasKnowledgeBase) {
      return {
        error: 'Knowledge base not initialized',
        suggestion: 'Please upload documents first'
      };
    }

    // Proceed with search
    const results = await ctx.vector.search('knowledge-base', {
      query: input.question
    });

    return { results };
  }
});
```

**Common Use Cases:**

```typescript
// 1. Conditional initialization
const agent = createAgent({
  handler: async (ctx, input) => {
    const storageExists = await ctx.vector.exists('user-memory');

    if (!storageExists) {
      // Initialize with default documents
      await ctx.vector.upsert('user-memory', {
        key: 'welcome',
        document: 'Welcome to the system',
        metadata: { type: 'system' }
      });
    }

    return { initialized: true };
  }
});

// 2. Feature availability check
const agent = createAgent({
  handler: async (ctx, input) => {
    const features = {
      search: await ctx.vector.exists('search-index'),
      recommendations: await ctx.vector.exists('recommendations'),
      history: await ctx.vector.exists('user-history')
    };

    return { availableFeatures: features };
  }
});
```

**Performance Note:**
- Lightweight operation for checking availability
- Useful before expensive search operations
- Helps provide better error messages to users

### Deleting Vectors

Remove specific vectors from storage using their keys.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Delete single vector
    const deletedCount = await ctx.vector.delete('knowledge-base', 'doc-1');

    // Delete multiple vectors
    const bulkDeleteCount = await ctx.vector.delete(
      'knowledge-base',
      'doc-1', 'doc-2', 'doc-3'
    );

    return { deletedCount: bulkDeleteCount };
  }
});
```

**Return Value:**
- Returns the count of deleted vectors
- Returns `0` if no keys were provided or if keys don't exist

**Use Cases:**

```typescript
// 1. Remove outdated documents
const agent = createAgent({
  handler: async (ctx, input) => {
    const outdatedKeys = ['old-doc-1', 'deprecated-faq'];
    const count = await ctx.vector.delete('docs', ...outdatedKeys);

    ctx.logger.info(`Removed ${count} outdated documents`);
    return { removed: count };
  }
});

// 2. User data deletion
const agent = createAgent({
  handler: async (ctx, input) => {
    // Find all user's vectors
    const userVectors = await ctx.vector.search('user-data', {
      metadata: { userId: input.userId },
      limit: 1000
    });

    // Delete all user's data
    const keys = userVectors.map(v => v.key);
    const deletedCount = await ctx.vector.delete('user-data', ...keys);

    return {
      message: `Deleted ${deletedCount} user records`,
      userId: input.userId
    };
  }
});
```

## Practical Examples

### Building a Simple RAG System

This example demonstrates a complete Retrieval-Augmented Generation (RAG) pattern - searching for relevant context and using it to generate informed responses.

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const ragAgent = createAgent({
  schema: {
    input: z.object({ question: z.string() }),
    output: z.object({
      answer: z.string(),
      sources: z.array(z.object({
        id: z.string(),
        key: z.string(),
        title: z.string().optional(),
        similarity: z.number()
      }))
    })
  },
  handler: async (ctx, input) => {
    try {
      // 1. Search for relevant context (top 5 results)
      const searchResults = await ctx.vector.search('knowledge-base', {
        query: input.question,
        limit: 5,
        similarity: 0.7
      });

      // 2. Handle no results gracefully
      if (searchResults.length === 0) {
        return {
          answer: "I couldn't find relevant information to answer your question.",
          sources: []
        };
      }

      // 3. Assemble context from search results
      const contextTexts = searchResults.map(result =>
        result.metadata?.content ?? result.metadata?.text ?? ''
      );
      const assembledContext = contextTexts.join('\n\n');

      // 4. Generate response using context
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: `Answer the question based on the following context:

Context: ${assembledContext}

Question: ${input.question}

Answer:`
      });

      // 5. Return answer with sources
      return {
        answer: text,
        sources: searchResults.map(r => ({
          id: r.id,
          key: r.key,
          title: r.metadata?.title,
          similarity: r.similarity
        }))
      };

    } catch (error) {
      ctx.logger.error('RAG query failed:', error);
      throw error;
    }
  }
});
```

**Key Points:**
- **Semantic search** finds relevant documents based on meaning, not keywords
- **Similarity threshold** of 0.7 balances relevance with recall
- **Context assembly** combines multiple sources for comprehensive answers
- **Error handling** ensures graceful failures with helpful messages
- **Source attribution** provides transparency about where information came from

<Callout type="info" title="RAG Quality Evaluation">
For production RAG systems, add evaluations to check answer quality, hallucination detection, and faithfulness to sources. See the [Evaluations guide](/Guides/evaluations) for comprehensive RAG quality patterns including:
- **Hallucination Detection** - Verify answers are grounded in retrieved documents
- **RAG Quality Metrics** - Measure contextual relevancy, answer relevancy, and faithfulness
- **Using ctx.state** - Store retrieved documents for eval access

These evaluation patterns help ensure your RAG system produces high-quality, trustworthy responses.
</Callout>

### Semantic Search with Metadata Filtering

This example shows how to combine semantic similarity with metadata filters for precise results - like finding products that match both meaning and business criteria.

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const productSearchAgent = createAgent({
  schema: {
    input: z.object({
      query: z.string(),
      maxPrice: z.number().optional(),
      category: z.string().optional(),
      inStock: z.boolean().optional()
    }),
    output: z.object({
      query: z.string(),
      filters: z.record(z.unknown()),
      resultCount: z.number(),
      products: z.array(z.record(z.unknown()))
    })
  },
  handler: async (ctx, input) => {
    try {
      // Build metadata filters based on criteria
      const metadataFilters: Record<string, unknown> = {};
      if (input.category) metadataFilters.category = input.category;
      if (input.inStock !== undefined) metadataFilters.inStock = input.inStock;

      // Search with semantic similarity + metadata filters
      const searchResults = await ctx.vector.search('products', {
        query: input.query,
        limit: 10,
        similarity: 0.65, // Lower threshold for broader results
        metadata: metadataFilters
      });

      // Post-process: Apply price filter and sort by relevance
      const filteredResults = searchResults
        .filter(result => !input.maxPrice || (result.metadata?.price as number) <= input.maxPrice)
        .map(result => ({
          ...result.metadata,
          similarity: result.similarity
        }))
        .sort((a, b) => (b.similarity as number) - (a.similarity as number));

      return {
        query: input.query,
        filters: {
          maxPrice: input.maxPrice,
          category: input.category,
          inStock: input.inStock
        },
        resultCount: filteredResults.length,
        products: filteredResults.slice(0, 5) // Top 5 results
      };

    } catch (error) {
      ctx.logger.error('Product search failed:', error);
      return {
        query: input.query,
        filters: {},
        resultCount: 0,
        products: []
      };
    }
  }
});
```

**Key Techniques:**
- **Metadata filters** are applied at the vector search level for efficiency
- **Post-processing** handles filters that can't be done at search time (like price ranges)
- **Lower similarity threshold** (0.65) catches more potential matches when using strict filters
- **Type-safe schemas** ensure input validation and output consistency

## Common Pitfalls & Solutions

### Empty Search Results

**Problem**: Your search returns empty results even though relevant data exists.

**Solutions:**
- **Lower the similarity threshold**: Start at 0.5 and increase gradually
- **Check your metadata filters**: They use exact matching, not fuzzy matching
- **Verify document format**: Ensure documents were upserted with text content

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Adaptive threshold example
    let results = await ctx.vector.search('kb', {
      query: input.question,
      similarity: 0.8
    });

    if (results.length === 0) {
      // Try again with lower threshold
      results = await ctx.vector.search('kb', {
        query: input.question,
        similarity: 0.5
      });
    }

    return { results };
  }
});
```

### Duplicate Documents

**Problem**: Same content appears multiple times in search results.

**Solution**: Vector upsert is idempotent when using the same key:
- Always use consistent `key` values for your documents
- Upserting with an existing key updates the vector rather than creating a duplicate
- The same internal vector ID is reused, keeping your storage clean

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // This will update existing doc-1, not create a duplicate
    await ctx.vector.upsert('docs', {
      key: 'doc-1',
      document: 'Updated content',
      metadata: { version: 2 }
    });

    return { success: true };
  }
});
```

### Performance Issues

**Problem**: Vector operations take too long.

**Solutions:**
- **Batch operations**: Upsert 100-500 documents at once, not one by one
- **Limit search results**: Use `limit: 10` instead of retrieving all matches
- **Optimize metadata**: Keep metadata objects small and focused
- **Use getMany()**: Batch retrieval instead of multiple `get()` calls

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Good: Batch upsert
    const documents = input.docs.map(doc => ({
      key: doc.id,
      document: doc.content,
      metadata: { title: doc.title }
    }));
    await ctx.vector.upsert('kb', ...documents);

    // Good: Limited search
    const results = await ctx.vector.search('kb', {
      query: input.query,
      limit: 10
    });

    return { count: documents.length, results };
  }
});
```

### Irrelevant Search Results

**Problem**: Search returns irrelevant or unexpected documents.

**Solutions:**
- **Check similarity scores**: Results with similarity < 0.7 may be poor matches
- **Review metadata filters**: Remember they're AND conditions, not OR
- **Verify embeddings**: Ensure consistent text preprocessing before upserting

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    const results = await ctx.vector.search('kb', {
      query: input.question,
      limit: 10,
      similarity: 0.7 // Minimum quality threshold
    });

    // Filter by additional quality checks
    const qualityResults = results.filter(r => {
      // Only include high-quality matches
      return r.similarity >= 0.75 && r.metadata?.verified === true;
    });

    return { results: qualityResults };
  }
});
```

## Best Practices

### Document Structure

- **Include context in documents**: Store enough context so documents are meaningful when retrieved
- **Use descriptive metadata**: Include relevant metadata for filtering and identification
- **Consistent formatting**: Use consistent document formatting for better embeddings

```typescript
// Good: Rich, contextual documents
await ctx.vector.upsert('docs', {
  key: 'getting-started',
  document: 'Getting Started with Agentuity: This guide walks you through creating your first agent, including setup, configuration, and deployment.',
  metadata: {
    title: 'Getting Started Guide',
    category: 'documentation',
    tags: ['beginner', 'setup', 'tutorial'],
    lastUpdated: Date.now()
  }
});

// Avoid: Minimal context
await ctx.vector.upsert('docs', {
  key: 'doc1',
  document: 'Setup guide',
  metadata: { type: 'doc' }
});
```

### Search Optimization

- **Adjust similarity thresholds**: Start with 0.7 and adjust based on result quality
- **Use metadata filtering**: Combine semantic search with metadata filters for precise results
- **Limit result sets**: Use appropriate limits to balance performance and relevance

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Optimized search with filters
    const results = await ctx.vector.search('products', {
      query: input.searchTerm,
      limit: 20, // Reasonable limit
      similarity: 0.7, // Quality threshold
      metadata: {
        active: true, // Only active products
        category: input.category
      }
    });

    return { results };
  }
});
```

### Performance Considerations

- **Batch upsert operations**: Use bulk upsert instead of individual calls
- **Monitor storage usage**: Track vector storage size in the Cloud Console
- **Consider document chunking**: Break large documents into smaller, focused chunks
- **Use type parameters**: Leverage TypeScript generics for type-safe metadata access

```typescript
// Good: Batch operations
const agent = createAgent({
  handler: async (ctx, input) => {
    // Process documents in batches
    const batchSize = 100;
    const documents = input.documents;

    for (let i = 0; i < documents.length; i += batchSize) {
      const batch = documents.slice(i, i + batchSize);
      const vectors = batch.map(doc => ({
        key: doc.id,
        document: doc.content,
        metadata: { title: doc.title, category: doc.category }
      }));

      await ctx.vector.upsert('kb', ...vectors);
    }

    return { processed: documents.length };
  }
});
```

### Type Safety

Use TypeScript interfaces for consistent, type-safe metadata:

```typescript
interface DocumentMetadata {
  title: string;
  category: 'guide' | 'api' | 'tutorial';
  tags: string[];
  author: string;
  lastUpdated: number;
}

const agent = createAgent({
  handler: async (ctx, input) => {
    // Type-safe upsert
    await ctx.vector.upsert<DocumentMetadata>('docs', {
      key: 'example',
      document: 'Content here',
      metadata: {
        title: 'Example',
        category: 'guide',
        tags: ['intro'],
        author: 'system',
        lastUpdated: Date.now()
      }
    });

    // Type-safe search
    const results = await ctx.vector.search<DocumentMetadata>('docs', {
      query: input.question,
      metadata: { category: 'guide' }
    });

    // TypeScript knows the metadata structure
    const titles = results.map(r => r.metadata?.title);

    return { titles };
  }
});
```

## Integration with Agent Memory

Vector storage serves as long-term memory for agents, enabling them to:

- Remember past conversations and context across sessions
- Access organizational knowledge bases
- Retrieve relevant examples for few-shot learning
- Build and maintain agent-specific knowledge repositories

For more information on memory patterns, see the [Key-Value Storage guide](/Guides/key-value-storage) for short-term memory or explore [Agent Communication](/Guides/agent-communication) for sharing knowledge between agents.

## Storage Types Overview

TODO: Add video for v1 storage overview

## Next Steps

- [Evaluations](/Guides/evaluations): Add quality checks for RAG systems (hallucination detection, faithfulness, relevancy)
- [Key-Value Storage](/Guides/key-value-storage): Fast lookups for simple data
- [Sessions and Threads](/Guides/sessions-threads): Manage conversation state
- [API Reference](/SDK/api-reference): Complete vector storage API documentation
