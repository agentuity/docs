---
title: Object Storage
description: Durable file storage for documents, images, videos, and binary content
---

# Object Storage

Object storage provides durable file storage for agents. Use it for documents, images, videos, and any binary content.

## When to Use Object Storage

Object storage is your solution for storing files, media, and large unstructured data that agents need to manage. Use it for documents, images, videos, backups, and any binary content.

Choose the right storage for your use case:

- **Object Storage**: Files, media, documents, backups
- **[Key-Value Storage](/Guides/key-value-storage)**: Fast lookups, session data, configuration
- **[Vector Storage](/Guides/vector-storage)**: Semantic search, embeddings, AI context

**Note:** For temporary files that only need to exist during agent execution, use `ctx.state` instead of Object Storage. See [Sessions and Threads](/Guides/sessions-threads) for built-in state management.

## Common Use Cases

- **File Management**: Store user uploads, generated documents, and processed files
- **Media Storage**: Keep images, videos, audio files, and other media assets
- **Document Processing**: Store PDFs, spreadsheets, and documents for agent processing
- **Backup and Archive**: Maintain backups of agent-generated content or historical data
- **Static Asset Serving**: Host files that can be accessed via public URLs
- **Data Export**: Store generated reports, exports, and downloadable content

## Creating Object Storage

You can create object storage buckets either through the Cloud Console or programmatically in your agent code.

### Via Cloud Console

Navigate to **Services > Object Store** and click **Create Storage**. Choose a descriptive bucket name that reflects its purpose (e.g., `user-uploads`, `processed-documents`, `media-assets`).

<ThemeImage baseName="object-store" alt="Object Storage Overview" />

### Via SDK

Buckets are automatically created when you first access them:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // TODO: Verify file upload input handling pattern
    const imageData = new Uint8Array(input.fileData);

    // Bucket 'user-uploads' is auto-created if it doesn't exist
    await ctx.objectstore.put('user-uploads', 'profile-123.jpg', imageData, {
      contentType: 'image/jpeg'
    });

    return { message: 'Image uploaded successfully' };
  }
});
```

## Working with Object Storage

The object storage API provides four core operations: `get`, `put`, `delete`, and `createPublicURL`. All operations are asynchronous and support various content types.

### Storing Objects

Store files with optional metadata and HTTP headers:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Store with content type
    await ctx.objectstore.put('documents', 'report.pdf', pdfData, {
      contentType: 'application/pdf'
    });

    // Store with full metadata
    await ctx.objectstore.put('uploads', 'document.pdf', pdfData, {
      contentType: 'application/pdf',
      contentDisposition: 'attachment; filename="report.pdf"',
      cacheControl: 'max-age=3600',
      metadata: {
        'uploaded-by': input.userId,
        'processed': 'false'
      }
    });

    // Store text file
    const textData = new TextEncoder().encode(logContent);
    await ctx.objectstore.put('logs', 'agent.log', textData, {
      contentType: 'text/plain',
      contentEncoding: 'utf-8'
    });

    return { success: true };
  }
});
```

**Put Parameters:**
- `contentType` (optional): MIME type of the file (default: `application/octet-stream`)
- `contentDisposition` (optional): Controls how browsers handle the file (download vs display)
- `cacheControl` (optional): Browser caching behavior
- `contentEncoding` (optional): Content encoding (e.g., `gzip`, `utf-8`)
- `contentLanguage` (optional): Content language (e.g., `en-US`)
- `metadata` (optional): Custom metadata as key-value pairs

**Data Types:**
The `put` method accepts:
- `Uint8Array` - Binary data
- `ArrayBuffer` - Raw binary buffer
- `ReadableStream` - Streaming data

### Retrieving Objects

Retrieve stored objects with type-safe null checking:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Get an object
    const result = await ctx.objectstore.get('documents', 'report.pdf');

    if (result.exists) {
      // Access binary data (Uint8Array)
      const pdfData = result.data;
      const contentType = result.contentType;

      ctx.logger.info(`PDF size: ${pdfData.byteLength} bytes`);
      ctx.logger.info(`Content type: ${contentType}`);
    } else {
      ctx.logger.info('Object not found');
    }

    // Convert to text if needed
    const textResult = await c.objectstore.get('logs', 'agent.log');
    if (textResult.exists) {
      const logContent = new TextDecoder().decode(textResult.data);
      ctx.logger.info('Log content:', logContent);
    }

    return { found: result.exists };
  }
});
```

**Get Return Value:**
Returns a discriminated union for type-safe null checking:
- `{ exists: true, data: Uint8Array, contentType: string }` - Object found
- `{ exists: false }` - Object not found

**Converting Data:**
- Binary data is returned as `Uint8Array`
- Use `TextDecoder` to convert to string: `new TextDecoder().decode(data)`
- Use `TextEncoder` to convert string to Uint8Array: `new TextEncoder().encode(text)`

### Generating Public URLs

Create time-limited public URLs for direct access to objects:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Create a 1-hour public URL
    const publicUrl = await ctx.objectstore.createPublicURL(
      'documents',
      'report.pdf',
      { expiresDuration: 3600000 } // 1 hour in milliseconds
    );

    ctx.logger.info(`Download link: ${publicUrl}`);

    // Create with default expiration (1 hour)
    const imageUrl = await ctx.objectstore.createPublicURL('images', 'photo.jpg');

    // Create short-lived URL (minimum 1 minute)
    const tempUrl = await ctx.objectstore.createPublicURL(
      'temp-files',
      'preview.png',
      { expiresDuration: 60000 }
    );

    return { publicUrl, imageUrl, tempUrl };
  }
});
```

**CreatePublicURL Parameters:**
- `expiresDuration` (optional): Duration in milliseconds (default: 1 hour, minimum: 1 minute)

**Return Value:**
- Returns a string containing the signed public URL
- Throws an error if the object doesn't exist

### Deleting Objects

Remove objects when they're no longer needed:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Delete an object
    const wasDeleted = await c.objectstore.delete('temp-files', 'processing.tmp');

    if (wasDeleted) {
      ctx.logger.info('Temporary file cleaned up');
    } else {
      ctx.logger.info('File was already deleted');
    }

    return { deleted: wasDeleted };
  }
});
```

**Delete Return Value:**
- Returns `true` if the object was deleted
- Returns `false` if the object didn't exist

## Best Practices

### Bucket Organization

Structure your buckets by purpose and access patterns:
- `user-uploads`: User-submitted content
- `processed-output`: Agent-generated results
- `public-assets`: Files meant for public access
- `temp-storage`: Short-lived processing files

### Key Naming Conventions

Use hierarchical paths for better organization:
- `users/{userId}/profile.jpg`
- `documents/{year}/{month}/report-{id}.pdf`
- `exports/{timestamp}/data.csv`

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Organize by user
    const key = `users/${input.userId}/profile.jpg`;
    await ctx.objectstore.put('uploads', key, imageData, {
      contentType: 'image/jpeg'
    });

    // Organize by date
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const documentKey = `documents/${year}/${month}/report-${input.reportId}.pdf`;

    await ctx.objectstore.put('reports', documentKey, pdfData, {
      contentType: 'application/pdf'
    });

    return { success: true };
  }
});
```

### Content Type Management

Always set appropriate content types for better browser handling:

```typescript
import { createAgent } from '@agentuity/runtime';

const contentTypes: Record<string, string> = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.pdf': 'application/pdf',
  '.json': 'application/json',
  '.csv': 'text/csv',
  '.txt': 'text/plain',
  '.html': 'text/html',
  '.xml': 'application/xml'
};

const agent = createAgent({
  handler: async (ctx, input) => {
    const filename = input.filename;
    const extension = filename.substring(filename.lastIndexOf('.'));
    const contentType = contentTypes[extension] || 'application/octet-stream';

    await ctx.objectstore.put('uploads', filename, input.fileData, {
      contentType
    });

    return { success: true, contentType };
  }
});
```

### Public URL Security

Use appropriate expiration times for public URLs:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    let expiresDuration: number;

    switch (input.accessType) {
      case 'temporary':
        // Temporary downloads: 5-15 minutes
        expiresDuration = 15 * 60 * 1000; // 15 minutes
        break;
      case 'shared':
        // Shared documents: 1-24 hours
        expiresDuration = 24 * 60 * 60 * 1000; // 24 hours
        break;
      case 'quick':
        // Quick preview: 1-5 minutes
        expiresDuration = 5 * 60 * 1000; // 5 minutes
        break;
      default:
        // Default: 1 hour
        expiresDuration = 60 * 60 * 1000;
    }

    const url = await c.objectstore.createPublicURL(
      'documents',
      input.documentKey,
      { expiresDuration }
    );

    return { url, expiresIn: expiresDuration };
  }
});
```

**Important:** Never create permanent public URLs for sensitive data. Always use time-limited signed URLs.

### Error Handling

Handle storage operations gracefully:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    try {
      // Attempt to store file
      await ctx.objectstore.put('uploads', input.key, input.data, {
        contentType: input.contentType
      });

      // Generate temporary URL for response
      const url = await c.objectstore.createPublicURL(
        'uploads',
        input.key,
        { expiresDuration: 900000 } // 15 minutes
      );

      return {
        success: true,
        url
      };
    } catch (error) {
      ctx.logger.error('Storage error:', error);

      return {
        success: false,
        error: 'Failed to process file'
      };
    }
  }
});
```

## File Processing Patterns

### Upload Handler

Create a robust file upload handler:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

// TODO: Verify the correct pattern for handling file uploads in v1
// This example assumes file data comes through the input parameter
const uploadAgent = createAgent({
  schema: {
    input: z.object({
      filename: z.string(),
      contentType: z.string(),
      fileData: z.instanceof(Uint8Array)
    }),
    output: z.object({
      message: z.string(),
      key: z.string(),
      url: z.string()
    })
  },
  handler: async (ctx, input) => {
    // Generate unique key
    const timestamp = Date.now();
    const key = `uploads/${timestamp}-${input.filename}`;

    // Store the uploaded file
    await ctx.objectstore.put('user-files', key, input.fileData, {
      contentType: input.contentType,
      metadata: {
        'original-name': input.filename,
        'upload-time': new Date().toISOString()
      }
    });

    // Generate access URL (1 hour expiration)
    const url = await c.objectstore.createPublicURL(
      'user-files',
      key,
      { expiresDuration: 3600000 }
    );

    return {
      message: 'File uploaded successfully',
      key,
      url
    };
  }
});
```

### Document Processing Pipeline

Process and store documents with metadata tracking:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const documentProcessorAgent = createAgent({
  schema: {
    input: z.object({
      documentId: z.string(),
      rawDocument: z.instanceof(Uint8Array)
    })
  },
  handler: async (ctx, input) => {
    // Store raw document
    const rawKey = `documents/raw/${input.documentId}.pdf`;
    await ctx.objectstore.put('documents', rawKey, input.rawDocument, {
      contentType: 'application/pdf',
      metadata: {
        'status': 'raw',
        'document-id': input.documentId,
        'uploaded-at': new Date().toISOString()
      }
    });

    // Process document (example: convert to text)
    const processedText = await processDocument(input.rawDocument);
    const textData = new TextEncoder().encode(processedText);

    // Store processed version
    const processedKey = `documents/processed/${input.documentId}.txt`;
    await ctx.objectstore.put('documents', processedKey, textData, {
      contentType: 'text/plain',
      metadata: {
        'status': 'processed',
        'document-id': input.documentId,
        'processed-at': new Date().toISOString()
      }
    });

    // Generate download URLs
    const rawUrl = await c.objectstore.createPublicURL(
      'documents',
      rawKey,
      { expiresDuration: 3600000 }
    );

    const processedUrl = await c.objectstore.createPublicURL(
      'documents',
      processedKey,
      { expiresDuration: 3600000 }
    );

    return {
      documentId: input.documentId,
      rawUrl,
      processedUrl
    };
  }
});

// Helper function (example)
async function processDocument(pdfData: Uint8Array): Promise<string> {
  // Implement document processing logic
  return 'Extracted text from document';
}
```

## Monitoring Usage

Track your object storage usage through the Cloud Console:

1. Navigate to **Services > Object Store**
2. View storage size and object count for each bucket
3. Monitor provider information and creation dates
4. Track storage operations through agent telemetry

For structured data with complex queries, consider using object storage to store data exports while maintaining indexes in key-value or vector storage.

## Storage Types Overview

TODO: Add video for v1 storage overview

## Next Steps

- [Key-Value Storage](/Guides/key-value-storage): Fast lookups for simple data
- [Vector Storage](/Guides/vector-storage): Semantic search and embeddings
- [Sessions and Threads](/Guides/sessions-threads): Manage conversation state
- [API Reference](/SDK/api-reference): Complete storage API documentation
