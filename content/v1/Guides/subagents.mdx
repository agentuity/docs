---
title: Subagents
description: Organize related agents into parent-child hierarchies
---

Subagents organize related agents into parent-child hierarchies with one level of nesting. Use subagents to group related functionality under a common parent, share validation logic, and create hierarchical API structures. Each subagent maintains its own handler and routes while accessing the parent agent via `c.parent`.

For routing patterns and middleware configuration, see the [Routing & Triggers Guide](/Guides/routing-triggers). For general agent patterns, see [Core Concepts](/Introduction/core-concepts).

## Understanding Subagents

Subagents are regular agents nested within a parent agent's directory. The file structure determines the relationship: agents in subdirectories become subagents automatically. This enables logical grouping of related operations while maintaining clear separation of concerns.

**File Structure:**
```
team/                   # Parent agent
├── agent.ts            # Parent logic
├── route.ts            # Parent routes
├── members/            # Subagent: member operations
│   ├── agent.ts
│   └── route.ts
└── tasks/              # Subagent: task operations
    ├── agent.ts
    └── route.ts
```

**Resulting Structure:**
- Parent agent name: `team`
- Subagent names: `team.members`, `team.tasks`
- Parent routes: `/agent/team`
- Subagent routes: `/agent/team/members`, `/agent/team/tasks`

### When to Use Subagents

Use subagents when you have:

- **Related operations in the same domain** - User profile, settings, and notifications belong together
- **Shared validation or authentication** - Parent validates permissions once for all subagents
- **Natural parent-child relationship** - Product catalog contains inventory, pricing, and reviews
- **Hierarchical API structure** - Routes reflect domain hierarchy (`/team/members`, `/team/tasks`)

### When to Use Separate Agents

Use separate agents when you have:

- **Independent domains** - User management and payment processing are unrelated
- **Different ownership** - Multiple teams maintain different parts of the system
- **No shared context** - Agents don't need common validation or state
- **Flexible composition** - Agent may be called from many different contexts

### Comparison Table

| Feature | Subagents | Separate Agents |
|---------|-----------|-----------------|
| **File structure** | Nested directories | Flat structure |
| **Access pattern** | `c.agent.parent.child.run()` | `c.agent.agentName.run()` |
| **Routes** | Inherit parent path | Independent paths |
| **Shared logic** | Parent provides context | Shared via middleware |
| **Parent access** | `c.parent` available | N/A |
| **Coupling** | Moderate (shares parent) | Low (independent) |
| **Use case** | Related operations | Independent operations |

## Creating Parent Agents

Parent agents are regular agents with subdirectories containing subagents. The parent provides coordination logic, shared validation, and high-level operations.

```typescript
// team/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      action: z.enum(['info', 'stats'])
    }),
    output: z.object({
      message: z.string(),
      memberCount: z.number().optional(),
      taskCount: z.number().optional()
    })
  },
  handler: async (c, input) => {
    if (input.action === 'info') {
      return { message: 'Team management system' };
    }

    // Coordinate between subagents
    const [members, tasks] = await Promise.all([
      c.agent.team.members.run({ action: 'count' }),
      c.agent.team.tasks.run({ action: 'count' })
    ]);

    return {
      message: 'Team statistics',
      memberCount: members.count,
      taskCount: tasks.count
    };
  }
});

export default agent;

// Routes: team/route.ts - standard routing applies
// GET /agent/team → calls agent with default input
// POST /agent/team → calls agent with request body
```

**Key Points:**
- Parent is a standard agent created with `createAgent()`
- Can call subagents via `c.agent.parent.child.run()`
- Provides high-level coordination between subagents
- Routes follow standard patterns (see [Routing & Triggers Guide](/Guides/routing-triggers))

## Creating Subagents

Subagents are created by placing agent.ts and route.ts files in a subdirectory of the parent agent. The directory structure is automatically detected during bundling.

**File Structure Requirements:**
- **Location**: Must be in a subdirectory of the parent agent
- **Files**: Both `agent.ts` and `route.ts` required
- **Depth**: One level only (no grandchildren)
- **Detection**: Automatically detected by the bundler

**Naming Convention:**
- Agent name: `parent.child` (e.g., `team.members`)
- Property access: `c.agent.team.members` (nested object)
- Current agent name: `c.agentName` returns `"team.members"`

### Basic Subagent

Create a subagent for member management:

```typescript
// team/members/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      action: z.enum(['list', 'add', 'remove', 'count']),
      name: z.string().optional()
    }),
    output: z.object({
      members: z.array(z.string()),
      count: z.number().optional()
    })
  },
  handler: async (c, input) => {
    const result = await c.kv.get<string[]>('team-data', 'members');
    let members: string[] = result.exists && result.data ? result.data : [];

    if (input.action === 'add' && input.name) {
      members.push(input.name);
      await c.kv.set('team-data', 'members', members);
    } else if (input.action === 'remove' && input.name) {
      members = members.filter(m => m !== input.name);
      await c.kv.set('team-data', 'members', members);
    } else if (input.action === 'count') {
      return { members, count: members.length };
    }

    return { members };
  }
});

export default agent;
```

**Key Points:**
- Same `createAgent()` syntax as regular agents
- Agent name automatically becomes `team.members`
- Access via `c.agentName` returns `"team.members"`
- Full schema validation and type inference

<Callout type="warning">
**Nesting Depth:** Only one level of nesting is supported. Grandchildren (`team/members/admins/agent.ts`) are not supported. If you need deeper organization, create separate subagents at the same level (e.g., `team/members/` and `team/memberAdmins/`).
</Callout>

### Subagent Routes

Routes inherit the parent's path and follow standard patterns:

```typescript
// team/members/route.ts
import { createRouter } from '@agentuity/runtime';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';

const router = createRouter();

// GET /agent/team/members
router.get('/', async (c) => {
  const result = await c.agent.team.members.run({ action: 'list' });
  return c.json(result);
});

// POST /agent/team/members/add
router.post('/add', zValidator('json', z.object({ name: z.string() })), async (c) => {
  const data = c.req.valid('json');
  const result = await c.agent.team.members.run({ action: 'add', name: data.name });
  return c.json(result);
});

export default router;
```

**Key Points:**
- Routes inherit parent path: `/agent/team/members`
- Access subagent via `c.agent.team.members.run()`
- Standard Hono routing patterns apply
- See [Routing & Triggers Guide](/Guides/routing-triggers) for complete patterns

## Accessing Subagents

Subagents are accessed via nested properties on `c.agent` or `c.agent`. Type inference provides autocomplete and compile-time validation when schemas are defined.

```typescript
// From routes or other agents
const router = createRouter();

router.get('/summary', async (c) => {
  // Parallel execution
  const [members, tasks] = await Promise.all([
    c.agent.team.members.run({ action: 'list' }),
    c.agent.team.tasks.run({ action: 'list' })
  ]);

  return c.json({
    memberCount: members.members.length,
    taskCount: tasks.tasks.length
  });
});

// From another agent
const agent = createAgent({
  handler: async (c, input) => {
    const members = await c.agent.team.members.run({ action: 'count' });
    return { count: members.count };
  }
});
```

**Key Points:**
- Nested property access: `c.agent.parent.child.run()`
- Works from routes and other agents
- Supports parallel execution with `Promise.all()`
- Type-safe when both agents have schemas

**Accessing Sibling Subagents:**

From within a subagent, access siblings via the full path (not via `ctx.sibling`):

```typescript
// From team/members/agent.ts
const tasksData = await c.agent.team.tasks.run({ action: 'list' });  // ✓
```

<Callout type="info">
**Type Safety:** When agents define schemas with Zod/Valibot/ArkType, TypeScript provides full type inference for inputs and outputs, including autocomplete and compile-time validation.
</Callout>

## Parent Context Access

Subagents access their parent agent via `c.parent`. This enables validation, shared configuration, and coordination patterns while maintaining separation of concerns.

### Basic Usage

The `c.parent` property is available only in subagent handlers:

```typescript
// team/members/agent.ts
const agent = createAgent({
  handler: async (c, input) => {
    let parentInfo: string | undefined;

    // Check if parent is available
    if (c.parent) {
      const parentData = await c.parent.run({ action: 'info' });
      parentInfo = parentData.message;

      c.logger.info('Retrieved parent context', {
        parentMessage: parentInfo,
        currentAgent: c.agentName  // "team.members"
      });
    }

    return { result: 'Processed', parentInfo };
  }
});
```

**Key Points:**
- `c.parent` available only in subagents (undefined in parent)
- Call parent via `c.parent.run(input)`
- Parent execution is synchronous (blocks subagent)
- Always check `if (c.parent)` for type safety

### Shared Validation Pattern

Use parent for centralized validation logic:

```typescript
// team/agent.ts - Parent validates permissions
const teamAgent = createAgent({
  schema: {
    input: z.object({
      userId: z.string(),
      teamId: z.string(),
      requiredRole: z.enum(['member', 'admin', 'owner']).optional()
    }),
    output: z.object({
      authorized: z.boolean(),
      userRole: z.string()
    })
  },
  handler: async (c, input) => {
    const result = await c.kv.get('team-memberships', `${input.teamId}:${input.userId}`);

    if (!result.exists) {
      throw new Error('User is not a member of this team');
    }

    const membership = result.data as { role: string };

    // Check role if required
    if (input.requiredRole) {
      const roleHierarchy = { member: 1, admin: 2, owner: 3 };
      const userLevel = roleHierarchy[membership.role as keyof typeof roleHierarchy] || 0;
      const requiredLevel = roleHierarchy[input.requiredRole];

      if (userLevel < requiredLevel) {
        throw new Error(`Requires ${input.requiredRole} role`);
      }
    }

    return { authorized: true, userRole: membership.role };
  }
});

// team/members/agent.ts - Uses parent validation
const membersAgent = createAgent({
  handler: async (c, input) => {
    // Validate with admin role requirement
    if (c.parent) {
      await c.parent.run({
        userId: input.userId,
        teamId: input.teamId,
        requiredRole: 'admin'
      });
    }

    // Admin-only operation
    const members = await c.kv.get<string[]>('team-members', input.teamId);
    return { members: members.data || [] };
  }
});
```

**Key Points:**
- Parent provides centralized validation
- Subagents call parent before executing
- Validation errors propagate to caller
- Reduces duplication across subagents

### When to Use Parent Access

Use `c.parent` for:
- **Validation** - Check permissions before executing subagent logic
- **Shared configuration** - Retrieve settings managed by parent
- **Logging context** - Include parent information in logs

Avoid `c.parent` for:
- **Core business logic** - Subagent should be mostly independent
- **Data operations** - Use storage directly, not via parent
- **Frequent calls** - Each call is synchronous and blocks execution
- **Circular calls** - Avoid parent calling child that calls parent back (creates infinite loop)

## Route Organization

Routes in subagent hierarchies follow the parent path structure. Middleware applied to parent routes cascades to all subagent routes.

### Path Inheritance

Subagent routes automatically inherit the parent path:

```
Parent:   GET /agent/team
          POST /agent/team

Subagent: GET /agent/team/members
          POST /agent/team/members/add
          POST /agent/team/members/remove
```

### Middleware Cascade

Middleware applied to parent routes cascades to all subagents:

```typescript
// team/route.ts - Parent with authentication
const router = createRouter();

router.use('/*', async (c, next) => {
  const token = c.req.header('Authorization');
  if (!token) return c.json({ error: 'Unauthorized' }, 401);

  c.set('userId', await getUserIdFromToken(token));
  await next();
});

// All subagent routes inherit this auth middleware
```

**Key Points:**
- Parent middleware automatically applies to all subagent routes
- Subagents can add additional middleware
- Middleware executes in order: parent first, then subagent

<Callout type="info">
For complete routing documentation including HTTP methods, middleware patterns, and specialized routes (WebSocket, SSE, cron), see the [Routing & Triggers Guide](/Guides/routing-triggers).
</Callout>

## Common Patterns

### User Account Management

Organize user-related operations under a parent user agent:

```
user/
├── agent.ts          # Core user operations
├── route.ts
├── profile/          # Profile management
│   ├── agent.ts
│   └── route.ts
├── settings/         # User settings
│   ├── agent.ts
│   └── route.ts
└── notifications/    # Notification preferences
    ├── agent.ts
    └── route.ts
```

**Parent agent handles core user logic:**

```typescript
// user/agent.ts
const userAgent = createAgent({
  schema: {
    input: z.object({
      userId: z.string(),
      action: z.enum(['get', 'validate'])
    }),
    output: z.object({
      user: z.object({
        id: z.string(),
        email: z.string(),
        status: z.enum(['active', 'suspended'])
      }).optional(),
      valid: z.boolean().optional()
    })
  },
  handler: async (c, input) => {
    const result = await c.kv.get('users', input.userId);
    if (!result.exists) throw new Error('User not found');

    const user = result.data;
    if (input.action === 'validate') {
      return { valid: user.status === 'active' };
    }

    return { user };
  }
});
```

**Subagent manages profile data:**

```typescript
// user/profile/agent.ts
const profileAgent = createAgent({
  schema: {
    input: z.object({
      userId: z.string(),
      action: z.enum(['get', 'update']),
      profile: z.object({
        displayName: z.string().optional(),
        bio: z.string().optional(),
        avatar: z.string().url().optional()
      }).optional()
    }),
    output: z.object({
      profile: z.object({
        displayName: z.string(),
        bio: z.string(),
        avatar: z.string().url().optional()
      })
    })
  },
  handler: async (c, input) => {
    // Validate user via parent
    if (c.parent) {
      const validation = await c.parent.run({
        userId: input.userId,
        action: 'validate'
      });
      if (!validation.valid) {
        throw new Error('User account is not active');
      }
    }

    const result = await c.kv.get(`profile-${input.userId}`, 'user-profiles');
    let profile = result.exists ? result.data : {
      displayName: 'New User',
      bio: ''
    };

    if (input.action === 'update' && input.profile) {
      profile = { ...profile, ...input.profile };
      await c.kv.set('user-profiles', `profile-${input.userId}`, profile);
    }

    return { profile };
  }
});
```

**Key Points:**
- Parent validates user status
- Subagents manage specific user data
- Clear separation: core vs. profile vs. settings vs. notifications
- Each subagent can be tested independently

### Other Domain Patterns

**E-commerce Product Management:**
```
product/
├── inventory/   # Stock management
├── pricing/     # Price operations
└── reviews/     # Customer reviews
```
- Parent: Product validation and catalog management
- Subagents: Domain-specific operations (inventory, pricing, reviews)
- Use case: E-commerce platforms requiring organized product operations

**Content Management:**
```
content/
├── drafts/      # Draft management
├── publishing/  # Publish workflow
└── media/       # Media attachments
```
- Parent: Content workflow coordination
- Subagents: Stage-specific operations (drafting, publishing, media)
- Use case: CMS platforms with multi-step content workflows

For complete working examples of these patterns, see the [Examples](/Examples) page.

## Best Practices

### Design Guidelines

**Parent Coordinates, Children Execute:**
```typescript
// Good: Parent coordinates
const teamAgent = createAgent({
  handler: async (c, input) => {
    const [members, tasks] = await Promise.all([
      c.agent.team.members.run({ action: 'count' }),
      c.agent.team.tasks.run({ action: 'count' })
    ]);
    return { memberCount: members.count, taskCount: tasks.count };
  }
});

// Bad: Parent implements domain logic
const teamAgent = createAgent({
  handler: async (c, input) => {
    const members = await c.kv.get('members', 'list');
    return { members: members.data.length }; // Should delegate to subagent
  }
});
```

**Keep Subagents Independent:**
- Minimize dependencies on parent
- Use parent for validation, not core logic
- Each subagent should have clear responsibility

**Limit Depth to One Level:**
```typescript
// Supported
team/members/agent.ts

// Not supported
team/members/admins/agent.ts  // Too deep

// Alternative
team/members/agent.ts
team/memberAdmins/agent.ts    // Separate subagent
```

### Performance

**Cache parent context if calling multiple times:**
```typescript
const membersAgent = createAgent({
  handler: async (c, input) => {
    const parentData = c.parent ? await c.parent.run({ teamId: input.teamId }) : null;
    // Use parentData multiple times without re-calling
    return { processed: true };
  }
});
```

**Execute independent subagent calls in parallel:**
```typescript
// Good
const [members, tasks] = await Promise.all([
  c.agent.team.members.run({ action: 'count' }),
  c.agent.team.tasks.run({ action: 'count' })
]);

// Bad - slower when independent
const members = await c.agent.team.members.run({ action: 'count' });
const tasks = await c.agent.team.tasks.run({ action: 'count' });
```

### Testing

**Test parent and children independently:**

```typescript
// Test parent with mocked subagents
describe('Team Agent', () => {
  it('should coordinate subagents', async () => {
    const mockCtx = {
      agent: {
        team: {
          members: { run: jest.fn().mockResolvedValue({ count: 5 }) },
          tasks: { run: jest.fn().mockResolvedValue({ count: 10 }) }
        }
      }
    };
    const result = await teamAgent.handler(mockCtx, { action: 'stats' });
    expect(result.memberCount).toBe(5);
  });
});

// Test subagent with mocked parent
describe('Members Subagent', () => {
  it('should validate via parent', async () => {
    const mockCtx = {
      parent: { run: jest.fn().mockResolvedValue({ authorized: true }) },
      kv: { get: jest.fn(), set: jest.fn() }
    };
    await membersAgent.handler(mockCtx, { action: 'add', name: 'Alice' });
    expect(mockCtx.parent.run).toHaveBeenCalled();
  });
});
```

### Error Handling

**Let validation errors propagate:**
```typescript
const membersAgent = createAgent({
  handler: async (c, input) => {
    if (c.parent) {
      await c.parent.run({ userId: input.userId, teamId: input.teamId });
      // Parent throws on validation failure - error propagates to caller
    }
    return { members: [] };
  }
});
```

**Graceful degradation for optional parent calls:**
```typescript
const membersAgent = createAgent({
  handler: async (c, input) => {
    if (c.parent) {
      try {
        await c.parent.run({ userId: input.userId });
      } catch (error) {
        c.logger.warn('Parent validation unavailable', { error });
        // Continue with degraded functionality
      }
    }
    return { members: [] };
  }
});
```

## React Integration

The SDK generates type-safe React hooks for accessing subagents:

```typescript
// Generated types
export type AgentClient = {
  team: {
    run: (input: TeamInput) => Promise<TeamOutput>;
    members: {
      run: (input: MembersInput) => Promise<MembersOutput>;
    };
  };
};

// Usage in React components
import { useAgent } from '@/lib/agentuity/client/react';

export function TeamDashboard() {
  const loadData = async () => {
    // Nested property access with full type safety
    const teamInfo = await useAgent.team.run({ action: 'stats' });
    const members = await useAgent.team.members.run({ action: 'list' });

    // TypeScript knows the exact types
    console.log(members.members.length);
  };
}
```

**Key Points:**
- Nested property access: `useAgent.parent.child.run()`
- Full TypeScript inference
- Same patterns as backend usage

## Next Steps

**Explore Related Guides:**
- [Routing](/Guides/routing): Complete routing patterns and middleware
- [Schema Validation](/Guides/schema-validation): Type-safe schemas with Zod/Valibot/ArkType
- [Events](/Guides/events): Monitor agent execution with lifecycle hooks
- [Sessions & Threads](/Guides/sessions-threads): Stateful context management

**API Reference:**
- [AgentContext](/api-reference#agentcontext): Complete context API including `c.parent`
- [createAgent](/api-reference#createagent): Agent creation and configuration
- [createRouter](/api-reference#createrouter): Route definition and middleware

**Examples:**
- [Examples](/Examples): Additional patterns and complete working examples
