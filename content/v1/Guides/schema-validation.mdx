---
title: Schema Validation
description: Type-safe input and output validation for agents
---

Schema validation provides runtime type safety and automatic validation for your agents. By defining schemas, you ensure data integrity, get full TypeScript autocomplete, and catch errors before they reach production.

## Why Use Schema Validation

**Runtime Safety:**
- Validates input before your handler runs
- Validates output before returning to callers
- Prevents invalid data from causing runtime errors

**Type Safety:**
- Full TypeScript autocomplete in your IDE
- Compile-time type checking
- No need to manually define TypeScript interfaces

**Documentation:**
- Schemas serve as clear documentation of expected inputs and outputs
- Self-documenting API contracts

## StandardSchema

The SDK uses the StandardSchemaV1 interface, which allows different validation libraries to work seamlessly together.

### Supported Libraries

**Zod** - Most popular, and most common in Agentuity examples:
```typescript
import { z } from 'zod';
```

**Valibot** - Lightweight alternative with similar API:
```typescript
import * as v from 'valibot';
```

**ArkType** - TypeScript-first validation:
```typescript
import { type } from 'arktype';
```

<Callout type="info">
Any library implementing StandardSchemaV1 will work with the SDK.
</Callout>

### Why StandardSchema?

StandardSchemaV1 is a common interface that provides:
- **Library independence** - Not locked into a single validation library
- **Flexibility** - Use the library that best fits your needs
- **Future-proof** - New libraries work automatically if they implement the standard

## Defining Schemas

Schemas are defined in the `schema` property of `createAgent()`.

### Input Schemas

Input schemas validate data passed to your agent:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      email: z.string().email(),
      age: z.number().min(0).max(120),
      preferences: z.object({
        newsletter: z.boolean(),
        notifications: z.boolean(),
      }).optional(),
    }),
  },
  handler: async (ctx, input) => {
    // input is validated before this runs
    // TypeScript knows the exact shape of input
    ctx.logger.info(`User email: ${input.email}`);
    return { success: true };
  },
});
```

### Output Schemas

Output schemas validate data returned from your agent:

```typescript
const agent = createAgent({
  schema: {
    output: z.object({
      userId: z.string().uuid(),
      created: z.date(),
      status: z.enum(['active', 'pending']),
    }),
  },
  handler: async (ctx, input) => {
    return {
      userId: crypto.randomUUID(),
      created: new Date(),
      status: 'active'
    };
    // Output is validated before returning to caller
  },
});
```

### Combined Input and Output

Define both input and output schemas for complete validation:

```typescript
const agent = createAgent({
  schema: {
    input: z.object({
      query: z.string(),
      limit: z.number().default(10),
    }),
    output: z.object({
      results: z.array(z.string()),
      total: z.number(),
    }),
  },
  handler: async (ctx, input) => {
    // Both input and output are validated
    return {
      results: ['item1', 'item2'],
      total: 2,
    };
  },
});
```

### Optional Schemas

Schemas are optional. If not provided, no validation occurs:

```typescript
const agent = createAgent({
  // No schema defined
  handler: async (ctx, input) => {
    // input is unknown type
    // No runtime validation
    return { message: 'Done' };
  },
});
```

For type safety, it's recommended to add a schema.

## Type Inference

TypeScript automatically infers types from your schemas, providing full autocomplete and compile-time type checking.

### Inferred Input Types

```typescript
const agent = createAgent({
  schema: {
    input: z.object({
      query: z.string(),
      filters: z.object({
        category: z.enum(['tech', 'business', 'sports']),
        limit: z.number().default(10),
      }),
    }),
  },
  handler: async (ctx, input) => {
    // TypeScript knows:
    // - input.query is string
    // - input.filters.category is 'tech' | 'business' | 'sports'
    // - input.filters.limit is number

    const category = input.filters.category; // Full autocomplete!
    return { processed: true };
  },
});
```

### Inferred Output Types

```typescript
const agent = createAgent({
  schema: {
    output: z.object({
      results: z.array(z.object({
        id: z.string(),
        title: z.string(),
        score: z.number(),
      })),
      total: z.number(),
    }),
  },
  handler: async (ctx, input) => {
    // Return type is validated and type-checked
    return {
      results: [
        { id: '1', title: 'Example', score: 0.95 },
      ],
      total: 1,
    };

    // This would cause a TypeScript error:
    // return { invalid: 'structure' };
  },
});
```

### Calling Agents with Type Inference

When calling agents, TypeScript knows the input and output types:

```typescript
// When calling the agent from another agent:
const result = await ctx.agent.searchAgent.run({
  query: 'agentic AI',
  filters: { category: 'tech', limit: 5 },
});

// TypeScript knows result has this shape:
// {
//   results: Array<{ id: string; title: string; score: number }>;
//   total: number;
// }

console.log(result.results[0].title); // Full autocomplete!
```

**Benefits:**
- Full IDE autocomplete for input and output
- Compile-time type checking catches errors before runtime
- No need to manually define TypeScript interfaces
- Refactoring is safer - changes to schemas update types automatically

## Validation Libraries

### Zod

[Zod](https://zod.dev/) is the most popular validation library with excellent TypeScript support.

```typescript
import { z } from 'zod';

const schema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().min(18),
  role: z.enum(['admin', 'user', 'guest']),
  tags: z.array(z.string()).optional(),
});
```

**Common Zod patterns:**
```typescript
// String validation
z.string()                    // Any string
z.string().min(5)             // Minimum length
z.string().max(100)           // Maximum length
z.string().email()            // Email format
z.string().url()              // URL format
z.string().uuid()             // UUID format

// Number validation
z.number()                    // Any number
z.number().min(0)             // Minimum value
z.number().max(100)           // Maximum value
z.number().int()              // Integer only
z.number().positive()         // Positive numbers

// Boolean, null, undefined
z.boolean()                   // Boolean
z.null()                      // Null
z.undefined()                 // Undefined

// Arrays and objects
z.array(z.string())           // Array of strings
z.object({ name: z.string() }) // Object shape
z.record(z.string())          // Record/map

// Optional and nullable
z.string().optional()         // string | undefined
z.string().nullable()         // string | null
z.string().nullish()          // string | null | undefined

// Defaults
z.string().default('hello')   // Use default if undefined
z.number().default(0)         // Use default if undefined

// Enums and literals
z.enum(['a', 'b', 'c'])       // One of these strings
z.literal('exact')            // Exact value
z.union([z.string(), z.number()]) // Multiple types
```

### Valibot

[Valibot](https://valibot.dev/) is a lightweight alternative with a similar API.

```typescript
import * as v from 'valibot';

const schema = v.object({
  name: v.string([v.minLength(1)]),
  email: v.string([v.email()]),
  age: v.number([v.minValue(18)]),
  role: v.union([
    v.literal('admin'),
    v.literal('user'),
    v.literal('guest')
  ]),
});
```

**Common Valibot patterns:**
```typescript
// String validation
v.string()                              // Any string
v.string([v.minLength(5)])              // Minimum length
v.string([v.maxLength(100)])            // Maximum length
v.string([v.email()])                   // Email format
v.string([v.url()])                     // URL format

// Number validation
v.number()                              // Any number
v.number([v.minValue(0)])               // Minimum value
v.number([v.maxValue(100)])             // Maximum value
v.number([v.integer()])                 // Integer only

// Arrays and objects
v.array(v.string())                     // Array of strings
v.object({ name: v.string() })          // Object shape

// Optional and nullable
v.optional(v.string())                  // string | undefined
v.nullable(v.string())                  // string | null
v.nullish(v.string())                   // string | null | undefined
```

### ArkType

[ArkType](https://arktype.io/) provides a TypeScript-first approach to validation.

```typescript
import { type } from 'arktype';

const schema = type({
  name: 'string>0',
  email: 'string.email',
  age: 'number>=18',
  role: '"admin"|"user"|"guest"',
  tags: 'string[]?',
});
```

**Common ArkType patterns:**
```typescript
// String validation
type('string')                 // Any string
type('string>5')               // Minimum length
type('string<100')             // Maximum length
type('string.email')           // Email format
type('string.url')             // URL format

// Number validation
type('number')                 // Any number
type('number>0')               // Greater than 0
type('number<=100')            // Less than or equal to 100
type('integer')                // Integer only

// Arrays and objects
type('string[]')               // Array of strings
type({ name: 'string' })       // Object shape

// Optional
type('string?')                // string | undefined
type('string|null')            // string | null
```

## Validation in Agents

### Complete Example

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      query: z.string().min(1),
      options: z.object({
        limit: z.number().default(10),
        includeMetadata: z.boolean().default(false),
      }).optional(),
    }),
    output: z.object({
      results: z.array(z.object({
        id: z.string(),
        title: z.string(),
        score: z.number().min(0).max(1),
      })),
      count: z.number(),
    }),
  },
  handler: async (ctx, input) => {
    // Input validated before handler runs
    ctx.logger.info('Processing query', { query: input.query });

    // Process the query...
    const results = [
      { id: '1', title: 'Result 1', score: 0.95 },
      { id: '2', title: 'Result 2', score: 0.87 },
    ];

    // Output validated before returning
    return {
      results,
      count: results.length,
    };
  },
});

export default agent;
```

### Validation Behavior

**Input validation:**
- Runs automatically before handler execution
- If validation fails, an error is thrown and the handler is not called
- Error includes detailed information about what failed

**Output validation:**
- Runs automatically after handler execution
- If validation fails, an error is thrown before returning to the caller
- Ensures consistent output shape

## Validation in Routes

Schemas can be used in route handlers with the `zValidator` middleware.

### Using zValidator

```typescript
import { createRouter } from '@agentuity/runtime';
import { zValidator } from '@hono/zod-validator';
import agent from './agent';

const router = createRouter();

router.post('/',
  zValidator('json', agent.inputSchema!),
  async (c) => {
    const data = c.req.valid('json'); // Type-safe, validated data
    const result = await c.agent.myAgent.run(data);
    return c.json(result);
  }
);

export default router;
```

### Route vs Agent Validation

**Route validation** (with zValidator):
- Validates HTTP request body before reaching your handler
- Returns 400 error if validation fails
- Useful for public-facing endpoints

**Agent validation** (with schema):
- Validates input when agent is called (from routes or other agents)
- Validates output before returning
- Ensures consistency across all callers

Both can be used together for defense in depth.

## Error Handling

### Validation Failures

When validation fails, an error is thrown with detailed information:

```typescript
try {
  await c.agent.userAgent.run({
    email: 'invalid-email',  // Invalid format
    age: -5,                 // Invalid range
  });
} catch (error) {
  // Error message includes:
  // - Which field failed validation
  // - What the validation rule was
  // - What the actual value was
  console.error('Validation error:', error.message);
}
```

### Input Validation Errors

If input validation fails, the handler never runs:

```typescript
const agent = createAgent({
  schema: {
    input: z.object({ age: z.number().min(0) }),
  },
  handler: async (ctx, input) => {
    // This never runs if age is negative
    return { processed: true };
  },
});

// This throws a validation error:
await ctx.agent.myAgent.run({ age: -1 });
```

### Output Validation Errors

If output validation fails, the error is thrown before returning:

```typescript
const agent = createAgent({
  schema: {
    output: z.object({ status: z.enum(['ok', 'error']) }),
  },
  handler: async (ctx, input) => {
    return { status: 'invalid' }; // Validation error!
  },
});
```

## Advanced Patterns

### Optional Fields

Use `.optional()` for fields that may be omitted:

```typescript
z.object({
  required: z.string(),
  optional: z.string().optional(),
  withDefault: z.number().default(10),
})

// Valid inputs:
{ required: 'value' }
{ required: 'value', optional: 'text' }
{ required: 'value', optional: 'text', withDefault: 20 }
```

### Nested Objects

Define complex nested structures:

```typescript
z.object({
  user: z.object({
    profile: z.object({
      name: z.string(),
      avatar: z.string().url().optional(),
    }),
    settings: z.object({
      theme: z.enum(['light', 'dark']),
      notifications: z.boolean(),
    }),
  }),
})
```

### Arrays and Unions

Validate arrays and multiple types:

```typescript
z.object({
  tags: z.array(z.string()),                    // Array of strings
  ids: z.array(z.number()).min(1).max(10),     // 1-10 numbers
  status: z.union([                             // Multiple types
    z.literal('active'),
    z.literal('inactive'),
    z.literal('pending')
  ]),
  value: z.string().or(z.number()),            // String or number
})
```

### Transformations

Transform data during validation:

```typescript
z.object({
  email: z.string().email().toLowerCase(),      // Convert to lowercase
  name: z.string().trim(),                      // Trim whitespace
  age: z.string().transform(val => parseInt(val)), // Parse to number
})
```

### Custom Validation

Add custom validation logic:

```typescript
z.object({
  password: z.string()
    .min(8)
    .refine(val => /[A-Z]/.test(val), {
      message: 'Password must contain uppercase letter'
    }),

  startDate: z.date(),
  endDate: z.date(),
}).refine(data => data.endDate > data.startDate, {
  message: 'End date must be after start date'
});
```

## Best Practices

### Always Validate Input

Validate input for all agents to prevent runtime errors:

```typescript
// Good - validated input
const agent = createAgent({
  schema: {
    input: z.object({
      email: z.string().email(),
      age: z.number().min(0)
    })
  },
  handler: async (ctx, input) => {
    // input is guaranteed valid
  },
});
```

### Use Schemas as Documentation

Schemas serve as clear documentation of your agent's API:

```typescript
schema: {
  input: z.object({
    // Query string to search for
    query: z.string().min(1).max(500),

    // Optional filters
    filters: z.object({
      category: z.enum(['tech', 'business', 'sports']),
      dateRange: z.object({
        from: z.date(),
        to: z.date(),
      }).optional(),
    }).optional(),

    // Maximum results (1-100)
    limit: z.number().min(1).max(100).default(10),
  }),
}
```

### Choose the Right Library

**Zod** - Best for most projects:
- Most popular with excellent community support
- Great TypeScript integration
- Comprehensive validation features

**Valibot** - Best for bundle size:
- Smaller bundle than Zod
- Similar API and features
- Good for client-side applications

**ArkType** - Best for TypeScript-first teams:
- Concise type-first syntax
- Strong TypeScript inference
- Good for complex type scenarios

### Validate Output for Consistency

Define output schemas to ensure consistent responses:

```typescript
schema: {
  output: z.object({
    success: z.boolean(),
    data: z.any().optional(),
    error: z.string().optional(),
  })
}
```

This ensures all code paths return the expected shape.

### Use Strict Mode

Enable strict mode to catch common mistakes:

```typescript
z.object({
  name: z.string()
}).strict() // Rejects unknown keys
```

This prevents accidentally passing extra fields that might indicate bugs.
