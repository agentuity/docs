---
title: Key-Value Storage
description: Fast, ephemeral storage for agent state, configuration, and caching
---

# Key-Value Storage

Key-value storage provides fast, ephemeral data access for agents. Use it for session state, configuration, caching, and temporary data that needs quick lookups.

## When to Use Key-Value Storage

Key-value storage is your go-to solution for fast, ephemeral data that agents need to access quickly. Think of it as your agent's short-term memory - perfect for session state, configuration, caching, and temporary data.

Choose the right storage for your use case:

- **Key-Value**: Fast lookups, simple data, temporary state
- **Vector Storage**: Semantic search, embeddings, similarity matching
- **Object Storage**: Large files, media, backups

## Common Use Cases

- **Persistent User Data**: Store user profiles, "remember me" tokens, and preferences that persist beyond active session lifetimes (use `ctx.session.state` for active session data - see [Sessions and Threads](/Guides/sessions-threads))
- **Configuration Storage**: Keep agent-specific settings, feature flags, and runtime configuration that can be updated without redeployment
- **Caching**: Cache expensive computation results, API responses, or frequently accessed data to improve agent performance
- **Inter-Agent Communication**: Share state between agents working together on complex workflows
- **Rate Limiting**: Track API usage, request counts, and implement throttling mechanisms

<Callout type="info" title="KV vs Built-in State">
v1 provides built-in state management (`ctx.state`, `ctx.thread.state`, `ctx.session.state`) for data tied to active requests, conversations, and sessions. Use KV when you need:

- **Custom TTL** longer than session/thread lifetimes
- **Persistent data** across sessions (user profiles, settings)
- **Shared state** across multiple sessions or agents (global config, rate limits)

See [Sessions and Threads](/Guides/sessions-threads) for built-in state management.
</Callout>

## Creating Key-Value Storage

You can create key-value storage either through the Cloud Console or programmatically in your agent code.

### Via Cloud Console

Navigate to **Services > Key Value** and click **Create Storage**. Choose a descriptive name that reflects the storage purpose (e.g., `user-sessions`, `agent-config`, `api-cache`).

<ThemeImage baseName="keyvalue" alt="Key Value Storage Overview" />

### Via SDK

The SDK automatically creates key-value storage when you first access it:

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Buckets are auto-created if they don't exist
    await ctx.kv.set('user-sessions', 'user-123', {
      lastSeen: new Date().toISOString(),
      preferences: { theme: 'dark' }
    });

    return { message: 'Session stored' };
  }
});
```

## Working with Key-Value Storage

The key-value API provides three core operations: `get`, `set`, and `delete`. All operations are asynchronous and support various data types.

The first parameter in all operations is the storage bucket name (also called "name" or "namespace"). Buckets are automatically created when you first use them.

### Storing Data

Store strings, objects, or binary data. Keys persist indefinitely by default, or you can set a TTL (time-to-live) for automatic expiration:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Simple store
    await ctx.kv.set('cache', 'api-response', responseData);

    // Store an object
    await ctx.kv.set('user-prefs', input.userId, {
      language: 'en',
      timezone: 'UTC'
    });

    // Store with TTL (expires after 1 hour)
    await ctx.kv.set('sessions', input.sessionId, userData, {
      ttl: 3600  // seconds
    });

    // Store feature flags (no TTL - persistent config)
    await ctx.kv.set('feature-flags', 'beta-features', {
      darkMode: true,
      aiAssistant: false,
      newDashboard: true
    });

    return { success: true };
  }
});
```

### Retrieving Data

Retrieve stored values with automatic deserialization:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Get a value
    const result = await ctx.kv.get('user-prefs', input.userId);

    if (result.exists) {
      // Data is already deserialized
      const preferences = result.data;
      ctx.logger.info('User preferences:', preferences);
    } else {
      ctx.logger.info('No preferences found for user');
    }

    // Handle missing keys gracefully
    const configResult = await ctx.kv.get('config', 'app-settings');
    const config = configResult.exists ? configResult.data : defaultConfig;

    return { config };
  }
});
```

**Type Safety with TypeScript:**

Use type parameters for full type safety:

```typescript
interface UserPreferences {
  language: string;
  timezone: string;
  theme: 'light' | 'dark';
}

const agent = createAgent({
  handler: async (ctx, input) => {
    // Specify type for type-safe access
    const result = await ctx.kv.get<UserPreferences>('user-prefs', input.userId);

    if (result.exists) {
      // TypeScript knows the shape of result.data
      const theme = result.data.theme; // Type: 'light' | 'dark'
      const language = result.data.language; // Type: string
    }

    return { success: true };
  }
});
```

### Deleting Data

Remove keys when they're no longer needed:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Delete a single key
    await ctx.kv.delete('sessions', input.sessionId);

    ctx.logger.info('Session deleted successfully');

    return { success: true };
  }
});
```

## Best Practices

### Key Naming Conventions

Use hierarchical, descriptive keys to organize your data:
- `user:{userId}:preferences`
- `session:{sessionId}:data`
- `cache:api:{endpoint}:{params}`

### Error Handling

Always handle potential storage errors gracefully:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    try {
      const result = await ctx.kv.get('config', 'settings');

      if (!result.exists) {
        // Initialize with defaults
        await ctx.kv.set('config', 'settings', defaultSettings);
      }

      return { config: result.exists ? result.data : defaultSettings };
    } catch (error) {
      ctx.logger.error('Storage error:', error);

      // Fall back to in-memory defaults
      return { config: defaultSettings };
    }
  }
});
```

### TTL Strategy

Keys persist indefinitely by default unless you specify a TTL (time-to-live) value. When you do specify a TTL, the minimum allowed value is 60 seconds.

Use TTL for temporary data to prevent storage bloat:
- **Session data**: 24-48 hours (86400-172800 seconds)
- **API cache**: 5-60 minutes (300-3600 seconds)
- **Rate-limiting counters**: Until period reset
- **Permanent config**: No TTL (keys persist forever)

Example with appropriate TTLs:

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Session data - expires after 24 hours
    await ctx.kv.set('sessions', input.sessionId, sessionData, {
      ttl: 86400
    });

    // API cache - expires after 5 minutes
    await ctx.kv.set('cache', cacheKey, apiResponse, {
      ttl: 300
    });

    // Rate limit counter - expires at end of hour
    const secondsUntilHourEnd = 3600 - (Date.now() / 1000 % 3600);
    await ctx.kv.set('rate-limits', input.userId, requestCount, {
      ttl: Math.ceil(secondsUntilHourEnd)
    });

    // Feature flags - no TTL (persistent)
    await ctx.kv.set('feature-flags', 'global', featureFlags);

    return { success: true };
  }
});
```

### Data Size Considerations

Key-value storage is optimized for small to medium-sized values. For large files or documents, consider using Object Storage instead.

## Monitoring Usage

Track your key-value storage usage through the Cloud Console:

1. Navigate to **Services > Key Value**
2. View storage size and record count for each instance
3. Click on an instance to browse stored keys and values
4. Monitor agent telemetry for KV operation performance

<ThemeImage baseName="keyvalue-detail" alt="Key Value Storage Detail View" />

For more complex data relationships or query needs, consider combining storage types or using external databases through your agent.

## Storage Types Overview

TODO: Add video for v1 storage overview

## Next Steps

- [Agent Communication](/Guides/agent-communication) - Share state between agents
- [Sessions and Threads](/Guides/sessions-threads) - Manage conversation state
- [API Reference](/SDK/api-reference) - Complete storage API documentation
