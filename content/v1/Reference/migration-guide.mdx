---
title: Migrating from v0 to v1
description: A comprehensive guide to migrating your Agentuity agents from v0 to v1
---

Agentuity v1 represents a significant evolution of the platform, introducing new capabilities for building AI agents with improved type safety, better developer experience, and powerful new features like evaluations and advanced routing.

This guide will help you migrate your existing v0 agents to v1, understand the breaking changes, and take advantage of the new features.

<Callout type="info">
**Migration Timeline:** We recommend migrating to v1 as soon as possible. v0 will continue to be supported until [DATE], but all new features and improvements will only be available in v1.
</Callout>

## What's New in v1?

<Callout type="success" title="No More Manual Agent Registration">
In v0, agents had to be created via the CLI (`agentuity agent create`) to register them with unique IDs in the cloud. In v1, just create a folder in `src/agents/` with `agent.ts` and `route.ts` — agents are auto-discovered and registered on deploy. No CLI commands or manual registration required.
</Callout>

v1 introduces several major improvements:

- **Auto-Discovery**: Create agents by adding folders — no CLI registration needed
- **Modern Architecture**: Built on Hono, a fast and lightweight web framework
- **Type-Safe Schemas**: Built-in support for Zod, Valibot, ArkType, and other StandardSchema libraries
- **Evaluation Framework**: Automatically test and validate agent outputs
- **Event System**: Integrate with agent lifecycle events for monitoring and analytics
- **Advanced Routing**: Native support for WebSocket, SSE, email, cron, and SMS
- **Session & Thread Management**: Better conversational state handling
- **Subagents**: Organize complex agents with parent-child relationships
- **React Package**: Build UIs for your agents with `@agentuity/react`

<Callout type="info">
**Workbench:** v0's "DevMode" is being rebranded to "Workbench", to better support agent development both locally and in production. The v0 `welcome()` function pattern for suggested prompts has been removed as part of this redesign.
</Callout>

---

## Breaking Changes Overview

### High Impact Changes

These changes require code modifications in all agents:

1. **Handler Pattern**: Default export functions replaced with `createAgent()`
2. **Request/Response**: New pattern using direct parameters and return values
3. **Context Properties**: `runId` renamed to `sessionId`, new properties added
4. **Package Structure**: SDK split into multiple packages (`@agentuity/runtime`, `@agentuity/core`, etc.)
5. **Language Support**: v1 is TypeScript-only, optimized for Bun runtime
6. **Trigger Configuration**: Cron schedules, email addresses, and SMS numbers are now configured in code (via `router.cron()`, `router.email()`, `router.sms()`) rather than in the cloud console UI

### Medium Impact Changes

These changes may affect some agents:

1. **Agent Registration**: Manual registration required with app router
2. **Trigger Types**: Additional trigger types available
3. **Service APIs**: Some method signatures updated

### Low Impact Changes

These are additions that don't break existing code:

1. **Schema Validation**: Optional but recommended
2. **Evaluations**: Optional quality checking framework
3. **Event Listeners**: Optional lifecycle hooks

---

## Step-by-Step Migration

### Step 1: Update Package Dependencies

First, update your `package.json` to use the new v1 packages:

**v0:**
```json
{
  "dependencies": {
    "@agentuity/sdk": "^0.x.x"
  }
}
```

**v1:**
```json
{
  "dependencies": {
    "@agentuity/runtime": "^1.x.x"
  }
}
```

Then install:
```bash
npm install
```

<Callout type="warn">
**Important**: v1 uses a monorepo structure. The primary package you'll use is `@agentuity/runtime`, which includes everything you need for agent development.
</Callout>

---

### Step 2: Update Agent Handler Pattern

The most significant change is how agents are created and exported.

#### Basic Agent Handler

**v0:**
```typescript
import { AgentHandler } from '@agentuity/sdk';

const handler: AgentHandler = async (request, response, context) => {
  const data = await request.data.json();
  
  context.logger.info('Processing request', data);
  
  return response.json({ 
    message: 'Hello from my agent!',
    data: data 
  });
};

export default handler;
```

**v1:**
```typescript
import { createAgent, createRouter } from '@agentuity/runtime';

const agent = createAgent({
  metadata: {
    name: 'My Agent',
    description: 'A simple agent'
  },
  handler: async (ctx, input) => {
    ctx.logger.info('Processing request', input);
    
    return {
      message: 'Hello from my agent!',
      data: input
    };
  }
});

const router = createRouter();
router.post('/my-agent', agent.handler);

export default router;
```

**Key Changes:**
1. Import from `@agentuity/runtime` instead of `@agentuity/sdk`
2. Use `createAgent()` instead of a plain function
3. Handler receives `(ctx, input)` instead of `(request, response, context)`
4. Return values directly instead of using `response.json()`
5. Use `createRouter()` to define HTTP endpoints and register your agent
6. Export the router instead of the handler

**File Structure Change:**
In v0, agents were typically single files. In v1, each agent has two files:
- **`agent.ts`** - Contains the `createAgent()` call with your handler logic
- **`route.ts`** - Contains the `createRouter()` call that defines HTTP endpoints and calls your agent

The route file imports the agent and invokes it via `ctx.agent.name.run(input)`. This separation keeps HTTP routing concerns separate from agent business logic, making agents reusable across different routes and other agents.

---

#### Agent with Schema Validation (NEW in v1)

v1 introduces optional schema validation for type safety:

```typescript
// src/agents/typed-agent/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      message: z.string(),
      count: z.number().optional()
    }),
    output: z.object({
      response: z.string(),
      timestamp: z.number()
    })
  },
  metadata: {
    name: 'Typed Agent',
    description: 'An agent with type-safe inputs and outputs'
  },
  handler: async (ctx, input) => {
    // input is fully typed as { message: string, count?: number }
    
    return {
      response: `Received: ${input.message}`,
      timestamp: Date.now()
    };
    // Return type is validated automatically
  }
});

export default agent;
```

```typescript
// src/agents/typed-agent/route.ts
import { createRouter } from '@agentuity/runtime';
import agent from './agent';

const router = createRouter();
router.post('/typed-agent', agent.handler);

export default router;
```

**Benefits:**
- Full TypeScript autocomplete
- Runtime validation of inputs and outputs
- Automatic error handling for invalid data
- Self-documenting API contracts

---

### Step 3: Update Context Usage

The context object has several changes and additions.

#### Context Property Changes

**v0:**
```typescript
const handler: AgentHandler = async (request, response, context) => {
  // Access run ID
  const id = context.runId;
  
  // Access services
  await context.kv.set('cache', 'key', data);
  
  // Access logger
  context.logger.info('Message');
};
```

**v1:**
```typescript
const agent = createAgent({
  handler: async (ctx) => {
    // runId renamed to sessionId
    const id = ctx.sessionId;
    
    // Services work the same way
    await ctx.kv.set('cache', 'key', data);
    
    // Logger unchanged
    ctx.logger.info('Message');
    
    // NEW: Access to all agents
    const result = await ctx.agent.otherAgent.run({ input: 'data' });
    
    // NEW: Current agent reference
    ctx.logger.info('Current agent:', { name: ctx.current?.metadata.name });
    
    // NEW: State management
    ctx.state.set('myKey', 'myValue');
    
    // NEW: Session and thread objects
    ctx.logger.info('Session:', ctx.session);
    ctx.logger.info('Thread:', ctx.thread);
  }
});
```

**Key Changes:**
- `context.runId` → `ctx.sessionId`
- New `ctx.agent` for accessing other agents
- New `ctx.current` for current agent metadata
- New `ctx.parent` for parent agent (in subagents)
- New `ctx.state` for temporary state storage
- New `ctx.session` and `ctx.thread` for conversation management

---

### Step 4: Update Request Handling

Request handling is simplified in v1.

#### Accessing Request Data

**v0:**
```typescript
const handler: AgentHandler = async (request, response, context) => {
  // Get JSON data
  const data = await request.data.json();
  
  // Get text data
  const text = await request.data.text();
  
  // Get binary data
  const binary = await request.data.binary();
  
  // Get metadata
  const userId = request.get('userId');
  const trigger = request.trigger;
};
```

**v1 (HTTP Routes):**
```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.post('/my-agent', async (c) => {
  // Get JSON body directly from Hono context
  const data = await c.req.json();
  
  // Get text body
  const text = await c.req.text();
  
  // Get headers
  const userId = c.req.header('x-user-id');
  
  // Get query params
  const param = c.req.query('param');
  
  return { processed: data };
});

export default router;
```

**v1 (Agent with Schema):**
```typescript
const agent = createAgent({
  schema: {
    input: z.object({ message: z.string() })
  },
  handler: async (ctx, input) => {
    // Input is automatically parsed and validated
    // No need to call request.data.json()
    ctx.logger.info('Input message:', { message: input.message });
    
    return { response: 'ok' };
  }
});
```

---

### Step 5: Update Response Handling

Responses are now returned directly instead of using a response builder.

#### Basic Responses

**v0:**
```typescript
const handler: AgentHandler = async (request, response, context) => {
  // JSON response
  return response.json({ message: 'Hello' });
  
  // Text response
  return response.text('Hello');
  
  // Binary response
  return response.binary(buffer);
  
  // Empty response
  return response.empty();
};
```

**v1:**
```typescript
const agent = createAgent({
  handler: async (ctx) => {
    // JSON response - just return an object
    return { message: 'Hello' };
    
    // Text response - return string (set content-type manually if needed)
    return 'Hello';
    
    // For more control, use Hono's response helpers
    return ctx.text('Hello');
    return ctx.json({ message: 'Hello' });
    return ctx.body(buffer);
    
    // Empty response
    return ctx.body(null);
  }
});
```

**Key Changes:**
1. No `response` object - return values directly
2. Objects are automatically JSON-serialized
3. Use Hono context methods for advanced responses
4. For typed responses, define `outputSchema`

---

### Step 6: Update Service Usage

<Callout type="success">
**Good News**: Service APIs (KV, Vector, ObjectStore, Stream) remain largely unchanged between v0 and v1. Your existing service code should work with minimal modifications.
</Callout>

#### Key-Value Storage

**v0:**
```typescript
// Set with TTL
await context.kv.set('cache', 'key', data, { ttl: 3600 });

// Get
const result = await context.kv.get('cache', 'key');
if (result.exists) {
  const value = await result.data.json();
}

// Delete
await context.kv.delete('cache', 'key');
```

**v1:**
```typescript
// Services work the same way!
// TTL is in seconds (minimum 60)
await ctx.kv.set('cache', 'key', data, { ttl: 3600 });

const result = await ctx.kv.get('cache', 'key');
if (result.exists) {
  const value = await result.data.json();
}

await ctx.kv.delete('cache', 'key');
```

---

### Step 7: Update Agent-to-Agent Communication

Agent-to-agent communication has been simplified and made type-safe in v1.

**v0:**
```typescript
const handler: AgentHandler = async (request, response, context) => {
  // Get agent by ID
  const agent = await context.getAgent({ id: 'agent_123' });
  
  // Or by name
  const agent = await context.getAgent({ 
    name: 'other-agent',
    projectId: 'proj_123' 
  });
  
  // Run the agent
  const result = await agent.run({
    data: JSON.stringify({ message: 'Hello' }),
    contentType: 'application/json'
  });
  
  const output = await result.data.json();
};
```

**v1:**
```typescript
const agent = createAgent({
  handler: async (ctx) => {
    // Access agents directly by name - much simpler!
    const result = await ctx.agent.otherAgent.run({
      message: 'Hello'
    });
    
    // Result is automatically typed if the agent has a schema
    ctx.logger.info('Agent response:', { response: result.response });
    
    return result;
  }
});
```

**Key Changes:**
1. `ctx.agent.otherAgent.run()` instead of `getAgent()`
2. No need to JSON-stringify data
3. Type-safe when using schemas
4. Subagents accessible via `ctx.agent.parent.child.run()`

---

## Advanced Migration Topics

Now that you've covered the essential migration steps, the following sections explore advanced features and patterns available in v1. These are optional enhancements that can improve your agents' capabilities, but aren't required for basic functionality.

### Migrating to Advanced Routing

v1 introduces specialized route types for different use cases.

#### Email Routes

**v0 (Webhook approach):**
```typescript
const handler: AgentHandler = async (request, response, context) => {
  // Parse email manually
  const emailData = await request.data.text();
  // ... manual RFC822 parsing
};
```

**v1 (Native email route):**
```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.email('support@example.com', async (email, ctx) => {
  // Email is automatically parsed
  ctx.logger.info('Email received:', {
    from: email.fromEmail(),
    subject: email.subject()
  });
  
  // Access email properties
  const textBody = email.text();
  const htmlBody = email.html();
  const attachments = email.attachments();
  
  // Note: Email reply functionality is coming soon
  
  return { status: 'processed' };
});

export default router;
```

#### WebSocket Routes (NEW)

```typescript
router.websocket('/chat', (ctx) => (ws) => {
  ws.onOpen((event) => {
    ctx.logger.info('Client connected');
    ws.send('Welcome!');
  });
  
  ws.onMessage(async (event) => {
    const message = event.data;
    ctx.logger.info('Received:', message);
    
    // Process with agent logic
    const response = await processMessage(message);
    ws.send(response);
  });
  
  ws.onClose((event) => {
    ctx.logger.info('Client disconnected');
  });
});
```

#### Server-Sent Events (NEW)

```typescript
router.sse('/updates', (ctx) => async (stream) => {
  // Send updates to client
  await stream.write({ event: 'started', data: 'Processing...' });
  
  // Do work
  const result = await longRunningTask();
  
  await stream.write({ event: 'progress', data: '50%' });
  
  // Final result
  await stream.write({ event: 'complete', data: result });
});
```

#### Cron Routes (NEW)

```typescript
router.cron('0 0 * * *', async (ctx) => {
  // Runs daily at midnight
  ctx.logger.info('Running daily job');
  
  const report = await generateDailyReport();
  await ctx.kv.set('reports', 'daily-latest', report);
  
  return { status: 'completed' };
});
```

---

### Adding Evaluations (NEW in v1)

Evaluations allow you to automatically test agent outputs for quality, accuracy, or compliance.

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ question: z.string() }),
    output: z.object({ answer: z.string() })
  },
  handler: async (ctx, input) => {
    const answer = await generateAnswer(input.question);
    return { answer };
  }
});

// Add an evaluation
agent.createEval({
  metadata: {
    name: 'answer-quality',
    description: 'Checks if answer is relevant and complete'
  },
  handler: async (ctx, input, output) => {
    // Evaluate the output
    const isRelevant = await checkRelevance(input.question, output.answer);
    const isComplete = output.answer.length > 50;
    
    if (isRelevant && isComplete) {
      return {
        success: true,
        score: 0.95,
        metadata: { 
          relevant: isRelevant,
          complete: isComplete 
        }
      };
    } else {
      return {
        success: true,
        score: 0.5,
        metadata: { 
          relevant: isRelevant,
          complete: isComplete 
        }
      };
    }
  }
});
```

**When to use evaluations:**
- Quality checking (accuracy, relevance, completeness)
- Compliance validation (PII detection, content policy)
- Performance monitoring (response time, token usage)
- A/B testing (comparing different approaches)

---

### Using Event Listeners (NEW in v1)

Integrate with agent lifecycle events for monitoring and analytics.

```typescript
import { createAgent, createApp } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    return { result: 'success' };
  }
});

// Agent-level events
agent.addEventListener('started', async (event, agent, ctx) => {
  ctx.logger.info('Agent started', { agentName: agent.metadata.name });
});

agent.addEventListener('completed', async (event, agent, ctx) => {
  ctx.logger.info('Agent completed', { 
    agentName: agent.metadata.name,
    sessionId: ctx.sessionId 
  });
});

agent.addEventListener('errored', async (event, agent, ctx, error) => {
  ctx.logger.error('Agent errored', { 
    agentName: agent.metadata.name,
    error: error.message 
  });
});

// App-level events
const app = createApp();

app.addEventListener('agent.started', async (agent, ctx) => {
  // Track all agent starts
  await analytics.track('agent_started', {
    agent: agent.metadata.name,
    session: ctx.sessionId
  });
});

app.addEventListener('agent.completed', async (agent, ctx) => {
  // Track all agent completions
  await analytics.track('agent_completed', {
    agent: agent.metadata.name,
    session: ctx.sessionId
  });
});
```

---

### Working with Sessions and Threads (NEW in v1)

v1 introduces explicit session and thread management for conversational agents.

```typescript
const agent = createAgent({
  handler: async (ctx, input) => {
    // Access session info
    ctx.logger.info('Session info:', {
      sessionId: ctx.sessionId,
      session: ctx.session
    });
    
    // Access thread for conversation history
    ctx.logger.info('Thread:', ctx.thread);
    
    // Store conversation state
    ctx.state.set('lastUserMessage', input.message);
    ctx.state.set('conversationTurn', 
      (ctx.state.get('conversationTurn') as number || 0) + 1
    );
    
    return { response: 'Message received' };
  }
});
```

**Use cases:**
- Multi-turn conversations
- Maintaining context across requests
- User preference storage
- Conversation history tracking

---

### Creating Subagents (NEW in v1)

Organize complex agents with parent-child relationships.

**Project Structure:**
```
src/agents/
  ├── email-agent/
  │   ├── index.ts          (parent agent)
  │   └── email-agent.parser/
  │       └── index.ts      (subagent)
```

**Parent Agent:**
```typescript
// src/agents/email-agent/index.ts
import { createAgent } from '@agentuity/runtime';

export const emailAgent = createAgent({
  metadata: {
    name: 'Email Agent',
    description: 'Processes incoming emails'
  },
  handler: async (ctx, input) => {
    // Use subagent for parsing
    const parsed = await ctx.agent.emailAgent.parser.run({
      rawEmail: input.email
    });
    
    // Process parsed data
    return { status: 'processed', data: parsed };
  }
});
```

**Subagent:**
```typescript
// src/agents/email-agent/email-agent.parser/index.ts
import { createAgent } from '@agentuity/runtime';

export const parserAgent = createAgent({
  metadata: {
    name: 'Email Parser',
    description: 'Parses email structure'
  },
  handler: async (ctx, input) => {
    // Access parent if needed
    ctx.logger.info('Parent agent:', { parent: ctx.parent?.metadata.name });
    
    // Parse email
    const parsed = parseEmailStructure(input.rawEmail);
    
    return parsed;
  }
});
```

---

## Common Migration Patterns

### Pattern 1: Simple REST API Agent

**v0:**
```typescript
import { AgentHandler } from '@agentuity/sdk';

const handler: AgentHandler = async (request, response, context) => {
  const { name } = await request.data.json();
  return response.json({ greeting: `Hello, ${name}!` });
};

export default handler;
```

**v1:**
```typescript
import { createAgent, createRouter } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ name: z.string() }),
    output: z.object({ greeting: z.string() })
  },
  handler: async (ctx, input) => {
    return { greeting: `Hello, ${input.name}!` };
  }
});

const router = createRouter();
router.post('/greet', agent.handler);

export default router;
```

---

### Pattern 2: Agent with Storage

**v0:**
```typescript
import { AgentHandler } from '@agentuity/sdk';

const handler: AgentHandler = async (request, response, context) => {
  const { userId, data } = await request.data.json();
  
  // Store data
  await context.kv.set('user-data', userId, data);
  
  // Retrieve data
  const result = await context.kv.get('user-data', userId);
  const storedData = result.exists ? await result.data.json() : null;
  
  return response.json({ stored: storedData });
};

export default handler;
```

**v1:**
```typescript
import { createAgent, createRouter } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      userId: z.string(),
      data: z.record(z.unknown())
    })
  },
  handler: async (ctx, input) => {
    // Store data (same API!)
    await ctx.kv.set('user-data', input.userId, input.data);
    
    // Retrieve data (same API!)
    const result = await ctx.kv.get('user-data', input.userId);
    const storedData = result.exists ? await result.data.json() : null;
    
    return { stored: storedData };
  }
});

const router = createRouter();
router.post('/store', agent.handler);

export default router;
```

---

### Pattern 3: Multi-Agent Workflow

**v0:**
```typescript
import { AgentHandler } from '@agentuity/sdk';

const handler: AgentHandler = async (request, response, context) => {
  const input = await request.data.json();
  
  // Call first agent
  const agent1 = await context.getAgent({ name: 'processor' });
  const result1 = await agent1.run({
    data: JSON.stringify(input),
    contentType: 'application/json'
  });
  const processed = await result1.data.json();
  
  // Call second agent
  const agent2 = await context.getAgent({ name: 'validator' });
  const result2 = await agent2.run({
    data: JSON.stringify(processed),
    contentType: 'application/json'
  });
  const validated = await result2.data.json();
  
  return response.json(validated);
};

export default handler;
```

**v1:**
```typescript
import { createAgent, createRouter } from '@agentuity/runtime';

const agent = createAgent({
  handler: async (ctx, input) => {
    // Call first agent (much simpler!)
    const processed = await ctx.agent.processor.run(input);
    
    // Call second agent
    const validated = await ctx.agent.validator.run(processed);
    
    return validated;
  }
});

const router = createRouter();
router.post('/workflow', agent.handler);

export default router;
```

---

## Troubleshooting

### Common Migration Issues

#### Issue 1: "Cannot find module '@agentuity/sdk'"

**Cause**: You haven't updated your imports from v0 to v1.

**Solution**: Change all imports from:
```typescript
import { ... } from '@agentuity/sdk';
```

To:
```typescript
import { ... } from '@agentuity/runtime';
```

---

#### Issue 2: "Property 'runId' does not exist on type 'AgentContext'"

**Cause**: `runId` was renamed to `sessionId` in v1.

**Solution**: Replace all instances of `context.runId` with `ctx.sessionId`.

---

#### Issue 3: "Handler is not a function"

**Cause**: You're exporting the agent directly instead of the router.

**Solution**: Make sure you export the router:
```typescript
const router = createRouter();
router.post('/agent', agent.handler);

export default router; // Not 'agent' or 'handler'
```

---

#### Issue 4: "Input validation failed"

**Cause**: You defined an input schema but the incoming data doesn't match it.

**Solution**: Check your schema definition and ensure incoming data matches:
```typescript
const agent = createAgent({
  schema: {
    input: z.object({
      message: z.string(),
      // Make optional fields explicit
      metadata: z.record(z.unknown()).optional()
    })
  },
  handler: async (ctx, input) => {
    // ...
  }
});
```

---

#### Issue 5: "Cannot access other agents"

**Cause**: Agents aren't properly registered with the router.

**Solution**: Ensure all agents are registered:
```typescript
const router = createRouter();

// Register each agent
router.post('/agent1', agent1.handler);
router.post('/agent2', agent2.handler);

// Now they can access each other via ctx.agent
```

---

### Getting Help

If you encounter issues not covered in this guide:

1. **Check the Documentation**: Visit the [v1 API Reference](/SDKs/javascript/api-reference) for detailed information
2. **Review Examples**: Browse the [Examples](/Examples) section for working code
3. **Community Support**: Join our [Discord community](https://discord.gg/agentuity) for help
4. **Report Issues**: Open an issue on [GitHub](https://github.com/agentuity/sdk) if you find bugs

---

## Next Steps

After migrating your agents:

1. **Add Schema Validation**: Improve type safety with [Schema Validation](/SDKs/javascript/schema-validation)
2. **Implement Evaluations**: Ensure quality with the [Evaluation Framework](/SDKs/javascript/evaluations)
3. **Use Advanced Routing**: Explore [WebSocket, SSE, and other routes](/Guides/routing-triggers)
4. **Add Event Listeners**: Monitor your agents with [Events](/SDKs/javascript/events)
5. **Organize with Subagents**: Structure complex agents with [Subagents](/SDKs/javascript/subagents)
