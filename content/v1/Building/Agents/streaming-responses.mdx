---
title: Returning Streaming Responses
description: Return real-time LLM output with streaming agents
---

# Returning Streaming Responses

Show LLM output as it's generated instead of waiting for the full response. Streaming reduces perceived latency and creates a more responsive experience.

## Streaming Types

Agentuity supports two streaming patterns:

### Ephemeral Streaming

Uses `router.stream()` for direct streaming to the HTTP client. Data flows through and is not stored. Use this for real-time chat responses.

```typescript
// In route.ts
router.stream('/', async (c) => {
  return await c.agent.chat.run({ message: '...' });
});
```

### Persistent Streaming

Uses `ctx.stream.create()` to create stored streams with public URLs. Data persists and can be accessed after the connection closes. Use this for batch processing, exports, or content that needs to be accessed later.

```typescript
// In agent.ts
const stream = await ctx.stream.create('my-export', {
  contentType: 'text/csv',
});
await stream.write('data');
await stream.close();
```

This page focuses on ephemeral streaming with the AI SDK. For persistent streaming patterns, see the [Storage documentation](/Building/Storage/durable-streams).

<Callout type="info" title="Two Parts to Streaming">
Streaming requires both: `schema.stream: true` in your agent (so the handler returns a stream) and `router.stream()` in your route (so the response is streamed to the client).
</Callout>

## Basic Streaming

Enable streaming by setting `stream: true` in your schema and returning a `textStream`:

```typescript
import { createAgent } from '@agentuity/runtime';
import { streamText } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({ message: z.string() }),
    stream: true,
  },
  handler: async (ctx, input) => {
    const { textStream } = streamText({
      model: anthropic('claude-sonnet-4-5'),
      prompt: input.message,
    });

    return textStream;
  },
});

export default agent;
```

## Route Configuration

Use `router.stream()` to handle streaming responses:

```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.stream('/', async (c) => {
  const body = await c.req.json();
  return c.agent.chat.run(body);
});

export default router;
```

<Callout type="info" title="Route Methods">
Use `router.stream()` for streaming agents. Regular `router.post()` works but may buffer the response depending on the client.
</Callout>

## Consuming Streams

### With Fetch API

Read the stream using the Fetch API:

```typescript
const response = await fetch('http://localhost:3500/chat', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ message: 'Tell me a story' }),
});

const reader = response.body?.getReader();
const decoder = new TextDecoder();

while (reader) {
  const { done, value } = await reader.read();
  if (done) break;

  const text = decoder.decode(value);
  // Process each chunk as it arrives
  appendToUI(text);
}
```

### With React

Use the `useAgent` hook from `@agentuity/react`:

```tsx
import { useAgent } from '@agentuity/react';

function Chat() {
  const { data, running, run } = useAgent('chat');

  const handleSubmit = async (message: string) => {
    await run({ message });
  };

  return (
    <div>
      {running && <p>Generating...</p>}
      {data && <p>{data}</p>}
      <button onClick={() => handleSubmit('Hello!')}>Send</button>
    </div>
  );
}
```

For streaming with React, see [Frontend Hooks](/Building/Frontend/react-hooks).

## Streaming with System Prompts

Add context to streaming responses:

```typescript
handler: async (ctx, input) => {
  const { textStream } = streamText({
    model: anthropic('claude-sonnet-4-5'),
    system: 'You are a helpful assistant. Be concise.',
    messages: [
      { role: 'user', content: input.message },
    ],
  });

  return textStream;
}
```

## Streaming with Conversation History

Combine streaming with thread state for multi-turn conversations:

```typescript
handler: async (ctx, input) => {
  // Get existing messages from thread state
  const messages = ctx.thread.state.get('messages') || [];

  // Add new user message
  messages.push({ role: 'user', content: input.message });

  const { textStream, text } = streamText({
    model: anthropic('claude-sonnet-4-5'),
    messages,
  });

  // Save assistant response after streaming completes
  ctx.waitUntil(async () => {
    const fullText = await text;
    messages.push({ role: 'assistant', content: fullText });
    ctx.thread.state.set('messages', messages);
  });

  return textStream;
}
```

<Callout type="tip" title="Background Tasks">
Use `ctx.waitUntil()` to save conversation history without blocking the stream. The response starts immediately while state updates happen in the background.
</Callout>

## When to Stream

| Scenario | Recommendation |
|----------|----------------|
| Chat interfaces | Stream for better UX |
| Long-form content | Stream to show progress |
| Quick classifications | Buffer (faster overall, consider Groq for speed) |
| Structured data | Buffer (use `generateObject`) |

## Error Handling

Handle streaming errors with the `onError` callback:

```typescript
const { textStream } = streamText({
  model: anthropic('claude-sonnet-4-5'),
  prompt: input.message,
  onError: (error) => {
    ctx.logger.error('Stream error', { error });
  },
});
```

<Callout type="warning" title="Stream Errors">
Errors in streaming are part of the stream, not thrown exceptions. Always provide an `onError` callback.
</Callout>

## Next Steps

- [Using the AI SDK](/Building/Agents/ai-sdk-integration): Structured output and non-streaming responses
- [State Management](/Building/Agents/state-management): Multi-turn conversations with memory
- [Server-Sent Events](/Building/Routes-Triggers/sse): Server-push updates without polling
