---
title: "Module 3: Specialized Routes & Triggers"
description: Beyond HTTP - Master cron scheduling, email/SMS triggers, real-time routes, and multi-trigger architecture
---

You've seen how useful HTTP routing can be, but it's not the only way to interact with your agents. Now we'll learn how to build agents that respond to scheduled jobs, email and SMS messages, and real-time connections. This module covers the specialized triggers that let your agents respond to any event, on any channel.

## Beyond HTTP

Agents can respond to more than HTTP requests. The router supports specialized triggers for different interaction patterns, all defined declaratively in code.

### Trigger Types

Routes define triggers through code, not configuration files or UI settings. Each route type provides specific capabilities:

**HTTP** - User-initiated requests (GET, POST, PUT, DELETE)
**Cron** - Scheduled execution with cron expressions
**Email** - Email-based interaction with natural language
**SMS** - Text message triggers for mobile integration
**WebSocket** - Real-time bidirectional communication
**SSE** - Server-to-client streaming for live updates

### When to Use Each Trigger

| Trigger | Best For | Example Use Cases |
|---------|----------|-------------------|
| **Cron** | Scheduled tasks | Cache warming, batch processing, scheduled reports, cleanup |
| **Email** | Natural language | Support tickets, queries, automated workflows |
| **SMS** | Mobile alerts | Concise queries, notifications, two-way texting |
| **WebSocket** | Bidirectional real-time | Chat, live collaboration, gaming |
| **SSE** | Server streaming | Live dashboards, progress updates, data feeds |

### Multi-Trigger Architecture

Design agents that respond to multiple channels. Share business logic across triggers while implementing channel-specific behavior in routes.

---

## Tutorial Steps

Each step below focuses on a different trigger type with simple, self-contained examples.

### Step 1: Status Checker (Cron + HTTP)

<TutorialStep number={1} title="Status Checker (Cron + HTTP)" estimatedTime="8 min">

Scheduled jobs enable proactive agents. This status checker runs every hour to verify services are up, storing results that can be queried on-demand.

<CodeFromFiles snippets={[
  { path: "/examples/training/03-specialized-routes/step1-status-checker/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/03-specialized-routes/step1-status-checker/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Cron syntax: `'0 * * * *'` runs every hour at minute 0
- Scheduled data updates with KV storage
- HTTP routes for querying cached data
- Simple loop for updating multiple items

**Cron Syntax Quick Reference:**
```
┌─────── minute (0-59)
│ ┌───── hour (0-23)
│ │ ┌─── day of month (1-31)
│ │ │ ┌─ month (1-12)
│ │ │ │ ┌ day of week (0-6, Sunday=0)
* * * * *

Examples:
'0 * * * *'     - Every hour
'0 0 * * *'     - Daily at midnight
'*/15 * * * *'  - Every 15 minutes
'0 9 * * 1-5'   - Weekdays at 9 AM
```

For complete cron documentation and best practices, see the [Routing Guide](/v1/Build/Routes/index).

**Try it:**
1. Start DevMode: `agentuity dev`
2. Trigger cron manually in DevMode console
3. Check logs to see status updates
4. Query via HTTP: `curl http://localhost:3500/status/api`
5. Notice data comes from cache (updated by cron)

> **Key Insight:** Scheduled jobs enable proactive agents. Cron updates data periodically, HTTP routes serve cached results. This pattern keeps responses fast while ensuring data freshness.

</TutorialStep>

---

### Step 2: Email Responder

<TutorialStep number={2} title="Email Responder" estimatedTime="8 min">

Email triggers enable conversational agents. This auto-responder acknowledges incoming emails with formatted text replies.

<CodeFromFiles snippets={[
  { path: "/examples/training/03-specialized-routes/step2-email-responder/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/03-specialized-routes/step2-email-responder/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Email triggers: `router.email('address@example.com')`
- Email parsing: `c.req.email()` provides `from`, `subject`, `text`, `html`
- Text response formatting
- Simple acknowledgment pattern

**Try it:**
1. Start DevMode
2. Send test email to `hello@example.com` (DevMode provides test endpoint)
3. Check logs to see parsed email data
4. Receive formatted auto-response

> **Key Insight:** Email triggers enable natural language interaction. Parse email data, process it through your agent, and return formatted text responses.

</TutorialStep>

---

### Step 3: Real-Time Echo (WebSocket & SSE)

<TutorialStep number={3} title="Real-Time Echo (WebSocket & SSE)" estimatedTime="10 min">

Real-time routes enable live agents. This example shows both WebSocket (bidirectional) and SSE (server-to-client) patterns.

<CodeFromFiles snippets={[
  { path: "/examples/training/03-specialized-routes/step3-realtime-echo/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/03-specialized-routes/step3-realtime-echo/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- WebSocket setup: `router.websocket(path, { onOpen, onMessage, onClose })`
- Bidirectional communication: client sends, server sends
- SSE setup: `router.sse(path, handler)` with `c.stream()`
- Unidirectional streaming: server → client only
- Periodic updates with `setInterval`
- Connection lifecycle management and cleanup

**WebSocket vs SSE:**

| Feature | WebSocket | SSE |
|---------|-----------|-----|
| **Direction** | Bidirectional (↔) | Server → Client (→) |
| **Use Case** | Chat, gaming, collaboration | Live feeds, dashboards, notifications |
| **Complexity** | More complex | Simpler |
| **Reconnection** | Manual | Automatic |
| **Protocol** | `ws://` or `wss://` | HTTP/HTTPS |

**Try it:**
1. **WebSocket:**
   - Connect: `ws://localhost:3500/echo`
   - Send message: `"Hello"`
   - Receive echo back with timestamp

2. **SSE:**
   - Connect: `curl -N http://localhost:3500/updates`
   - Receive periodic updates every 5 seconds
   - Auto-reconnects if connection drops

> **Key Insight:** WebSocket enables bidirectional communication (client sends, server responds). SSE enables server-to-client streaming (server pushes updates). Use WebSocket for interactive experiences, SSE for live data feeds.

</TutorialStep>

---

### Step 4: Multi-Trigger Notifications

<TutorialStep number={4} title="Multi-Trigger Notifications" estimatedTime="8 min">

Modern agents should be accessible via multiple channels. This notification agent demonstrates how to use different routes for different triggers while sharing business logic.

<CodeFromFiles snippets={[
  { path: "/examples/training/03-specialized-routes/step4-multi-trigger-notifications/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/03-specialized-routes/step4-multi-trigger-notifications/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Different routes for different triggers (recommended pattern)
- HTTP: On-demand notifications
- Cron: Scheduled daily digest
- Email: Email-triggered notifications
- Shared agent logic across all triggers
- Channel-specific response formatting
- Smart caching strategies per trigger

**Best Practices:**

**Use different routes when:**
- Logic differs significantly per trigger
- Response format differs (JSON vs email text vs SMS)
- You want clear separation of concerns
- Each trigger has unique caching or rate limiting needs

**Design guidelines:**
- Log trigger type for observability
- Use trigger-specific caching strategies
- Format responses appropriately per channel
- Share agent business logic across all routes
- Document expected behavior per trigger

> **Key Insight:** Design for multi-channel access. Use different routes for different triggers with shared agent logic. This makes your agents flexible and user-friendly across all channels while maintaining clean code organization.

</TutorialStep>

---

## Key Takeaways

By the end of this module, you should understand:

1. **Cron Scheduling:**
   - Cron syntax for scheduling tasks
   - Scheduled data updates with KV storage
   - Periodic maintenance patterns
   - Combining cron with HTTP for fast queries

2. **Email Triggers:**
   - Email route setup with `router.email()`
   - Parsing email data (`c.req.email()`)
   - Text response formatting
   - Natural language interaction patterns

3. **Real-Time Routes:**
   - WebSocket for bidirectional communication
   - SSE for server-to-client streaming
   - Connection lifecycle management
   - When to use each pattern

4. **Multi-Trigger Architecture:**
   - Different routes for different triggers
   - Shared agent logic across channels
   - Trigger-specific behavior in routes
   - Best practices for multi-channel agents

Agents can now respond to any channel. Design routes around user needs, not technical constraints.

---

## What's Next?

**Module 4: State Management** - Learn about `c.state`, `c.thread.state`, and `c.session.state` for managing memory across different scopes (request, conversation, user-level).

For more details on routing patterns an