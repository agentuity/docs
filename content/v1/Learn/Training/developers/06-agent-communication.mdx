---
title: "Module 6: Agent Communication"
description: Building multi-agent systems with type-safe orchestration
---

Building a single agent is powerful, but the real potential emerges when agents collaborate. Whether you need specialized expertise, parallel processing, or coordinated workflows, multi-agent systems enable you to break down complex problems into manageable, focused components.

## Why Multi-Agent Systems?

Modern AI systems increasingly rely on agent collaboration. The benefits mirror how effective teams work:

- **Specialization**: Each agent focuses on what it does best
- **Scalability**: Distribute work across multiple agents
- **Modularity**: Add or modify agents without rewriting the system
- **Reliability**: Isolate failures to specific agents

The difference is in the execution: agents communicate through type-safe calls with automatic validation.

## Agent Communication in v1

Agents communicate via direct imports. Import an agent and call its `run()` method with type-safe input.

**Basic Pattern:**
```typescript
// Import the agent
import enrichmentAgent from '@agent/enrichment-agent';

// Inside any agent handler or route
const result = await enrichmentAgent.run({
  text: input.data
});
```

**Key features:**
- **Direct imports**: `import agent from '@agent/name'`
- **Type safety**: Full TypeScript inference when schemas are defined
- **Schema validation**: Input and output automatically validated
- **Simple syntax**: Import and call `agent.run()`

### Conditional Routing in Routes

Routes can analyze requests and conditionally call different agents based on the analysis. This replaces delegation patterns from previous versions with explicit, controllable orchestration:

```typescript
// route.ts - routes handle conditional logic
import urgentProcessor from '@agent/urgent-processor';
import standardProcessor from '@agent/standard-processor';

router.post('/process', async (c) => {
  const body = await c.req.json();

  // Choose agent based on request type
  if (body.type === 'urgent') {
    return c.json(await urgentProcessor.run(body));
  }

  return c.json(await standardProcessor.run(body));
});
```

This gives you explicit control over which agent handles each request.

---

## Tutorial Steps

Each step demonstrates a core pattern for agent communication.

### Step 1: Basic Agent Calls

<TutorialStep number={1} title="Basic Agent Calls" estimatedTime="8 min">

The foundation of multi-agent systems is simple: one agent calls another. This step demonstrates the basic pattern with a coordinator that uses AI-powered sentiment analysis through a specialist agent.

<CodeFromFiles snippets={[
  { path: "/examples/training/06-agent-communication/step1-basic-agent-calls/coordinator/agent.ts", lang: "ts", title: "coordinator/agent.ts" },
  { path: "/examples/training/06-agent-communication/step1-basic-agent-calls/coordinator/route.ts", lang: "ts", title: "coordinator/route.ts" },
  { path: "/examples/training/06-agent-communication/step1-basic-agent-calls/enricher/agent.ts", lang: "ts", title: "enricher/agent.ts" }
]} />

**What this demonstrates:**
- Type-safe agent calls via `import enricher from '@agent/enricher'; enricher.run()`
- Direct imports (no context lookup needed)
- Schema validation on both input and output
- AI-powered enrichment using `generateObject` with structured schemas
- KV storage for tracking interaction history
- Processing results from another agent
- Clean separation between coordinator and specialist logic

**Try it:**
1. Start DevMode: `agentuity dev`
2. Send a POST request:
   ```bash
   curl -X POST http://localhost:3500/process \
     -H "Content-Type: application/json" \
     -d '{"text": "I love this product! It works great."}'
   ```
3. Check logs to see both agents executing
4. Notice the enriched response with AI-powered sentiment analysis and confidence scores

> **Key Insight:** Agent calls use direct imports with full type safety. Import any agent with `import agent from '@agent/name'` and call `agent.run()`. The SDK validates all inputs and outputs through schemas. Use specialist agents for AI-powered processing like the enricher's sentiment analysis.

</TutorialStep>

---

### Step 2: Sequential Workflows

<TutorialStep number={2} title="Sequential Workflows" estimatedTime="8 min">

Many workflows require processing data through multiple stages. This step shows how to chain agents together in a 2-stage pipeline: enrichment followed by summarization.

<CodeFromFiles snippets={[
  { path: "/examples/training/06-agent-communication/step2-sequential-workflows/coordinator/agent.ts", lang: "ts", title: "coordinator/agent.ts" },
  { path: "/examples/training/06-agent-communication/step2-sequential-workflows/coordinator/route.ts", lang: "ts", title: "coordinator/route.ts" }
]} />

**What this demonstrates:**
- Chaining multiple agent calls sequentially
- Passing enrichment results to the summarizer
- Building complex workflows from simple, focused agents
- Processing intermediate results before the next step
- Maintaining type safety through the entire chain

**Try it:**
1. Start DevMode
2. Send a document for processing:
   ```bash
   curl -X POST http://localhost:3500/pipeline \
     -H "Content-Type: application/json" \
     -d '{"text": "Artificial intelligence is transforming how we build software. Modern AI systems can understand context, generate code, and help developers be more productive than ever before."}'
   ```
3. Watch logs to see each agent execute in order
4. Notice how the enricher's sentiment analysis informs the summarizer's output

> **Key Insight:** Sequential workflows chain agents together. Each agent focuses on one task, making the system modular and testable. Results flow naturally from one agent to the next, with each stage building on the previous.

</TutorialStep>

---

### Step 3: Parallel Execution

<TutorialStep number={3} title="Parallel Execution" estimatedTime="8 min">

When agents don't depend on each other's results, run them in parallel for better performance. This step demonstrates concurrent AI processing with translation and summarization happening simultaneously.

<CodeFromFiles snippets={[
  { path: "/examples/training/06-agent-communication/step3-parallel-execution/aggregator/agent.ts", lang: "ts", title: "aggregator/agent.ts" },
  { path: "/examples/training/06-agent-communication/step3-parallel-execution/aggregator/route.ts", lang: "ts", title: "aggregator/route.ts" }
]} />

**What this demonstrates:**
- Running multiple agents concurrently with `Promise.all`
- Independent AI operations (translation + summarization) in parallel
- Significant performance improvements over sequential execution
- Type-safe destructuring of parallel results
- Execution time tracking to show performance gains

**Try it:**
1. Start DevMode
2. Send text for parallel processing:
   ```bash
   curl -X POST http://localhost:3500/process \
     -H "Content-Type: application/json" \
     -d '{"text": "Artificial intelligence is revolutionizing software development. AI agents can now collaborate, each specializing in different tasks to solve complex problems efficiently.", "targetLanguage": "Spanish"}'
   ```
3. Check execution time in logs - much faster than sequential processing
4. See combined results: original text, translation, and summary

> **Key Insight:** Parallel execution dramatically improves performance when agents are independent. Use `Promise.all` to run multiple agent calls concurrently. Translation and summarization are perfect examples - they can both analyze the same input independently.

</TutorialStep>

---

### Step 4: Smart Routing with Structured Responses

<TutorialStep number={4} title="Smart Routing with Structured Responses" estimatedTime="10 min">

Advanced systems need intelligent routing - using AI to decide which agent should handle each request. Structured responses (validated schemas) transform unpredictable AI output into reliable routing decisions. This step shows a router that directs requests to either support or sales specialists.

<CodeFromFiles snippets={[
  { path: "/examples/training/06-agent-communication/step4-smart-routing/router/agent.ts", lang: "ts", title: "router/agent.ts" },
  { path: "/examples/training/06-agent-communication/step4-smart-routing/router/route.ts", lang: "ts", title: "router/route.ts" },
  { path: "/examples/training/06-agent-communication/step4-smart-routing/support-agent/agent.ts", lang: "ts", title: "support-agent/agent.ts (example specialist)" }
]} />

**What this demonstrates:**
- AI-powered routing with structured output schemas
- Confidence thresholds for fallback handling
- Type-safe routing decisions validated by Zod
- AI-powered specialist agents (support agent uses AI for response generation)
- KV storage for tracking support tickets
- Severity assessment and suggested actions
- Transforming unpredictable AI output into reliable data structures
- Building production-ready orchestration systems

**Try it:**
1. Start DevMode
2. Send different request types:
   ```bash
   # Support request
   curl -X POST http://localhost:3500/route \
     -H "Content-Type: application/json" \
     -d '{"message": "I cannot access my account and keep getting error 403"}'

   # Sales inquiry
   curl -X POST http://localhost:3500/route \
     -H "Content-Type: application/json" \
     -d '{"message": "What are your enterprise pricing plans?"}'
   ```
3. Check logs to see routing decisions with confidence scores
4. Notice the support agent's AI-generated response with severity and suggested actions
5. Try ambiguous requests to see fallback handling

> **Key Insight:** Structured responses transform unreliable AI outputs into type-safe data structures. Define schemas with Zod, validate AI decisions, and build reliable routing logic on validated data. Specialist agents can also use AI to provide context-aware responses, as shown in the support agent.

</TutorialStep>

---

## Lab: Multi-Agent System

TODO: add concierge lab example
---

## Key Takeaways

By the end of this module, you should understand:

1. **Type-Safe Agent Calls:**
   - Direct access via `c.agent.agentName.run(input)`
   - Auto-discovery of all agents in your project
   - Full TypeScript inference with schemas
   - Automatic input/output validation
   - Using AI SDK (`generateObject`) in specialist agents

2. **Sequential Workflows:**
   - Chain agents together for multi-stage processing
   - Pass results between agents (enrichment â†’ summarization)
   - Build complex workflows from simple, focused components
   - Maintain type safety through the entire chain

3. **Parallel Execution:**
   - Run independent agents concurrently with `Promise.all`
   - Execute different AI operations simultaneously (translation + summarization)
   - Improve performance significantly over sequential processing
   - Track execution time to measure performance gains

4. **Smart Routing:**
   - Use AI with structured schemas for routing decisions
   - Validate AI output with Zod for reliability
   - Implement confidence thresholds and fallback handling
   - Build AI-powered specialist agents with context-aware responses
   - Use KV storage to track interactions and state
   - Build production-ready orchestration systems

Multi-agent systems enable specialization, scalability, and modularity. The SDK provides type-safe communication with automatic validation, making it simple to build complex orchestration patterns. Combine with AI SDK and KV storage for stateful multi-agent applications.

---

## What's Next?

**Module 7: Observability, Evals, & Validation** - Learn how to monitor agent execution, implement quality checks, and ensure your multi-agent systems behave reliably in production.

For more details on agent communication patterns and advanced orchestration, see:
- [Agent Communication Guide](/v1/Guides/agent-communication)
