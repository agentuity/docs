---
title: "Module 5: Storage APIs"
description: Manual storage control for caching, semantic search, and file management
---

Agents need more than automatic state management. They need explicit control over data persistence, custom TTL, and the ability to share data across multiple agents and sessions. This module teaches you how to use the three Agentuity storage APIs: key-value, vector, and object storage.

## Storage vs State

Module 4 taught you how to use **managed state scopes** (`ctx.state`, `ctx.thread.state`, `ctx.session.state`) with automatic lifecycle handling. This module teaches you how to use **manual storage APIs** for explicit control.

| Aspect | State (Module 4) | Storage (Module 5) |
|--------|------------------|-------------------|
| **Lifecycle** | Automatic (Agentuity manages) | Manual (you control) |
| **Scope** | Request/thread/session | Custom buckets and keys |
| **TTL** | Fixed (request, 1 hour, session) | Custom (any duration) |
| **Sharing** | Limited to same session/thread | Shared across agents and sessions |
| **Use Case** | Scoped memory patterns | Persistent data, caching, search |

**When to use state:**
- Request-scoped calculations
- Conversation context (up to 1 hour)
- User preferences within a session

**When to use storage:**
- Custom TTL requirements (5 minutes, 24 hours, permanent)
- Data shared across multiple agents
- Semantic search and knowledge bases
- File storage and media
- Persistence beyond session lifetime

**Core question:** *"How do I store, search, and retrieve different types of data?"*

## Understanding Storage Types

The SDK provides three storage APIs, each optimized for different data patterns:

### Key-Value Storage (`ctx.kv`)
Fast exact-match lookups for structured data. Use TTL for auto-expiring cache, or omit TTL for permanent storage.

**Use cases:**
- API response caching (with TTL)
- User preferences (without TTL)
- Feature flags and configuration
- Rate limiting counters

### Vector Storage (`ctx.vector`)
Semantic similarity search using embeddings. Finds information by meaning rather than keywords.

**Use cases:**
- Knowledge bases and documentation search
- Semantic search ("find similar products")
- RAG (Retrieval-Augmented Generation) systems
- Long-term agent memory across sessions

### Object Storage (Bun S3)
Binary file storage with public URL generation for documents, images, and media. Use `import { s3 } from "bun"` for S3-compatible object storage.

**Use cases:**
- User-uploaded files
- Generated reports and exports
- Images and media files
- Large datasets and backups

---

## Tutorial Steps

Each step below focuses on one storage API with simple, runnable code you can test immediately.

### Step 1: KV Basics with TTL

<TutorialStep number={1} title="KV Basics with TTL" estimatedTime="7 min">

Key-value storage with TTL (time-to-live) provides automatic cache expiration. Set a TTL to have data automatically deleted after a specified duration, preventing manual cleanup and storage bloat.

<CodeFromFiles snippets={[
  { path: "/examples/training/05-storage-apis/step1-kv-basics/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/05-storage-apis/step1-kv-basics/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Caching pattern: check cache first, compute on miss
- KV storage with custom TTL (5 minutes)
- Cache hit vs miss handling
- Automatic data deserialization (`result.data` is already parsed)

**Try it:**
1. Start DevMode: `agentuity dev`
2. First request (cache miss):
   ```bash
   curl -X POST http://localhost:3500/query \
     -H "Content-Type: application/json" \
     -d '{"query": "what is agentuity"}'
   ```
3. Expected response:
   ```json
   {
     "result": "Computed result for: what is agentuity",
     "cached": false,
     "cacheKey": "query:what-is-agentuity"
   }
   ```
4. Second request within 5 minutes (cache hit):
   ```bash
   curl -X POST http://localhost:3500/query \
     -H "Content-Type: application/json" \
     -d '{"query": "what is agentuity"}'
   ```
5. Expected response:
   ```json
   {
     "result": "Computed result for: what is agentuity",
     "cached": true,
     "cacheKey": "query:what-is-agentuity"
   }
   ```
6. Check logs to see cache hit/miss behavior

> **Key Insight:** TTL-based caching prevents manual cleanup and storage costs. Data automatically expires after the specified duration.

</TutorialStep>

---

### Step 2: KV Persistent Storage

<TutorialStep number={2} title="KV Persistent Storage" estimatedTime="7 min">

Omit the TTL parameter to make data persist indefinitely until explicitly deleted. Use for user profiles, settings, and application state that should survive restarts.

<CodeFromFiles snippets={[
  { path: "/examples/training/05-storage-apis/step2-kv-persistent/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/05-storage-apis/step2-kv-persistent/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Persistent storage by omitting TTL parameter
- Default values for new users
- Partial updates (merge with existing data)
- Schema validation with Zod

**Try it:**
1. Get preferences (creates defaults):
   ```bash
   curl http://localhost:3500/users/user123/settings
   ```
2. Expected response:
   ```json
   {
     "preferences": {
       "theme": "light",
       "language": "en",
       "notifications": true
     },
     "source": "default",
     "updated": false
   }
   ```
3. Update preferences:
   ```bash
   curl -X POST http://localhost:3500/users/user123/settings \
     -H "Content-Type: application/json" \
     -d '{"theme": "dark", "notifications": false}'
   ```
4. Get preferences again - changes persist:
   ```bash
   curl http://localhost:3500/users/user123/settings
   ```
5. Restart DevMode - preferences still there (no TTL = permanent)

> **Key Insight:** No TTL means data persists forever until explicitly deleted. Use for user profiles, settings, and permanent application state.

</TutorialStep>

---

### Step 3: Vector Basics with Variadic Upsert

<TutorialStep number={3} title="Vector Basics with Variadic Upsert" estimatedTime="8 min">

Vector storage enables semantic search—finding information by meaning rather than keywords. Documents are automatically converted to embeddings for similarity matching.

**Important API Change:** The upsert operation uses variadic parameters, allowing you to pass multiple documents in a single call.

<CodeFromFiles snippets={[
  { path: "/examples/training/05-storage-apis/step3-vector-basics/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/05-storage-apis/step3-vector-basics/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- **Variadic upsert pattern**: `await ctx.vector.upsert(bucket, ...array)`
- Two approaches: spread array (dynamic) or individual parameters (static)
- Semantic search with query text and similarity threshold
- Automatic embedding generation from document text
- Similarity scores (0-1, where 1 = perfect match)

**Variadic Upsert Pattern Explained:**

```typescript
// Option 1: Spread array (recommended for dynamic data)
const documents = [{ key: 'doc1', document: 'text', metadata: {...} }, ...];
await ctx.vector.upsert(bucket, ...documents);

// Option 2: Individual parameters (good for static data)
await ctx.vector.upsert(
  bucket,
  { key: 'doc1', document: 'text1', metadata: {...} },
  { key: 'doc2', document: 'text2', metadata: {...} }
);

// Both are equivalent - choose based on your use case
```

**Try it:**
1. Search for "What is Agentuity?":
   ```bash
   curl -X POST http://localhost:3500/search \
     -H "Content-Type: application/json" \
     -d '{"query": "What is Agentuity?"}'
   ```
2. Expected response (semantic matches):
   ```json
   {
     "query": "What is Agentuity?",
     "resultsFound": 3,
     "results": [
       {
         "key": "fact-1",
         "similarity": 0.89,
         "category": "platform"
       },
       ...
     ]
   }
   ```
3. Try different queries:
   - "How does storage work?" → finds storage-related facts
   - "semantic search" → finds vector storage explanation
4. Notice similarity scores vary by relevance

> **Key Insight:** Vector search finds meaning, not keywords. Use the variadic upsert pattern (`...array`) for efficient bulk inserts.

</TutorialStep>

---

### Step 4: Vector Filtering with Metadata

<TutorialStep number={4} title="Vector Filtering with Metadata" estimatedTime="7 min">

Combine semantic similarity with structured metadata filters to narrow results by category, user, status, or any metadata field.

<CodeFromFiles snippets={[
  { path: "/examples/training/05-storage-apis/step4-vector-filtering/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/05-storage-apis/step4-vector-filtering/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Adding metadata to vectors (category, price, inStock, etc.)
- Filtering search results with `metadata` parameter
- Metadata filters use AND logic (all conditions must match)
- Lower similarity threshold when using strict filters
- Combining semantic search with business rules

**Try it:**
1. Search all products:
   ```bash
   curl -X POST http://localhost:3500/products/search \
     -H "Content-Type: application/json" \
     -d '{"query": "comfortable workspace"}'
   ```
2. Filter by category (furniture only):
   ```bash
   curl -X POST http://localhost:3500/products/search \
     -H "Content-Type: application/json" \
     -d '{"query": "comfortable workspace", "category": "furniture"}'
   ```
3. Filter by stock status (in-stock only):
   ```bash
   curl -X POST http://localhost:3500/products/search \
     -H "Content-Type: application/json" \
     -d '{"query": "high performance", "category": "electronics", "inStock": true}'
   ```
4. Compare results with and without filters

> **Key Insight:** Metadata filtering is exact-match, not fuzzy. Use it to combine semantic search with business rules like availability, category, or user permissions.

</TutorialStep>

---

### Step 5: Object Storage for Files

<TutorialStep number={5} title="Object Storage for Files" estimatedTime="6 min">

Files and media need different storage than structured data. Object storage handles binary content and provides shareable public URLs with automatic expiration.

<CodeFromFiles snippets={[
  { path: "/examples/training/05-storage-apis/step5-object-storage/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/05-storage-apis/step5-object-storage/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Storing text/binary files with Bun S3
- Retrieving files with `s3.file(path)`
- Creating temporary public URLs with `s3.presign()` (configurable expiration)
- File cleanup with `file.delete()`

**Try it:**
1. Upload and retrieve a file:
   ```bash
   curl -X POST http://localhost:3500/files/upload \
     -H "Content-Type: application/json" \
     -d '{"content": "Hello from object storage!", "filename": "demo.txt"}'
   ```
2. Expected response:
   ```json
   {
     "message": "File stored, retrieved, and public URL created",
     "filename": "demo.txt",
     "contentLength": 27,
     "publicUrl": "https://...",
     "urlExpiresIn": "1 hour"
   }
   ```
3. Access the public URL in browser (works for 1 hour)
4. Try uploading different content types

> **Key Insight:** Public URLs expire automatically, perfect for temporary file sharing without permanent public access.

</TutorialStep>

---

## Lab Project

TODO: translate docs Q&A (RAG) example here

---

## Key Takeaways

By the end of this module, you should understand:

1. **Storage vs State:**
   - State (Module 4) = Managed scopes with automatic lifecycle
   - Storage (Module 5) = Manual control with custom TTL and sharing

2. **Three Storage APIs:**
   - KV = Fast exact-match lookups, optional TTL
   - Vector = Semantic search by meaning
   - Object = Binary files and public URLs

3. **KV Storage Patterns:**
   - With TTL for auto-expiring cache
   - Without TTL for permanent data
   - Automatic deserialization of stored values

4. **Vector Storage Patterns:**
   - Variadic upsert: `await ctx.vector.upsert(bucket, ...documents)`
   - Semantic search with similarity thresholds
   - Metadata filtering for targeted results

5. **When to Use Each:**
   - KV → Caching, preferences, configuration
   - Vector → Knowledge bases, semantic search, RAG
   - Object → Files, media, large binary data

Choose the right storage API for your data type and access pattern. Combine multiple storage types for complex use cases like RAG systems.

---

## What's Next?

**Module 6: Agent Collaboration** - Learn import-based agent calling for multi-agent workflows, parallel execution, and orchestration patterns.

For more details on storage APIs, see:
- [Key-Value Storage Guide](/v1/Guides/key-value-storage)
- [Vector Storage Guide](/v1/Guides/vector-storage)
- [Object Storage Guide](/v1/Guides/object-storage)
