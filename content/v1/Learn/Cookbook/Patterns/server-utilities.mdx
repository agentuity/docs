---
title: SDK Utilities for External Apps
description: Use storage, logging, error handling, and schema utilities from external backends like Next.js or Express
---

Use `@agentuity/server` and `@agentuity/core` utilities in external apps, scripts, or backends that integrate with Agentuity.

## Storage Access via HTTP Routes

Expose KV, Vector, or Stream services through HTTP routes. External backends call these routes to read and write data.

```typescript title="src/api/sessions/route.ts"
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

interface ChatSession {
  messages: Array<{ role: string; content: string }>;
  createdAt: string;
  updatedAt: string;
}

// Get a session by ID
router.get('/:id', async (c) => {
  const sessionId = c.req.param('id');
  const result = await c.var.kv.get<ChatSession>('sessions', sessionId); // [!code highlight]

  if (!result.exists) {
    return c.json({ error: 'Session not found' }, 404);
  }

  return c.json(result.data);
});

// Create or update a session
router.post('/:id', async (c) => {
  const sessionId = c.req.param('id');
  const body = await c.req.json<Partial<ChatSession>>();

  const existing = await c.var.kv.get<ChatSession>('sessions', sessionId);
  const session: ChatSession = existing.exists
    ? { ...existing.data, ...body, updatedAt: new Date().toISOString() }
    : { messages: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), ...body };

  await c.var.kv.set('sessions', sessionId, session, { ttl: 86400 * 7 }); // [!code highlight]

  c.var.logger.info('Session updated', { sessionId });
  return c.json(session);
});

// Delete a session
router.delete('/:id', async (c) => {
  const sessionId = c.req.param('id');
  await c.var.kv.delete('sessions', sessionId); // [!code highlight]

  c.var.logger.info('Session deleted', { sessionId });
  return c.json({ success: true });
});

export default router;
```

### Securing Storage Routes

Add authentication middleware to protect storage endpoints:

```typescript title="src/api/sessions/route.ts"
import { createRouter, createMiddleware } from '@agentuity/runtime';

const router = createRouter();

const requireAuth = createMiddleware(async (c, next) => {
  const apiKey = c.req.header('x-api-key');

  if (!apiKey || apiKey !== process.env.STORAGE_API_KEY) {
    c.var.logger.warn('Unauthorized storage access attempt');
    return c.json({ error: 'Unauthorized' }, 401);
  }

  await next();
});

router.use('/*', requireAuth); // [!code highlight]

// Routes now require x-api-key header
router.get('/:id', async (c) => {
  // ... same as above
});

export default router;
```

### Calling from Next.js

Create a client in your Next.js app:

```typescript title="lib/agentuity-client.ts"
const AGENTUITY_URL = process.env.AGENTUITY_URL!;
const STORAGE_API_KEY = process.env.STORAGE_API_KEY!;

interface ChatSession {
  messages: Array<{ role: string; content: string }>;
  createdAt: string;
  updatedAt: string;
}

export async function getSession(sessionId: string): Promise<ChatSession | null> {
  const res = await fetch(`${AGENTUITY_URL}/api/sessions/${sessionId}`, {
    headers: { 'x-api-key': STORAGE_API_KEY },
  });

  if (res.status === 404) return null;
  if (!res.ok) throw new Error(`Failed to get session: ${res.statusText}`);

  return res.json();
}

export async function saveSession(sessionId: string, data: Partial<ChatSession>): Promise<ChatSession> {
  const res = await fetch(`${AGENTUITY_URL}/api/sessions/${sessionId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': STORAGE_API_KEY,
    },
    body: JSON.stringify(data),
  });

  if (!res.ok) throw new Error(`Failed to save session: ${res.statusText}`);
  return res.json();
}

export async function deleteSession(sessionId: string): Promise<void> {
  const res = await fetch(`${AGENTUITY_URL}/api/sessions/${sessionId}`, {
    method: 'DELETE',
    headers: { 'x-api-key': STORAGE_API_KEY },
  });

  if (!res.ok) throw new Error(`Failed to delete session: ${res.statusText}`);
}
```

Use the client in a Next.js API route:

```typescript title="app/api/chat/route.ts"
import { getSession, saveSession } from '@/lib/agentuity-client';

export async function POST(req: Request) {
  const { sessionId, message } = await req.json();

  // Load existing session from Agentuity KV
  const session = await getSession(sessionId) || { // [!code highlight]
    messages: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  session.messages.push({ role: 'user', content: message });

  // Process with your AI logic...
  const response = { role: 'assistant', content: 'Hello!' };
  session.messages.push(response);

  // Save back to Agentuity KV
  await saveSession(sessionId, session); // [!code highlight]

  return Response.json({ response: response.content });
}
```

### Vector Storage

The same pattern works for Vector and Stream storage:

```typescript title="src/api/vectors/route.ts"
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.post('/search', async (c) => {
  const { query, limit = 10 } = await c.req.json();

  const results = await c.var.vector.search('documents', { // [!code highlight]
    query,
    topK: limit,
  });

  return c.json(results);
});

router.post('/upsert', async (c) => {
  const { id, content, metadata } = await c.req.json();

  await c.var.vector.upsert('documents', [{ // [!code highlight]
    id,
    content,
    metadata,
  }]);

  return c.json({ success: true });
});

export default router;
```

<Callout type="info" title="About createAgentContext()">
`createAgentContext()` is designed for code running within the Agentuity runtime (Discord bots, CLI tools deployed alongside agents). For external backends, use the HTTP pattern above.
</Callout>

## Logging with createLogger

Create structured loggers for scripts or external services:

```typescript
import { createLogger } from '@agentuity/server';

// Create a logger with info level, no timestamps, dark color scheme
const logger = createLogger('info', false, 'dark');

logger.info('Processing request', { userId: '123' });
logger.error('Failed to connect', { error: err.message });

// Child logger with persistent context
const requestLogger = logger.child({ requestId: 'req_abc' });
requestLogger.info('Starting'); // Includes requestId in all logs
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `level` | `'trace' \| 'debug' \| 'info' \| 'warn' \| 'error'` | `'info'` | Minimum log level |
| `showTimestamp` | `boolean` | `false` | Include ISO timestamps |
| `colorScheme` | `'light' \| 'dark'` | `'dark'` | Terminal color scheme |
| `context` | `Record<string, unknown>` | `{}` | Default context for all logs |

## Safe JSON Serialization

`safeStringify` handles circular references and BigInt values that break `JSON.stringify`:

```typescript
import { safeStringify } from '@agentuity/core';

// Circular references become "[Circular]"
const obj = { name: 'Alice' };
obj.self = obj;
safeStringify(obj); // '{"name":"Alice","self":"[Circular]"}'

// BigInt converts to string
safeStringify({ id: 9007199254740991n }); // '{"id":"9007199254740991"}'

// Pretty-print with indentation
safeStringify(data, 2);
```

## Error Handling Utilities

### RichError

Enhanced errors with context and pretty printing:

```typescript
import { RichError } from '@agentuity/core';

const error = new RichError({
  message: 'Request failed',
  statusCode: 500,
  endpoint: '/api/users',
  cause: originalError,
});

error.plainArgs;     // { statusCode: 500, endpoint: '/api/users' }
error.cause;         // originalError (the cause chain)
error.prettyPrint(); // Formatted multi-line output with stack traces
error.toJSON();      // Serializable object for logging
error.toString();    // Same as prettyPrint()
```

### StructuredError

Type-safe, discriminated errors with a `_tag` for pattern matching:

```typescript
import { StructuredError, isStructuredError } from '@agentuity/core';

// Create error types
const NotFoundError = StructuredError('NotFound');
const ValidationError = StructuredError('ValidationError')<{
  field: string;
  code: string;
}>();

// With a default message (message is preset, cannot be overridden)
const UpgradeRequired = StructuredError('UpgradeRequired', 'Upgrade required to access this feature');

// Throw with context
throw new ValidationError({
  field: 'email',
  code: 'INVALID_FORMAT',
  message: 'Email format is invalid',
});

// Type-safe handling
if (isStructuredError(err) && err._tag === 'ValidationError') {
  logger.error('Validation failed', { field: err.field, code: err.code });
}
```

## Schema Conversion

Convert Zod or Agentuity schemas to JSON Schema for tooling or OpenAPI generation:

```typescript
import { toJSONSchema } from '@agentuity/server';
import { z } from 'zod';

const schema = z.object({ name: z.string(), age: z.number() });
const jsonSchema = toJSONSchema(schema);
// { type: 'object', properties: { name: { type: 'string' }, age: { type: 'number' } }, ... }
```

## Key Points

- **Routes have full access** to `c.var.kv`, `c.var.vector`, and `c.var.stream`
- **HTTP is the bridge**: External backends call routes via REST
- **Always authenticate** storage routes with API keys or other auth
- **This works for any framework**: Next.js, Express, Remix, etc.

## See Also

- [Key-Value Storage](/v1/Build/Storage/key-value): KV operations and TTL options
- [Route Middleware](/v1/Build/Routes/middleware): Authentication patterns
- [RPC Client](/v1/Build/Frontend/rpc-client): Typed client generation
