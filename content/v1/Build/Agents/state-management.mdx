---
title: Managing State
description: Request and thread state for stateful agents
---

Agentuity provides two state scopes for managing data across requests:

- **Request state** for temporary calculations within a single request
- **Thread state** for conversation context that persists across requests

## State Scopes

| Scope | Lifetime | Cleared When | Access | Example Use Case |
|-------|----------|--------------|--------|----------|
| Request | Single request | After response sent | `ctx.state` | Timing, temp calculations |
| Thread | Up to 1 hour | Expiration or `destroy()` | `ctx.thread.state` | Conversation history |

### Quick Example

```typescript
import { createAgent } from '@agentuity/runtime';
import { s } from '@agentuity/schema';

const agent = createAgent('StateDemo', {
  schema: {
    input: s.object({ message: s.string() }),
    output: s.object({
      response: s.string(),
      requestTime: s.number(),
      messageCount: s.number(),
    }),
  },
  handler: async (ctx, input) => {
    // REQUEST STATE: Cleared after this response
    ctx.state.set('startTime', Date.now());

    // THREAD STATE: Persists across requests (up to 1 hour)
    const messages = (ctx.thread.state.get('messages') as string[]) || [];
    messages.push(input.message);
    ctx.thread.state.set('messages', messages);

    const requestTime = Date.now() - (ctx.state.get('startTime') as number);

    return {
      response: `Received: ${input.message}`,
      requestTime,
      messageCount: messages.length,
    };
  },
});

export default agent;
```

## Request State

Request state (`ctx.state`) holds temporary data within a single request. It's cleared automatically after the response is sent.

```typescript
handler: async (ctx, input) => {
  // Track timing
  ctx.state.set('startTime', Date.now());

  // Process request...
  const result = await processData(input);

  // Use the timing data
  const duration = Date.now() - (ctx.state.get('startTime') as number);
  ctx.logger.info('Request completed', { durationMs: duration });

  return result;
}
```

**Use cases:** Request timing, temporary calculations, passing data between event listeners.

## Thread State

Thread state (`ctx.thread.state`) persists across multiple requests within a conversation, expiring after 1 hour of inactivity. Thread identity is managed automatically via cookies (or the `x-thread-id` header for API clients).

### Conversation Memory

```typescript
import { createAgent } from '@agentuity/runtime';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import * as v from 'valibot';

interface Message {
  role: 'user' | 'assistant';
  content: string;
}

const agent = createAgent('ConversationMemory', {
  schema: {
    input: v.object({ message: v.string() }),
    output: v.string(),
  },
  handler: async (ctx, input) => {
    // Initialize on first request
    if (!ctx.thread.state.has('messages')) {
      ctx.thread.state.set('messages', []);
      ctx.thread.state.set('turnCount', 0);
    }

    const messages = ctx.thread.state.get('messages') as Message[];
    const turnCount = ctx.thread.state.get('turnCount') as number;

    // Add user message
    messages.push({ role: 'user', content: input.message });

    // Generate response with conversation context
    const { text } = await generateText({
      model: openai('gpt-5-mini'),
      system: 'You are a helpful assistant. Reference previous messages when relevant.',
      messages,
    });

    // Update thread state
    messages.push({ role: 'assistant', content: text });
    ctx.thread.state.set('messages', messages);
    ctx.thread.state.set('turnCount', turnCount + 1);

    ctx.logger.info('Conversation turn', {
      threadId: ctx.thread.id,
      turnCount: turnCount + 1,
    });

    return text;
  },
});

export default agent;
```

### Thread Properties and Methods

```typescript
ctx.thread.id;  // Thread ID (thrd_...)
ctx.thread.state.set('key', value);
ctx.thread.state.get('key');
ctx.thread.state.has('key');
ctx.thread.state.delete('key');

// Reset the conversation
await ctx.thread.destroy();
```

### Resetting a Conversation

Call `ctx.thread.destroy()` to clear all thread state and start fresh:

```typescript
handler: async (ctx, input) => {
  if (input.command === 'reset') {
    await ctx.thread.destroy();
    return 'Conversation reset. Thread state cleared.';
  }

  // Continue conversation...
}
```

## ctx.state vs ctx.session.state

Both `ctx.state` and `ctx.session.state` are request-scoped and reset after each request. The difference:

- **`ctx.state`**: General request state, accessible in agent event listeners and evals
- **`ctx.session.state`**: Accessible via `session` in completion event callbacks

For most use cases, use `ctx.state`. Use `ctx.session.state` only when you need data in session completion events. See [Events & Lifecycle](/v1/Build/Agents/events-lifecycle) for more on event handlers.

<Callout type="info" title="Persistent Data">
Neither `ctx.state` nor `ctx.session.state` persist across requests. For data that should survive across requests, use `ctx.thread.state` (up to 1 hour) or [KV storage](/v1/Build/Storage/key-value) (durable).
</Callout>

## Persisting to Storage

In-memory state is lost on server restart. For durability, combine state management with KV storage:

### Load → Cache → Save Pattern

```typescript
import { createAgent } from '@agentuity/runtime';
import { streamText } from 'ai';
import { openai } from '@ai-sdk/openai';
import * as v from 'valibot';

type Message = { role: 'user' | 'assistant'; content: string };

const agent = createAgent('PersistentChat', {
  schema: {
    input: v.object({ message: v.string() }),
    stream: true,
  },
  handler: async (ctx, input) => {
    const key = `chat_${ctx.thread.id}`;
    let messages: Message[] = [];

    // Load from KV on first access in this thread
    if (!ctx.thread.state.has('loaded')) {
      const result = await ctx.kv.get<Message[]>('conversations', key);
      if (result.exists) {
        messages = result.data;
        ctx.logger.info('Loaded conversation from KV', { messageCount: messages.length });
      }
      ctx.thread.state.set('messages', messages);
      ctx.thread.state.set('loaded', true);
    } else {
      messages = ctx.thread.state.get('messages') as Message[];
    }

    // Add user message
    messages.push({ role: 'user', content: input.message });

    // Stream response
    const result = streamText({
      model: openai('gpt-5-mini'),
      messages,
    });

    // Save in background (non-blocking)
    ctx.waitUntil(async () => {
      const fullText = await result.text;
      messages.push({ role: 'assistant', content: fullText });

      // Keep last 20 messages to bound state size
      const recentMessages = messages.slice(-20);
      ctx.thread.state.set('messages', recentMessages);

      // Persist to KV
      await ctx.kv.set('conversations', key, recentMessages, {
        ttl: 86400, // 24 hours
      });
    });

    return result.textStream;
  },
});

export default agent;
```

**Key points:**
- Load from KV once per thread, cache in thread state
- Use `ctx.waitUntil()` for non-blocking saves
- Bound state size to prevent unbounded growth

## Thread Lifecycle

Threads expire after 1 hour of inactivity. Use the `destroyed` event to archive data before expiration:

```typescript
ctx.thread.addEventListener('destroyed', async (eventName, thread) => {
  const messages = thread.state.get('messages') as string[] || [];
  if (messages.length > 0) {
    await ctx.kv.set('archives', thread.id, {
      messages,
      endedAt: new Date().toISOString(),
    }, { ttl: 604800 });
  }
});
```

Similarly, track when sessions complete with `ctx.session.addEventListener('completed', ...)`.

For app-level monitoring of all threads and sessions, see [Events & Lifecycle](/v1/Build/Agents/events-lifecycle).

## Thread vs Session IDs

| ID | Format | Lifetime | Purpose |
|----|--------|----------|---------|
| Thread ID | `thrd_<hex>` | Up to 1 hour (shared across requests) | Group related requests into conversations |
| Session ID | `sess_<hex>` | Single request (unique per call) | Request tracing and analytics |

```typescript
handler: async (ctx, input) => {
  ctx.logger.info('Request received', {
    threadId: ctx.thread.id,    // Same across conversation
    sessionId: ctx.sessionId,    // Unique per request
  });

  return { threadId: ctx.thread.id, sessionId: ctx.sessionId };
}
```

## Advanced: Custom Thread IDs

By default, thread IDs are generated automatically and managed via signed cookies. For advanced use cases, you can provide custom thread ID logic using a `ThreadIDProvider`.

**Use cases:**
- Integrating with external identity systems
- Multi-tenant applications where threads should be scoped to users
- Custom conversation management tied to your domain model

### ThreadIDProvider Interface

```typescript
import type { Context } from 'hono';
import type { Env, AppState } from '@agentuity/runtime';

interface ThreadIDProvider {
  getThreadId(appState: AppState, ctx: Context<Env>): string | Promise<string>;
}
```

### Thread ID Format Requirements

Custom thread IDs must follow these rules:

| Requirement | Value |
|-------------|-------|
| Prefix | Must start with `thrd_` |
| Length | 32-64 characters total |
| Characters | After prefix: `[a-zA-Z0-9]` only |

```typescript
// Valid thread IDs
'thrd_abc123def456789012345678901'     // 32 chars - minimum
'thrd_' + 'a'.repeat(59)                // 64 chars - maximum

// Invalid thread IDs
'thrd_abc'                              // Too short
'thrd_abc-def-123'                      // Dashes not allowed
'thread_abc123'                         // Wrong prefix
```

### Custom Provider Example

Create a provider that generates deterministic thread IDs based on authenticated users:

```typescript
import { createApp, getThreadProvider } from '@agentuity/runtime';
import type { ThreadIDProvider } from '@agentuity/runtime';

const userThreadProvider: ThreadIDProvider = {
  getThreadId: async (appState, ctx) => {
    const userId = ctx.req.header('x-user-id');

    if (userId) {
      // Create deterministic thread ID from user ID
      const data = new TextEncoder().encode(userId);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hex = Array.from(new Uint8Array(hashBuffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('')
        .slice(0, 27);
      return `thrd_${hex}`;
    }

    // Fall back to random ID for unauthenticated requests
    const arr = new Uint8Array(16);
    crypto.getRandomValues(arr);
    return `thrd_${Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('')}`;
  }
};

await createApp({
  setup: () => {
    getThreadProvider().setThreadIDProvider(userThreadProvider);
    return {};
  }
});
```

### Default Thread ID Behavior

The built-in `DefaultThreadIDProvider` handles thread IDs automatically:

1. **Check header**: Looks for signed `x-thread-id` header
2. **Check cookie**: Falls back to signed `atid` cookie
3. **Generate new**: Creates a new random thread ID if neither exists
4. **Persist**: Sets both the response header and cookie for future requests

The signing uses `AGENTUITY_SDK_KEY` (or defaults to `'agentuity'` in development) with HMAC SHA-256 to prevent tampering.

### Client-Side Thread Persistence

When building frontends, you can maintain thread continuity by storing and sending the thread ID:

```typescript
// Client-side: store thread ID from response header
const response = await fetch('/api/chat', { method: 'POST', body: message });
const threadId = response.headers.get('x-thread-id');
localStorage.setItem('threadId', threadId);

// Subsequent requests: send thread ID header
const nextResponse = await fetch('/api/chat', {
  method: 'POST',
  headers: { 'x-thread-id': localStorage.getItem('threadId') },
  body: nextMessage
});
```

<Callout type="warning" title="Signed Headers Required">
The `x-thread-id` header must include the signature (format: `threadId;signature`). Use the exact value from the response header. Unsigned or tampered thread IDs are rejected.
</Callout>

## State Size Limits

<Callout type="warning" title="1MB State Limit">
Thread and session state are limited to **1MB** after JSON serialization. Values that exceed this limit are truncated with a warning. Non-JSON-serializable values (functions, circular references) are silently dropped.
</Callout>

To stay within limits:
- Store large data in [KV storage](/v1/Build/Storage/key-value) instead of state
- Keep only recent messages (e.g., last 20-50)
- Store IDs or references rather than full objects

## Best Practices

- **Use the right scope**: `ctx.state` for request-scoped data, `ctx.thread.state` for conversations
- **Keep state bounded**: Limit conversation history (e.g., last 20-50 messages)
- **Persist important data**: Don't rely on state for data that must survive restarts
- **Clean up resources**: Use `destroyed` event to save or archive data
- **Cache strategically**: Load from KV once, cache in thread state, save on completion
- **Watch state size**: Stay under 1MB to avoid truncation

```typescript
// Good: Bounded conversation history
const messages = ctx.thread.state.get('messages') as Message[];
if (messages.length > 50) {
  const archived = messages.slice(0, -50);
  ctx.waitUntil(async () => {
    await ctx.kv.set('archives', `${ctx.thread.id}_${Date.now()}`, archived);
  });
  ctx.thread.state.set('messages', messages.slice(-50));
}
```

## Next Steps

- [Key-Value Storage](/v1/Build/Storage/key-value): Durable data persistence with namespaces and TTL
- [Calling Other Agents](/v1/Build/Agents/calling-other-agents): Share state between agents in workflows
- [Events & Lifecycle](/v1/Build/Agents/events-lifecycle): Monitor agent execution and cleanup
