---
title: Creating Subagents
description: Organize related agents into parent-child hierarchies
---

Group related agents under a parent to create hierarchical organizations. Subagents share context with their parent, inherit route paths, and can access their parent via `ctx.parent`.

## When to Use Subagents

| Scenario | Use Subagents | Use Separate Agents |
|----------|---------------|---------------------|
| Related domain operations | Team members, tasks | User auth, payments |
| Shared validation needed | Parent validates once | Each validates independently |
| Hierarchical API structure | `/team/members`, `/team/tasks` | `/users`, `/orders` |
| Different team ownership | Same team | Different teams |
| Testing isolation | Moderate coupling | Full independence |

**Use subagents when:**
- Operations belong to the same domain (e.g., team/members, team/tasks)
- Parent needs to provide shared validation or configuration
- You want hierarchical route paths

**Use separate agents when:**
- Domains are independent
- Agents may be called from many different contexts
- Teams maintain different parts of the system

## File Structure

Create subagents by placing agent files in subdirectories of the parent:

```
src/agents/
└── team/                   # Parent agent
    ├── agent.ts            # Parent logic
    ├── route.ts            # Parent routes (/team)
    ├── members/            # Subagent
    │   ├── agent.ts        # Subagent logic
    │   └── route.ts        # Subagent routes (/team/members)
    └── tasks/              # Subagent
        ├── agent.ts
        └── route.ts        # Routes at /team/tasks
```

**Naming convention:**
- Parent agent: `team`
- Subagent names: `team.members`, `team.tasks`
- Access via: `ctx.agent.team.members.run()`

<Callout type="warning" title="One Level Only">
Only one level of nesting is supported. Grandchildren (`team/members/admins/`) are not allowed. If you need deeper organization, create additional subagents at the same level.
</Callout>

## Creating a Parent Agent

Parent agents coordinate subagents and provide shared logic:

```typescript
// team/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  metadata: {
    name: 'Team Agent',
    description: 'Coordinates team operations',
  },
  schema: {
    input: z.object({
      action: z.enum(['info', 'stats']),
    }),
    output: z.object({
      message: z.string(),
      memberCount: z.number().optional(),
      taskCount: z.number().optional(),
    }),
  },
  handler: async (ctx, input) => {
    if (input.action === 'info') {
      return { message: 'Team management system' };
    }

    // Coordinate subagents in parallel
    const [members, tasks] = await Promise.all([
      ctx.agent.team.members.run({ action: 'count' }),
      ctx.agent.team.tasks.run({ action: 'count' }),
    ]);

    return {
      message: 'Team statistics',
      memberCount: members.count,
      taskCount: tasks.count,
    };
  },
});

export default agent;
```

## Creating Subagents

Subagents are regular agents in subdirectories:

```typescript
// team/members/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  metadata: {
    name: 'Members Subagent',
    description: 'Manages team members',
  },
  schema: {
    input: z.object({
      action: z.enum(['list', 'add', 'remove', 'count']),
      name: z.string().optional(),
    }),
    output: z.object({
      members: z.array(z.string()),
      count: z.number().optional(),
    }),
  },
  handler: async (ctx, input) => {
    const stored = await ctx.kv.get<string[]>('team', 'members');
    let members: string[] = stored.exists ? stored.data : [];

    switch (input.action) {
      case 'add':
        if (input.name && !members.includes(input.name)) {
          members.push(input.name);
          await ctx.kv.set('team', 'members', members);
        }
        break;

      case 'remove':
        if (input.name) {
          members = members.filter((m) => m !== input.name);
          await ctx.kv.set('team', 'members', members);
        }
        break;

      case 'count':
        return { members, count: members.length };
    }

    return { members };
  },
});

export default agent;
```

The agent name automatically becomes `team.members` based on the directory structure.

## Accessing Subagents

Access subagents using dot notation on `ctx.agent`:

```typescript
// From any route or agent
const router = createRouter();

router.get('/summary', async (c) => {
  // Call subagents in parallel
  const [members, tasks] = await Promise.all([
    c.agent.team.members.run({ action: 'list' }),
    c.agent.team.tasks.run({ action: 'list' }),
  ]);

  return c.json({
    memberCount: members.members.length,
    taskCount: tasks.tasks.length,
  });
});
```

**Access siblings from a subagent:**

```typescript
// From team/members/agent.ts
handler: async (ctx, input) => {
  // Access sibling via full path (not ctx.sibling)
  const tasks = await ctx.agent.team.tasks.run({ action: 'list' });
  return { members: [], relatedTasks: tasks.tasks };
}
```

## Parent Context Access

Subagents can call their parent via `ctx.parent`:

```typescript
// team/members/agent.ts
const agent = createAgent({
  handler: async (ctx, input) => {
    let parentInfo: string | undefined;

    // ctx.parent is only available in subagents
    if (ctx.parent) {
      const result = await ctx.parent.run({ action: 'info' });
      parentInfo = result.message;

      ctx.logger.info('Accessed parent', {
        parentMessage: parentInfo,
        currentAgent: ctx.agentName, // "team.members"
      });
    }

    return { members: [], parentInfo };
  },
});
```

<Callout type="info" title="Check Before Calling">
Always check `if (ctx.parent)` before calling. The property is `undefined` for top-level agents.
</Callout>

### Shared Validation Pattern

Use the parent for centralized validation:

```typescript
// team/agent.ts - Parent validates permissions
const teamAgent = createAgent({
  schema: {
    input: z.object({
      userId: z.string(),
      teamId: z.string(),
      requiredRole: z.enum(['member', 'admin']).optional(),
    }),
    output: z.object({
      authorized: z.boolean(),
      userRole: z.string(),
    }),
  },
  handler: async (ctx, input) => {
    const membership = await ctx.kv.get(
      'memberships',
      `${input.teamId}:${input.userId}`
    );

    if (!membership.exists) {
      throw new Error('User is not a member of this team');
    }

    const role = membership.data.role;

    // Check role if required
    if (input.requiredRole) {
      const hierarchy = { member: 1, admin: 2 };
      if (hierarchy[role] < hierarchy[input.requiredRole]) {
        throw new Error(`Requires ${input.requiredRole} role`);
      }
    }

    return { authorized: true, userRole: role };
  },
});

// team/members/agent.ts - Subagent uses parent validation
const membersAgent = createAgent({
  handler: async (ctx, input) => {
    // Validate admin access through parent
    if (ctx.parent) {
      await ctx.parent.run({
        userId: input.userId,
        teamId: input.teamId,
        requiredRole: 'admin',
      });
    }

    // Admin-only operation
    const members = await ctx.kv.get<string[]>('members', input.teamId);
    return { members: members.data || [] };
  },
});
```

Validation errors propagate to the caller automatically.

## Route Organization

Subagent routes inherit the parent path:

```
Parent routes:    /team, /team/stats
Subagent routes:  /team/members, /team/members/add
                  /team/tasks, /team/tasks/create
```

### Subagent Route Example

```typescript
// team/members/route.ts
import { createRouter } from '@agentuity/runtime';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';

const router = createRouter();

// GET /team/members
router.get('/', async (c) => {
  const result = await c.agent.team.members.run({ action: 'list' });
  return c.json(result);
});

// POST /team/members/add
router.post(
  '/add',
  zValidator('json', z.object({ name: z.string() })),
  async (c) => {
    const data = c.req.valid('json');
    const result = await c.agent.team.members.run({
      action: 'add',
      name: data.name,
    });
    return c.json(result);
  }
);

export default router;
```

### Middleware Cascade

Middleware on parent routes applies to all subagent routes:

```typescript
// team/route.ts
const router = createRouter();

// Auth middleware applies to /team/* including /team/members/*
router.use('/*', async (c, next) => {
  const token = c.req.header('Authorization');
  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401);
  }
  await next();
});

router.get('/', async (c) => {
  const result = await c.agent.team.run({ action: 'info' });
  return c.json(result);
});

export default router;
```

## Best Practices

### Parent Coordinates, Children Execute

```typescript
// Good: Parent coordinates
const teamAgent = createAgent({
  handler: async (ctx, input) => {
    const [members, tasks] = await Promise.all([
      ctx.agent.team.members.run({ action: 'count' }),
      ctx.agent.team.tasks.run({ action: 'count' }),
    ]);
    return { memberCount: members.count, taskCount: tasks.count };
  },
});

// Avoid: Parent implements domain logic directly
const teamAgent = createAgent({
  handler: async (ctx, input) => {
    const members = await ctx.kv.get('members', 'list');
    return { count: members.data.length }; // Should delegate to subagent
  },
});
```

### Keep Subagents Independent

- Minimize dependencies on parent
- Use parent for validation, not core logic
- Each subagent should have a clear, single responsibility

### Cache Parent Results

If calling parent multiple times, cache the result:

```typescript
handler: async (ctx, input) => {
  // Call once, use multiple times
  const parentData = ctx.parent
    ? await ctx.parent.run({ teamId: input.teamId })
    : null;

  // Use parentData throughout handler
  return { processed: true };
}
```

### Avoid Circular Calls

Don't create infinite loops between parent and child:

```typescript
// Parent calls child
const parent = createAgent({
  handler: async (ctx, input) => {
    return await ctx.agent.parent.child.run(input);
  },
});

// Child calls parent - creates infinite loop!
const child = createAgent({
  handler: async (ctx, input) => {
    if (ctx.parent) {
      return await ctx.parent.run(input); // Loops back to parent
    }
  },
});
```

## Next Steps

- [Calling Other Agents](/Build/Agents/calling-other-agents): Communication patterns between agents
- [HTTP Routes](/Build/Routes-Triggers/http-routes): Complete routing patterns and middleware
- [State Management](/Build/Agents/state-management): Share data between parent and subagents
