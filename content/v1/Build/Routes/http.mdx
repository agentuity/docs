---
title: Creating HTTP Routes
description: Define GET, POST, and other HTTP endpoints with createRouter()
---

Routes define how your application responds to HTTP requests. Built on [Hono](https://hono.dev), the router provides a familiar Express-like API with full TypeScript support.

<Callout type="info" title="Works in agents and APIs">
These examples show agent patterns, but the same code works in standalone API routes (`src/apis/*/route.ts`).
</Callout>

## Basic Routes

Create routes using `createRouter()`:

```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.get('/', async (c) => {
  return c.json({ status: 'healthy' });
});

router.post('/process', async (c) => {
  const body = await c.req.json();
  return c.json({ received: body });
});

export default router;
```

<Callout type="info" title="Automatic Response Conversion">
Return values are automatically converted: `string` → text response, `object` → JSON, `ReadableStream` → streamed response. You can also use explicit methods (`c.json()`, `c.text()`) for more control.
</Callout>

## HTTP Methods

The router supports all standard HTTP methods:

```typescript
router.get('/items', handler);        // Read
router.post('/items', handler);       // Create
router.put('/items/:id', handler);    // Replace
router.patch('/items/:id', handler);  // Update
router.delete('/items/:id', handler); // Delete
```

## Route Parameters

Capture URL segments with `:paramName`:

```typescript
router.get('/users/:id', async (c) => {
  const userId = c.req.param('id');
  return c.json({ userId });
});

router.get('/posts/:year/:month/:slug', async (c) => {
  const { year, month, slug } = c.req.param();
  return c.json({ year, month, slug });
});
```

### Wildcard Parameters

For paths with variable depth, use regex patterns:

```typescript
router.get('/files/:bucket/:key{.*}', async (c) => {
  const bucket = c.req.param('bucket');
  const key = c.req.param('key'); // Captures "path/to/file.txt"
  return c.json({ bucket, key });
});
// GET /files/uploads/images/photo.jpg → { bucket: "uploads", key: "images/photo.jpg" }
```

## Query Parameters

Access query strings with `c.req.query()`:

```typescript
router.get('/search', async (c) => {
  const query = c.req.query('q');
  const page = c.req.query('page') || '1';
  const limit = c.req.query('limit') || '10';

  return c.json({ query, page, limit });
});
// GET /search?q=hello&page=2 → { query: "hello", page: "2", limit: "10" }
```

## Calling Agents

Invoke agents from routes using `c.agent`:

```typescript
router.post('/chat', async (c) => {
  const { message } = await c.req.json();

  const response = await c.agent.assistant.run({ message });

  return c.json(response);
});
```

For background processing, use `c.waitUntil()`:

```typescript
router.post('/webhook', async (c) => {
  const payload = await c.req.json();

  // Process in background, respond immediately
  c.waitUntil(async () => {
    await c.agent.webhookProcessor.run(payload);
  });

  return c.json({ status: 'accepted' });
});
```

## Request Validation

Use `zValidator` middleware for type-safe validation:

```typescript
import { createRouter } from '@agentuity/runtime';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';

const router = createRouter();

const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1),
});

router.post('/users',
  zValidator('json', createUserSchema),
  async (c) => {
    const data = c.req.valid('json'); // Typed as { email: string, name: string }
    const user = await c.agent.userCreator.run(data);
    return c.json(user);
  }
);

export default router;
```

## Request Context

The context object (`c`) provides access to request data and Agentuity services:

**Request data:**
```typescript
await c.req.json();        // Parse JSON body
await c.req.text();        // Get raw text body
c.req.param('id');         // Route parameter
c.req.query('page');       // Query string
c.req.header('Authorization'); // Request header
```

**Responses:**
```typescript
c.json({ data });          // JSON response
c.text('OK');              // Plain text
c.html('<h1>Hello</h1>');  // HTML response
c.redirect('/other');      // Redirect
```

**Agentuity services:**
```typescript
c.agent.myAgent.run(input);   // Call an agent
c.kv.get('bucket', 'key');    // Key-value storage
c.vector.search('ns', opts);  // Vector search
c.var.logger.info('message'); // Logging
```

## Best Practices

### Validate input

Always validate request bodies, especially for public endpoints:

```typescript
router.post('/api',
  zValidator('json', inputSchema),
  async (c) => {
    const data = c.req.valid('json');
    // data is guaranteed valid
  }
);
```

### Use structured logging

Use `c.var.logger` instead of `console.log` for searchable, traceable logs:

```typescript
c.var.logger.info('Request processed', { userId, duration: Date.now() - start });
c.var.logger.error('Processing failed', { error: err.message });
```

### Order routes correctly

Register specific routes before generic ones:

```typescript
// Correct: specific before generic
router.get('/users/me', getCurrentUser);
router.get('/users/:id', getUserById);

// Wrong: :id matches "me" first
router.get('/users/:id', getUserById);
router.get('/users/me', getCurrentUser); // Never reached
```

### Use middleware for cross-cutting concerns

Apply middleware to all routes with `router.use()`:

```typescript
router.use(loggingMiddleware);
router.use(authMiddleware);

router.get('/protected', handler); // Both middlewares apply
```

For authentication patterns, rate limiting, and more, see [Middleware](/docs/v1/Build/Routes/middleware).

### Handle errors gracefully

Return appropriate status codes when things go wrong:

```typescript
router.post('/process', async (c) => {
  try {
    const body = await c.req.json();
    const result = await c.agent.processor.run(body);
    return c.json(result);
  } catch (error) {
    c.var.logger.error('Processing failed', { error });
    return c.json({ error: 'Processing failed' }, 500);
  }
});
```

## Streaming Responses

Use `router.stream()` to return a `ReadableStream` directly to the client without buffering:

```typescript
router.stream('/chat', async (c) => {
  const body = await c.req.json();
  return c.agent.chatAgent.run(body); // Returns a ReadableStream
});
```

### Creating Custom Streams

Return any `ReadableStream` for custom streaming:

```typescript
router.stream('/events', (c) => {
  return new ReadableStream({
    start(controller) {
      controller.enqueue('data: event 1\n\n');
      controller.enqueue('data: event 2\n\n');
      controller.close();
    }
  });
});
```

### With Middleware

Stream routes support middleware:

```typescript
router.stream('/protected', authMiddleware, async (c) => {
  return c.agent.streamAgent.run({ userId: c.var.userId });
});
```

### Stream vs SSE vs WebSocket

| Type | Direction | Format | Use Case |
|------|-----------|--------|----------|
| `router.stream()` | Server → Client | Raw bytes | LLM responses, file downloads |
| `router.sse()` | Server → Client | SSE events | Progress updates, notifications |
| `router.websocket()` | Bidirectional | Messages | Chat, collaboration |

Use `router.stream()` for raw streaming (like AI SDK `textStream`). Use `router.sse()` when you need named events or auto-reconnection. See [Streaming Responses](/docs/v1/Build/Agents/streaming-responses) for the full guide on streaming agents.

## Next Steps

- [Middleware](/docs/v1/Build/Routes/middleware): Authentication, rate limiting, logging
- [Scheduled Jobs (Cron)](/docs/v1/Build/Routes/cron): Run tasks on a schedule
- [Email Handling](/docs/v1/Build/Routes/email): Process incoming emails
- [WebSockets](/docs/v1/Build/Routes/websockets): Real-time bidirectional communication
- [Server-Sent Events](/docs/v1/Build/Routes/sse): Stream updates to clients
