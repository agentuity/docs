---
title: "Module 2: Anatomy of an Agent"
description: HTTP Routing & Agent Anatomy - Master the two-file pattern, HTTP routing, and the context object
---

Now that you've built your first agent, let's understand how agents work under the hood. In this module, you'll master the two-file pattern, HTTP routing fundamentals, and the powerful context object that gives your agents access to storage, logging, and more.

## The Agent Lifecycle

Every agent interaction in v1 follows a predictable lifecycle. Understanding this flow is essential for building effective agents.

```
Trigger → Route → Schema Validation → Agent Handler → Response
```

**Each stage explained:**

- **Trigger:** How the agent is invoked (HTTP request, cron schedule, email, SMS, etc.)
- **Route:** The router matches the trigger to a handler in `route.ts`
- **Schema Validation:** Input is validated against your schema before the handler runs
- **Agent Handler:** Your business logic executes in `agent.ts`
- **Response:** The return value is sent back to the caller

This lifecycle applies to all agents, whether you're using raw LLM APIs (OpenAI, Anthropic), agent frameworks (LangChain, CrewAI), or custom logic. Agentuity provides the infrastructure (triggers, routing, storage), you provide the intelligence (planning, reasoning, decision-making).

### The Two-File Pattern

In v1, every agent uses a two-file structure that separates concerns:

**`agent.ts`** - Business logic only
- Schema definitions
- Metadata (name, description)
- Handler function (your core logic)
- No HTTP knowledge

**`route.ts`** - HTTP orchestration
- Route definitions (GET, POST, etc.)
- Request parsing
- Calling the agent
- Response formatting

Routes invoke agents via `c.agent.agentName.run(input)`. The SDK auto-discovers agents based on your file structure, providing type-safe calls throughout.

| Aspect | v0 (Single File) | v1 (Two Files) |
|--------|------------------|----------------|
| **Structure** | Default export function | `agent.ts` + `route.ts` |
| **HTTP Logic** | Mixed with business logic | Separated in `route.ts` |
| **Reusability** | Limited to one trigger type | Same agent, multiple routes |
| **Testing** | Must mock HTTP | Test business logic directly |

### Planning & Reasoning

What separates agents from simple scripts is their ability to plan and reason. While Agentuity provides the infrastructure, you implement the logic that makes your agents intelligent.

Effective agent planning involves:
- **Intent Recognition**: Understanding what the user actually wants
- **Task Decomposition**: Breaking complex requests into smaller steps
- **Resource Assessment**: Determining what tools and data are needed
- **Execution Strategy**: Deciding the order and approach for each step

Agents use a reasoning loop: **Observe → Think → Act → Reflect**. This iterative approach allows agents to handle uncertainty and recover from errors.

For a deep dive on agent planning patterns, see the [Agent Engineering Guide](/Guides/agent-engineering).

---

## Tutorial Steps

Each step below focuses on one core concept with runnable code you can test immediately.

### Step 1: The Two-File Pattern

<TutorialStep number={1} title="The Two-File Pattern" estimatedTime="6 min">

Every v1 agent separates business logic from HTTP concerns. Let's see how this works with a simple task agent.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step1-two-file-pattern/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/02-anatomy/step1-two-file-pattern/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Agent contains only business logic (no HTTP knowledge)
- Routes handle HTTP concerns (parsing, calling agent, formatting)
- Type-safe agent calls via `c.agent.taskAgent.run()`
- Schema validation happens automatically before the handler runs

**Try it:**
1. Start DevMode: `agentuity dev`
2. Send a POST request:
   ```bash
   curl -X POST http://localhost:3500/tasks \
     -H "Content-Type: application/json" \
     -d '{"action": "create", "task": "Learn v1 routing"}'
   ```
3. Expected response:
   ```json
   {
     "success": true,
     "message": "Created: Learn v1 routing"
   }
   ```
4. Check the logs to see the handler execution

> **Key Insight:** The two-file pattern separates HTTP concerns from business logic. Routes orchestrate, agents execute. This makes testing easier and logic reusable across different trigger types.

</TutorialStep>

---

### Step 2: HTTP Routing Patterns

<TutorialStep number={2} title="HTTP Routing Patterns" estimatedTime="8 min">

A single agent can serve multiple HTTP routes using different methods, parameters, and query strings. Let's build a complete REST API.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step2-http-routing/agent.ts", lang: "ts", title: "agent.ts" },
  { path: "/examples/training/02-anatomy/step2-http-routing/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- REST semantics: GET for queries, POST for creation, PUT for updates, DELETE for removal
- Route parameters: `c.req.param('id')` extracts values from the URL path
- Query strings: `c.req.query('status')` extracts values from the query
- One agent handles all operations through different routes

**Try it:**
1. List all tasks:
   ```bash
   curl http://localhost:3500/tasks
   ```
2. Filter with query string:
   ```bash
   curl http://localhost:3500/tasks?status=completed
   ```
3. Get specific task:
   ```bash
   curl http://localhost:3500/tasks/123
   ```
4. Create a task:
   ```bash
   curl -X POST http://localhost:3500/tasks \
     -H "Content-Type: application/json" \
     -d '{"title": "New task", "status": "pending"}'
   ```
5. Update a task:
   ```bash
   curl -X PUT http://localhost:3500/tasks/123 \
     -H "Content-Type: application/json" \
     -d '{"title": "Updated task", "status": "completed"}'
   ```
6. Delete a task:
   ```bash
   curl -X DELETE http://localhost:3500/tasks/123
   ```

> **Key Insight:** REST principles apply to agent routes. Use GET for queries, POST for creation, PUT for updates, DELETE for removal. Route parameters and query strings make your APIs intuitive and semantic.

</TutorialStep>

---

### Step 3: The Context Object

<TutorialStep number={3} title="The Context Object" estimatedTime="8 min">

The context object (`c`) is your agent's interface to Agentuity's capabilities. It provides request/response methods, storage, logging, and more.

#### Context Capabilities

**Request & Response**
```typescript
// Request data
c.req.json()          // Parse JSON body
c.req.text()          // Get text body
c.req.param('id')     // Route parameter
c.req.query('filter') // Query string parameter

// Response
c.json(data)          // JSON response
c.text(data)          // Text response
c.html(data)          // HTML response
```

**Storage (Basic Introduction)**
```typescript
// Key-value storage for basic caching
await c.kv.get(bucket, key)
await c.kv.set(bucket, key, value, { ttl })
await c.kv.delete(bucket, key)

// Note: Vector and object storage covered in Module 5
```

**Observability**
```typescript
// Structured logging
c.logger.info('message', { metadata })
c.logger.warn('message', { metadata })
c.logger.error('message', { metadata })

// Child loggers (add context to all logs)
const userLogger = c.logger.child({ userId: '123' })
userLogger.info('User action') // Includes userId automatically
```

**Metadata**
```typescript
c.agentName   // Current agent name
c.sessionId   // Current session ID
c.env         // Environment variables
```

#### When to Use What

| Scenario | Use |
|----------|-----|
| Get validated input from agent call | `input` parameter in handler |
| Parse HTTP request body | `c.req.json()`, `c.req.text()` |
| Access route parameters | `c.req.param()` |
| Access query strings | `c.req.query()` |
| Log with context | `c.logger` |
| Basic caching | `c.kv` |

#### Practical Example

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step3-context-object/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Extracting route parameters and query strings
- Creating child loggers with user context
- Basic caching with KV storage (5-minute TTL)
- Logging cache hits and misses
- Type-safe agent calls

**Try it:**
1. First request (cache miss):
   ```bash
   curl http://localhost:3500/users/user123/tasks?filter=pending
   ```
2. Second request within 5 minutes (cache hit):
   ```bash
   curl http://localhost:3500/users/user123/tasks?filter=pending
   ```
3. Check logs to see cache behavior

> **Key Insight:** The context object is your toolbox. Use `c.req` for HTTP details, `c.logger` for observability, `c.kv` for basic caching, and `c.agent` for multi-agent workflows. Each capability is designed to work together seamlessly.

</TutorialStep>

---

### Step 4: Request/Response Handling

<TutorialStep number={4} title="Request/Response Handling" estimatedTime="8 min">

Agents can handle different input formats and return different response types. This flexibility makes your agents versatile and easy to integrate.

<CodeFromFiles snippets={[
  { path: "/examples/training/02-anatomy/step4-request-response/route.ts", lang: "ts", title: "route.ts" }
]} />

**What this demonstrates:**
- Parsing different input formats (JSON, text, FormData)
- Returning different response types (JSON, text, HTML, redirect)
- Content negotiation based on Accept header
- Custom status codes and headers

**Try it:**
1. JSON input:
   ```bash
   curl -X POST http://localhost:3500/tasks/json \
     -H "Content-Type: application/json" \
     -d '{"action": "create", "title": "New task"}'
   ```
2. Plain text input:
   ```bash
   curl -X POST http://localhost:3500/tasks/text \
     -H "Content-Type: text/plain" \
     -d "Buy groceries"
   ```
3. Form data input:
   ```bash
   curl -X POST http://localhost:3500/tasks/form \
     -F "title=Clean room" \
     -F "status=pending"
   ```
4. Content negotiation (HTML response):
   ```bash
   curl http://localhost:3500/tasks/123 \
     -H "Accept: text/html"
   ```
5. Content negotiation (plain text response):
   ```bash
   curl http://localhost:3500/tasks/123 \
     -H "Accept: text/plain"
   ```
6. Default JSON response:
   ```bash
   curl http://localhost:3500/tasks/123
   ```

> **Key Insight:** Flexible I/O makes agents versatile. Support multiple input formats to integrate with any system. Return appropriate response types based on client needs. Content negotiation enables one endpoint to serve multiple formats.

</TutorialStep>

---

## Key Takeaways

By the end of this module, you should understand:

1. **The Two-File Pattern:**
   - `agent.ts` contains business logic
   - `route.ts` contains HTTP endpoints
   - Routes call agents via `c.agent.name.run()`

2. **HTTP Routing:**
   - Different methods (GET, POST, PUT, DELETE)
   - Route parameters and query strings
   - Multiple routes for one agent
   - REST principles

3. **Context Object (`c`):**
   - Request/response methods
   - Logging capabilities
   - Basic KV storage for caching
   - Metadata access

4. **Request/Response Patterns:**
   - Multiple input formats (JSON, text, FormData)
   - Multiple response types (JSON, text, HTML)
   - Content negotiation
   - Custom headers and status codes

You can now build production HTTP APIs with proper routing, validation, and basic storage. This foundation prepares you for specialized routes in Module 3.

---

## What's Next?

**Module 3: Specialized Routes & Triggers** - Learn cron scheduling, email/SMS triggers, WebSocket/SSE for real-time communication, and multi-trigger architecture patterns.

For more details on routing patterns and best practices, see the [Routing Guide](/Guides/routing).
