---
title: Core Concepts
description: Learn about the fundamental concepts of the Agentuity v1 SDK
---

The Agentuity v1 SDK is built on modern web standards and designed for type safety. Understanding these core concepts will help you build robust agents quickly.

## Creating Agents

Each agent in v1 is created with the `createAgent()` function. Simply define your metadata and handler function to get started.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent({
  metadata: {
    name: 'My Agent',
    description: 'A simple agent that greets users'
  },
  handler: async (c) => {
    c.logger.info('Agent invoked');
    return { message: 'Hello!' };
  }
});

export default agent;
```

Each agent lives in its own directory with two files:
- **`agent.ts`** - Defines the agent logic using `createAgent()`, including schemas and the handler function
- **`route.ts`** - Defines HTTP routes using `createRouter()` that call the agent

The route file imports the agent and invokes it via `ctx.agent.agentName.run(input)`. This separation keeps HTTP routing concerns separate from agent logic.

<Callout type="info">
**Project Structure:** See the [Architecture Guide](/Introduction/architecture) for complete details on file structure, how routes and agents work together, and how the bundler discovers them.
</Callout>

## Schema Validation

For type safety, it's recommended to add a schema. This enables IDE autocomplete and automatic input validation.

v1 supports any [StandardSchema](https://github.com/standard-schema/standard-schema)-compatible library, including Zod, Valibot, and ArkType. Here's an example with Zod:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      name: z.string(),
      age: z.number().optional()
    }),
    output: z.object({
      greeting: z.string()
    })
  },
  handler: async (c, input) => {
    // input is fully typed and validated!
    return {
      greeting: `Hello ${input.name}!`
    };
  }
});
```

**Benefits:**
- Full TypeScript type inference
- Automatic runtime validation
- Clear API contracts
- Better error messages

## App and Router

v1 uses Hono for routing, a fast and lightweight web framework similar to Express.

Your project has an `app.ts` file that creates the application and exports the server:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// The router is available at app.router
// Routes are automatically discovered from agent directories

export default app.server;
```

Agents define their routes in `route.ts` files using `createRouter()`:

```typescript
import { createRouter } from '@agentuity/runtime';
import agent from './agent';

const router = createRouter();

router.post('/', async (c) => {
  const input = await c.req.json();
  const result = await c.agent.myAgent.run(input);
  return c.json(result);
});

export default router;
```

Routes automatically include load balancing, monitoring, and error tracking. You can configure authentication and rate limiting per route using middleware.

<Callout type="info">
**Advanced Routing:** v1 supports WebSocket, Server-Sent Events, email, cron, and more. See the [Routing & Triggers Guide](/Guides/routing-triggers) for details.
</Callout>

## Agent Context

The handler receives a context object (`ctx`) with everything your agent needs:

**Execution Info:**
- `ctx.sessionId` - Unique identifier for this execution
- `ctx.session` - Session object for conversation state
- `ctx.thread` - Thread object for multi-turn interactions

**Services:**
- `ctx.kv` - Key-value storage
- `ctx.vector` - Vector storage
- `ctx.objectstore` - Object storage
- `ctx.stream` - Stream storage

**Agent Access:**
- `ctx.agent` - Call other agents in your project
- `ctx.current` - Reference to the current agent
- `ctx.parent` - Reference to parent agent (for subagents)

**Observability:**
- `ctx.logger` - Structured logging
- `ctx.tracer` - OpenTelemetry tracing

**Utilities:**
- `ctx.state` - Temporary state storage (Map)
- `ctx.waitUntil()` - Background task execution

The context object provides access to all agent capabilities, from storage to logging.

## Request Handling

When using schemas, v1 automatically handles parsing and validation. Without schemas, use Hono's request methods for manual control.

**Pattern 1: With Schema (Recommended)**

When you define an input schema, it's passed directly to your handler:

```typescript
const agent = createAgent({
  schema: {
    input: z.object({ message: z.string() })
  },
  handler: async (c, input) => {
    // input is already parsed and validated
    return { echo: input.message };
  }
});
```

**Pattern 2: Route-Based (Manual Parsing)**

For more control, parse requests manually in your routes:

```typescript
router.post('/', async (c) => {
  const data = await c.req.json();
  const headers = c.req.header('authorization');
  const query = c.req.query('limit');

  return c.json({ processed: data });
});
```

## Response Handling

By default, returning an object will automatically serialize it as JSON. For more control over responses, use Hono's response methods.

**Simple Returns:**

```typescript
handler: async (c, input) => {
  return { message: 'Done!' }; // Automatically becomes JSON
}
```

**Advanced Responses:**

Use Hono methods in routes for custom status codes, headers, or content types:

```typescript
router.get('/status', (c) => {
  return c.json({ status: 'ok' }, 200);
});

router.get('/html', (c) => {
  return c.html('<h1>Hello</h1>');
});

router.get('/custom', (c) => {
  return c.text('Custom response', 201, {
    'X-Custom-Header': 'value'
  });
});
```

## Agent-to-Agent Communication

To call another agent, use `ctx.agent.otherAgent.run()`. This provides direct access without requiring agent IDs or lookups.

```typescript
const agent = createAgent({
  handler: async (c, input) => {
    // Call another agent
    const result = await c.agent.helperAgent.run({
      data: input.data
    });

    // Use the result
    return {
      original: input.data,
      processed: result
    };
  }
});
```

When both agents use schemas, the communication is fully type-safe. Your IDE will autocomplete the input structure and validate the output.

## Sessions and Threads

Sessions track individual executions, while threads track conversation histories. These enable stateful, conversational agents.

**Sessions** represent a single execution context with a unique `sessionId`. Each agent invocation gets its own session.

**Threads** represent conversation histories for multi-turn interactions. Use threads to maintain context across multiple requests.

```typescript
handler: async (c, input) => {
  // Log session info
  c.logger.info('Session:', {
    id: c.sessionId,
    session: c.session
  });

  // Track conversation turns
  const turnCount = (c.state.get('turnCount') as number || 0) + 1;
  c.state.set('turnCount', turnCount);

  return {
    turn: turnCount,
    message: `This is turn ${turnCount} of our conversation`
  };
}
```

<Callout type="info">
**State Management:** Use `ctx.state` for temporary data within a session. For persistent storage, use `ctx.kv` or other storage services.
</Callout>

## Events and Evaluations

v1 provides built-in capabilities for monitoring and testing agents through events and evaluations.

**Events** let you listen to agent lifecycle events (started, completed, errored) for monitoring and analytics:

```typescript
agent.addEventListener('started', (eventName, agent, ctx) => {
  ctx.logger.info('Agent started', { name: agent.metadata.name });
});

agent.addEventListener('completed', (eventName, agent, ctx) => {
  ctx.logger.info('Agent completed successfully');
});
```

See the [Events Guide](/SDKs/javascript/events) for complete documentation.

**Evaluations** automatically test agent outputs for quality, accuracy, or compliance. Evaluations test your complete agent logic—the actual input and output from your handler—not just external LLM API responses.

```typescript
agent.createEval({
  metadata: {
    name: 'quality-check',
    description: 'Validates output quality'
  },
  handler: async (c, input, output) => {
    const score = calculateQuality(output);
    return {
      success: true,
      score: score
    };
  }
});
```

Evaluations run asynchronously after responses are sent, ensuring zero impact on response times. Common use cases:

- Quality assurance and compliance checking
- RAG metrics (hallucination detection, faithfulness)
- Performance monitoring and optimization

See the [Evaluations Guide](/SDKs/javascript/evaluations) for complete documentation.

## Next Steps

Now that you understand the core concepts, you can:

- TODO: Create dedicated deployment guide
- Explore the [Routing & Triggers Guide](/Guides/routing-triggers) for WebSocket, SSE, and specialized routes
- Learn about [Schema Validation](/SDKs/javascript/schema-validation) in depth
- Set up [Evaluations](/SDKs/javascript/evaluations) to test your agents
- Use [Events](/SDKs/javascript/events) for monitoring and analytics
- Check the [API Reference](/SDKs/javascript/api-reference) for complete documentation
