---
title: Overview
description: Understanding Agentuity
---

## Agentuity Overview

Agentuity is a cloud platform that lets you run and scale AI agents with enterprise-grade reliability.
Each agent operates in its own isolated, containerized environment, giving you the security and
isolation you need for production workloads.

Unlike traditional serverless platforms, your agents run for as long as needed, maintaining state
and context throughout their lifecycles. This long-running approach means you can build complex
workflows without worrying about time limits. It's perfect for agents that need extended processing
time, persistent storage, or ongoing access to resources.

The platform is fundamentally cross-platform, so you can run different agent frameworks (CrewAI,
Langchain, custom agents) side by side in the same ecosystem. Built-in communication channels let
your agents work together seamlessly, regardless of which framework they use.

## Core Components

Agentuity consists of five primary components:

1. **Agent Platform** - The cloud platform for providing agent services, providing:
   - Agent communication and routing
   - Agent monitoring, logging, telemetry and troubleshooting
   - Agent usage analytics and performance insights
   - Automatic scaling on-demand based on workload
   - Agent services such as KeyValue, Vector storage, AI Gateway and more

2. **Agent Runtime** - The execution environment where your agents run, providing:
   - Isolated, secure virtualized environment for each agent project
   - Resource management and optimization
   - Long-running support for persistent agents
   - Dynamic Storage, Compute and Networking resources

3. **Command Line Interface (CLI)** - A developer tool that enables:
   - Quick agent creation and initialization
   - Local development and testing
   - Deployment management to the Agentuity cloud
   - Integration with external Agentic code tools via MCP

4. **Software Development Kits (SDKs)** - Libraries that provide:
   - Agent-native tools and services integration with the Agent Platform
   - Runtime-specific optimizations for JavaScript/TypeScript (Node.js and Bun)
   - Integration capabilities with external systems
   - Enhanced agent capabilities and extensions which work cross-framework and cross-runtime

5. **Web Console** - A management interface offering:
   - Real-time agent monitoring and metrics
   - Deployment and configuration management
   - Usage analytics, logging, monitoring and performance insights
   - Team collaboration features

## Built-in Services

Agentuity includes built-in services that work out of the box. These services are accessible through the agent context (`c`) and require minimal configuration.

### Routing and Connectivity

| Service | Description | Access |
|---------|-------------|--------|
| HTTP/WebSocket/SSE | Built on Hono framework with automatic load balancing | `router.get()`, `router.post()`, `router.websocket()`, `router.sse()` |
| Email Handling | Define email addresses as routes to trigger agents from incoming messages | `router.email()` |
| SMS Integration | Route SMS messages to agents based on phone numbers | `router.sms()` |
| Cron Scheduling | Schedule periodic agent execution with cron expressions | `router.cron()` |
| Authentication | Configurable authentication and rate limiting per route | Middleware |

### Storage Layer

| Service | Description | Access |
|---------|-------------|--------|
| Key-Value Storage | Fast key-value store with TTL support | `c.kv` |
| Vector Database | Embeddings storage and semantic search | `c.vector` |
| Object Storage | Blob and file storage with public URL generation | `c.objectstore` |
| Stream Storage | Large data streaming and processing | `c.stream` |

### Observability

| Service | Description | Access |
|---------|-------------|--------|
| Structured Logging | Built-in logger with contextual information | `c.logger` |
| OpenTelemetry Tracing | Distributed tracing for agent interactions | `c.tracer` |
| Real-time Analytics | Execution metrics, performance data, and usage tracking | Web Console |
| Error Tracking | Automatic error capture and reporting | Web Console |

### AI Gateway

| Feature | Description |
|---------|-------------|
| Unified LLM Access | Single interface for multiple LLM providers (OpenAI, Anthropic, etc.) |
| Managed API Keys | Centralized credential management for LLM services |
| Model Switching | Change providers without code modifications |
| Usage Tracking | Monitor LLM API usage and costs |

### Evaluation Framework

| Feature | Description |
|---------|-------------|
| Real-time Testing | Test agent input/output during execution using `agent.createEval()` |
| Quality Assurance | Automated checks for accuracy, relevance, and compliance |
| Custom Evaluators | Define custom evaluation logic for specific requirements |
| Non-blocking Execution | Evaluations run asynchronously without impacting response times |

### Frontend Deployment

| Feature | Description |
|---------|-------------|
| React Integration | Deploy React applications alongside agents |
| Hot Reload | Automatic reload during development |
| CDN Distribution | Built-in CDN for global frontend delivery |
| Custom Domains | Configure custom domains with automatic SSL certificates |

All services are configured in `agentuity.yaml` and accessed through the agent context. No additional infrastructure setup required.

## SDK Architecture

Agentuity v1 uses a monorepo structure with specialized packages for different concerns:

### Package Overview

- **`@agentuity/runtime`** - The primary SDK for building agents
  - Agent creation and lifecycle management
  - Built on Hono framework for routing
  - Event system for monitoring
  - Evaluation framework for testing
  - Session and thread management

- **`@agentuity/core`** - Shared utilities and types
  - Storage abstractions (KV, Vector, Object, Stream)
  - Common interfaces and types
  - Schema validation support (StandardSchema)

- **`@agentuity/server`** - Runtime-agnostic server utilities
  - Server creation and configuration
  - Request/response handling
  - Middleware support

- **`@agentuity/react`** - React components and hooks
  - `AgentuityProvider` for app-wide configuration
  - `useAgent` hook for calling agents
  - `useAgentWebsocket` for WebSocket connections
  - `useAgentEventStream` for Server-Sent Events

- **`@agentuity/cli`** - Command-line tools
  - Project scaffolding and management
  - Local development server
  - Deployment orchestration

### App & Router Architecture

Agentuity v1 is built on [Hono](https://hono.dev/), a fast, lightweight web framework. Your agents are organized into an **App** that manages routing, configuration, and lifecycle:

```typescript
import { createApp } from '@agentuity/runtime';

// Create the app
const app = createApp();

// The router is available at app.router
app.router.post('/my-agent', async (c) => {
  return c.json({ message: 'Hello!' });
});

// Export the server
export default app.server;
```

This architecture provides:
- **Type-safe routing** with full TypeScript support
- **Middleware support** for authentication, logging, etc.
- **Automatic service injection** (kv, logger, tracer, etc.)
- **Event system** for monitoring agent executions
- **Code-based trigger configuration** - Cron schedules, email addresses, and SMS numbers are defined in your routes, not in the UI

## Data Flow

Agent communication and data flow in Agentuity follow secure, encrypted channels:

1. **Agent-to-Agent Communication** - Agents can communicate with each other through authenticated, encrypted routing,
regardless of the underlying frameworks or runtimes used.

2. **External Integrations** - Agents can connect to external systems and data sources through managed
integration points.

3. **Deployment Pipeline** - Your project code is packaged, containerized, and deployed to the Agentuity
cloud infrastructure with appropriate networking and routing configured automatically. Built-in support for GitHub Actions.

## Scalability

Agentuity is designed for enterprise-scale agent deployments:

- **Horizontal Scaling** - Automatically provision additional resources as demand increases
- **Framework Agnostic** - Scale any type of agent regardless of the underlying framework
- **Load Balancing** - Distribute agent workloads efficiently across available resources
- **Resource Optimization** - Intelligently allocate compute resources based on agent requirements

## Security Architecture

Security is foundational to Agentuity's design:

- **Agent Isolation** - Each agent project operates in its own isolated environment
- **Encrypted Communications** - All agent-to-agent communication is encrypted
- **Secure Deployment** - Protected deployment pipeline from development to production

## Deployment Targets

Agentuity supports multiple deployment targets, allowing you to choose where your agents run based on your requirements. The same agent code and configuration work across all targets.

### Public Cloud

Deploy to Agentuity's managed infrastructure for immediate scalability:

- **Global Edge Network** - Agents run on a distributed edge network for low-latency responses
- **Automatic Scaling** - Scale from zero to thousands of requests without configuration
- **Fast Cold Starts** - Sub-100ms cold start times on the global edge
- **Managed Services** - All infrastructure, monitoring, and maintenance handled by Agentuity

Best for: Rapid deployment, global distribution, and zero infrastructure management.

### Private Cloud

Deploy agents to your own Virtual Private Cloud (VPC) while using Agentuity services:

- **Infrastructure Control** - Agents run in your AWS, GCP, or Azure account
- **Data Security** - Your data never leaves your infrastructure
- **Agentuity Services** - Access storage, observability, and platform features
- **Compliance** - Meet regulatory requirements for data residency

Best for: Organizations with strict data governance or compliance requirements.

### Multi-Cloud

Deploy agents across multiple cloud providers with consistent configuration:

- **Provider Flexibility** - Run on AWS, GCP, Azure, or combinations
- **Avoid Lock-in** - Move between providers without code changes
- **Geographic Distribution** - Place agents near users across different clouds
- **Consistent Tooling** - Same CLI, SDK, and deployment process everywhere

Best for: Organizations requiring cloud provider flexibility or multi-region deployments.

### On-Premises

Self-host Agentuity infrastructure on your own hardware:

- **Complete Control** - Full ownership of infrastructure and data
- **Air-Gapped Support** - Run in isolated networks without internet access
- **Custom Hardware** - Deploy on specialized hardware or existing infrastructure
- **Data Sovereignty** - Guarantee data never leaves your physical premises

Best for: Highly regulated industries, air-gapped environments, or specific hardware requirements.

### Edge Deployment

Deploy agents to edge devices for local processing:

- **Local Processing** - Run agents on Raspberry Pi, laptops, or IoT devices
- **Low Latency** - Process data at the edge without network round-trips
- **Offline Operation** - Agents function without cloud connectivity
- **Resource Efficiency** - Optimized for resource-constrained environments

Best for: IoT applications, offline scenarios, or latency-sensitive workloads.

## Project Conventions

Agentuity projects follow specific conventions to take advantage of the deployment and cloud platform Agentuity offers. Understanding these conventions is important for effective agent development.

### Project Structure

Every Agentuity project requires the following core components:

1. **agentuity.yaml** - The central configuration file that defines:
   - Project metadata (name, ID, description)
   - Development settings (port, watch patterns)
   - Deployment configuration (resources, scaling)
   - Bundler settings (language, runtime)
   - Agent definitions and routing

2. **Environment Variables** - Stored in a `.env` file:
   - `AGENTUITY_SDK_KEY` - Identifies the SDK level API Key (only used in development to access the Agentuity Cloud)
   - `AGENTUITY_PROJECT_KEY` - Identifies the project level API Key
   - Additional provider-specific keys (OpenAI, Anthropic, etc.)

3. **Agent Directory** - Specified in `bundler.agents.dir`:
   - Each agent has its own subdirectory
   - TypeScript/JavaScript entry points: `agent.ts` and `route.ts`
   - Agent-specific configuration and dependencies

### JavaScript/TypeScript Project Structure

```
my-project/
├── agentuity.yaml        # Project configuration
├── .env                  # Environment variables
├── package.json          # Dependencies and scripts
├── app.ts                # App entry point
└── src/
    ├── agents/           # Agent directory
    │   └── my-agent/     # Individual agent
    │       ├── agent.ts  # Agent logic (createAgent)
    │       └── route.ts  # Route definitions (createRouter)
    └── apis/             # Optional: Custom API routes
        └── status/
            └── route.ts
```

### Agent Structure

Each agent in Agentuity consists of two files that work together:

#### Understanding the Two-File Pattern

Every agent directory contains both `agent.ts` and `route.ts`. This separation keeps concerns clear:

- **`agent.ts`** uses `createAgent()` to define the agent's logic, schemas, and metadata. This is where your business logic lives.
- **`route.ts`** uses `createRouter()` to define HTTP endpoints that invoke the agent. Routes handle HTTP-specific concerns like request parsing and response formatting.

The route file imports the agent and calls it using `ctx.agent.agentName.run(input)`. The Agentuity bundler automatically discovers both files and registers them together based on the directory structure.

Routes can exist without agents (such as health check endpoints in `/apis/` directories), but every agent should have a corresponding route file to enable HTTP access.

#### `agent.ts` - Agent Logic

Defines the agent's behavior, schema, and metadata:

```typescript
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';

export default createAgent({
  schema: {
    input: z.object({
      message: z.string()
    }),
    output: z.object({
      response: z.string()
    })
  },
  metadata: {
    name: 'My Agent',
    description: 'A simple agent'
  },
  handler: async (c, input) => {
    c.logger.info('Processing request', { input });

    return {
      response: `Received: ${input.message}`
    };
  }
});
```

#### `route.ts` - Route Definitions

Defines how the agent is exposed via HTTP or other protocols:

```typescript
import { createRouter } from '@agentuity/runtime';
import agent from './agent';

const router = createRouter();

// HTTP routes
router.post('/', async (c) => {
  const input = await c.req.json();
  const result = await c.agent.myAgent.run(input);
  return c.json(result);
});

// Advanced: WebSocket route
router.websocket('/ws', (c) => (ws) => {
  ws.onMessage(async (event) => {
    const result = await c.agent.myAgent.run(event.data);
    ws.send(JSON.stringify(result));
  });
});

export default router;
```

#### How Agent Files Work Together

When an HTTP request arrives, the flow works as follows:

1. The HTTP request is routed to the appropriate route handler in `route.ts`
2. The route handler optionally validates the input using middleware (such as `zValidator` with the agent's schema)
3. The route calls the agent using `c.agent.myAgent.run(input)`
4. The agent's handler function executes with the validated input
5. The agent returns its output, which flows back through the route to the client

This architecture provides clear separation: routes handle HTTP concerns (request parsing, validation, response formatting) while agents focus purely on business logic. The agent can be called from multiple routes or by other agents without duplicating logic.

### App Entry Point

The `app.ts` file creates and configures your application:

```typescript
import { createApp } from '@agentuity/runtime';

const app = createApp();

// Optional: Add app-level event listeners
app.addEventListener('agent.started', (event, agent, ctx) => {
  app.logger.info('Agent started', {
    agent: agent.metadata.name,
    session: ctx.sessionId
  });
});

// The router automatically discovers and registers all agents
// based on the directory structure

export default app.server;
```

### Configuration File (agentuity.yaml)

The `agentuity.yaml` file is the heart of your project, defining how it behaves in development and production:

```yaml
version: ">=0.0.0"         # Minimum CLI version required
project_id: "proj_..."     # Unique project identifier
name: "My Project"         # Human-readable project name
description: "..."         # Optional project description

# Development configuration
development:
  port: 3000               # Local development server port
  watch:
    enabled: true          # Auto-reload on file changes
    files: ["src/**/*.ts"] # Files to watch

# Deployment configuration
deployment:
  resources:
    memory: "1Gi"          # Memory allocation
    cpu: "1000m"           # CPU allocation

# Bundler configuration
bundler:
  language: "javascript"   # Programming language (javascript only in v1)
  runtime: "nodejs"        # Runtime environment (nodejs or bunjs)
  agents:
    dir: "src/agents"      # Directory where agents are located

# Agents configuration
agents:
  - id: "agent_..."        # Unique agent identifier
    name: "My Agent"       # Human-readable agent name
    description: "..."     # Optional agent description
```

### Key Concepts in v1

#### Sessions and Threads

- **Session** - Represents a single execution context with a unique `sessionId`
- **Thread** - Represents a conversation thread for multi-turn interactions
- Access via `ctx.session` and `ctx.thread` in agent handlers

#### Event System

Monitor agent lifecycle with event listeners:

```typescript
// Agent-level events
agent.addEventListener('started', (event, agent, ctx) => {
  // Called when agent starts
});

agent.addEventListener('completed', (event, agent, ctx) => {
  // Called when agent completes successfully
});

agent.addEventListener('errored', (event, agent, ctx, error) => {
  // Called when agent encounters an error
});

// App-level events
app.addEventListener('agent.started', (event, agent, ctx) => {
  // Called for any agent start
});
```

#### Evaluation Framework

Test and validate agent outputs automatically:

```typescript
agent.createEval({
  metadata: {
    name: 'quality-check',
    description: 'Validates output quality'
  },
  handler: async (c, input, output) => {
    // Evaluate the output
    const score = calculateQuality(output);

    return {
      success: true,
      score: score,
      metadata: { /* additional info */ }
    };
  }
});
```

#### Schema Validation

Define and validate input/output schemas using any StandardSchema-compatible library (Zod, Valibot, ArkType, etc.):

```typescript
import { z } from 'zod';

const agent = createAgent({
  schema: {
    input: z.object({
      name: z.string(),
      age: z.number().optional()
    }),
    output: z.object({
      greeting: z.string()
    })
  },
  handler: async (c, input) => {
    // input is fully typed and validated
    return {
      greeting: `Hello ${input.name}!`
    };
  }
});
```

### Why These Conventions Matter

These conventions enable several key capabilities:

1. **Consistent Development Experience** - Standardized structure makes it easier to work across projects
2. **Automated Deployment** - The CLI can package and deploy your project without additional configuration
3. **Framework Flexibility** - Use any agent framework while maintaining compatibility with the platform
4. **Type Safety** - Full TypeScript support throughout the stack
5. **Scalability** - Clear separation of concerns makes it easy to organize complex agent systems

TODO: Add examples showing integration with frontend frameworks (Next.js, Svelte, vanilla JS, etc.) for building UIs that call agents
