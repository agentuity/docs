---
title: "Module 7: Routes and Triggers"
description: Connect agents to the outside world through HTTP endpoints, scheduled jobs, and real-time connections
---

Routes are the bridge between users, external systems, and your agents. They define HOW interactions happen, while agents define WHAT happens.

## The Route Architecture

In Agentuity, there's a clear separation of concerns:

| Component | Location | Purpose |
|-----------|----------|---------|
| **Routes** | `src/api/` | Handle HTTP concerns (validation, response formatting, scheduling) |
| **Agents** | `src/agent/` | Handle business logic (AI reasoning, storage operations) |

This separation keeps your codebase clean: routes manage the "how" of incoming requests, agents manage the "what" of processing them.

<Callout type="info">
Routes are built on [Hono](https://hono.dev), a fast, lightweight web framework. If you're familiar with Express or Fastify, Hono will feel natural.
</Callout>

## Route Context vs Agent Context

Routes and agents have different contexts, each optimized for their purpose:

| Route Context (`c`) | Agent Context (`ctx`) |
|---------------------|----------------------|
| `c.var.logger` | `ctx.logger` |
| `c.var.kv` | `ctx.kv` |
| `c.req`, `c.json()`, `c.text()` | N/A (no HTTP) |
| `c.executionCtx.waitUntil()` | `ctx.waitUntil()` |

Routes have access to HTTP request/response methods. Agents have access to storage, tracing, and other runtime services.

## Build Routes Step-by-Step

<TutorialStep number={1} title="Basic HTTP Routes" estimatedTime="4 min">

Start with a simple route that invokes an agent. The `createRouter()` function from `@agentuity/runtime` creates a Hono router with Agentuity middleware already configured.

```typescript
import { createRouter } from '@agentuity/runtime';
import helloAgent from '../../agent/hello/agent';

const router = createRouter();

// GET endpoint for simple health checks or info
router.get('/', (c) => {
  return c.json({ status: 'healthy', version: '1.0.0' });
});

// POST endpoint to invoke the agent
router.post('/', async (c) => {
  const body = await c.req.json();
  const result = await helloAgent.run({ name: body.name || 'World' });
  return c.text(result);
});

export default router;
```

**What this demonstrates:**
- Creating a router with `createRouter()`
- Handling GET requests for health checks
- Handling POST requests to invoke agents
- Returning different response types (`c.json()`, `c.text()`)

**Try it:**
1. Create a route file at `src/api/hello/route.ts`
2. Start Workbench with `agentuity dev`
3. Test with `curl http://localhost:3500/api/hello` (GET)
4. Test with `curl -X POST http://localhost:3500/api/hello -d '{"name": "Developer"}'` (POST)

**Key insight:** Routes are thin wrappers. They handle HTTP concerns and delegate business logic to agents.

</TutorialStep>

<TutorialStep number={2} title="Route Validation with agent.validator()" estimatedTime="5 min">

Manual request validation is error-prone. Use `agent.validator()` to automatically validate incoming requests against the agent's schema.

```typescript
import { createRouter } from '@agentuity/runtime';
import chatAgent from '../../agent/chat/agent';

const router = createRouter();

// validator() auto-validates request body against agent's input schema
router.post('/', chatAgent.validator(), async (c) => {
  // c.req.valid('json') returns fully typed, validated data
  const data = c.req.valid('json');

  // TypeScript knows the exact shape of data from the agent schema
  const result = await chatAgent.run(data);

  return c.json(result);
});

router.get('/', (c) => {
  return c.json({
    message: 'Use POST /api/chat to send messages',
    schema: 'Expects { message: string }',
  });
});

export default router;
```

**What this demonstrates:**
- Using `agent.validator()` as middleware
- Type-safe request data with `c.req.valid('json')`
- Automatic error responses for invalid input (400 Bad Request)
- Schema information in GET endpoint for documentation

**Try it:**
1. Send valid request: `curl -X POST /api/chat -d '{"message": "Hello"}'`
2. Send invalid request: `curl -X POST /api/chat -d '{"wrong": "field"}'`
3. Notice the automatic validation error response

**Key insight:** `agent.validator()` eliminates manual validation code and ensures type safety from HTTP to agent.

<Callout type="info">
The validator middleware returns a 400 Bad Request with validation errors if the request body doesn't match the agent's input schema. No additional error handling needed.
</Callout>

</TutorialStep>

<TutorialStep number={3} title="Multiple HTTP Methods and Parameters" estimatedTime="5 min">

Real APIs need multiple endpoints with parameters. Routes support all standard HTTP methods and parameter extraction.

```typescript
import { createRouter } from '@agentuity/runtime';
import documentAgent from '../../agent/document/agent';

const router = createRouter();

// GET with query parameters
router.get('/', async (c) => {
  const filter = c.req.query('filter') || 'all';
  const limit = parseInt(c.req.query('limit') || '10', 10);

  c.var.logger.info('Fetching documents', { filter, limit });

  const result = await documentAgent.run({
    action: 'list',
    filter,
    limit,
  });

  return c.json(result);
});

// GET with route parameter
router.get('/:id', async (c) => {
  const id = c.req.param('id');

  c.var.logger.info('Fetching document', { id });

  const result = await documentAgent.run({
    action: 'get',
    documentId: id,
  });

  return c.json(result);
});

// POST for creating new documents
router.post('/', documentAgent.validator(), async (c) => {
  const data = c.req.valid('json');

  c.var.logger.info('Creating document', { title: data.title });

  const result = await documentAgent.run({
    action: 'create',
    ...data,
  });

  return c.json(result, 201);
});

// DELETE for removing documents
router.delete('/:id', async (c) => {
  const id = c.req.param('id');

  c.var.logger.info('Deleting document', { id });

  const result = await documentAgent.run({
    action: 'delete',
    documentId: id,
  });

  return c.json(result);
});

export default router;
```

**What this demonstrates:**
- Query parameters with `c.req.query('name')`
- Route parameters with `c.req.param('id')`
- Multiple HTTP methods (GET, POST, DELETE)
- Using `c.var.logger` for route-level logging
- Setting response status codes (`c.json(result, 201)`)

**Try it:**
1. List documents: `curl /api/documents?filter=active&limit=5`
2. Get specific document: `curl /api/documents/doc-123`
3. Create document: `curl -X POST /api/documents -d '{"title": "New Doc"}'`
4. Delete document: `curl -X DELETE /api/documents/doc-123`

**Key insight:** Routes provide a clean REST API surface while agents handle all the business logic.

</TutorialStep>

<TutorialStep number={4} title="Scheduled Routes with Cron" estimatedTime="6 min">

Cron routes run on a schedule without HTTP triggers. Use them for background jobs, cleanup tasks, data synchronization, and periodic reports.

```typescript
import { createRouter, cron } from '@agentuity/runtime';
import cleanupAgent from '../../agent/cleanup/agent';
import reportAgent from '../../agent/report/agent';

const router = createRouter();

// Hourly cleanup job
router.post('/cleanup', cron('0 * * * *', async (c) => {
  c.var.logger.info('Running hourly cleanup');

  const result = await cleanupAgent.run({
    action: 'cleanup-expired',
    olderThan: 24 * 60 * 60 * 1000, // 24 hours in ms
  });

  c.var.logger.info('Cleanup complete', {
    itemsRemoved: result.removed,
  });

  return { success: true, removed: result.removed };
}));

// Daily report at midnight
router.post('/daily-report', cron('0 0 * * *', async (c) => {
  c.var.logger.info('Generating daily report');

  const result = await reportAgent.run({
    type: 'daily-summary',
    date: new Date().toISOString().split('T')[0],
  });

  c.var.logger.info('Daily report generated', {
    metrics: result.metrics,
  });

  return result;
}));

// Weekly digest every Monday at 9am
router.post('/weekly-digest', cron('0 9 * * 1', async (c) => {
  c.var.logger.info('Generating weekly digest');

  const result = await reportAgent.run({
    type: 'weekly-digest',
  });

  return result;
}));

export default router;
```

**What this demonstrates:**
- Using `cron()` middleware with schedule expressions
- Cron routes must use POST method
- Logging at start and end of scheduled jobs
- Multiple schedules in a single route file

**Cron expression reference:**

| Expression | Schedule |
|------------|----------|
| `0 * * * *` | Every hour |
| `0 0 * * *` | Daily at midnight |
| `0 9 * * 1` | Monday at 9am |
| `*/15 * * * *` | Every 15 minutes |
| `0 0 1 * *` | First day of month |

**Try it:**
1. Create the cron route file
2. Deploy with `agentuity deploy`
3. Check the Agentuity console to see scheduled executions
4. View logs to confirm jobs run on schedule

**Key insight:** Cron routes are ideal for tasks that don't need user interaction: cleanup, reports, data sync, health checks.

<Callout type="warning">
Cron routes only run in deployed environments, not in Workbench. Test the handler logic manually during development, then deploy to verify scheduling.
</Callout>

</TutorialStep>

<TutorialStep number={5} title="Background Processing with waitUntil()" estimatedTime="5 min">

Sometimes you need to return a response immediately while continuing work in the background. Use `c.executionCtx.waitUntil()` for fire-and-forget operations.

```typescript
import { createRouter } from '@agentuity/runtime';
import processingAgent from '../../agent/processing/agent';
import analyticsAgent from '../../agent/analytics/agent';

const router = createRouter();

router.post('/submit', async (c) => {
  const body = await c.req.json();
  const taskId = crypto.randomUUID().slice(0, 8);

  c.var.logger.info('Task submitted', { taskId });

  // Start background processing - don't wait for completion
  c.executionCtx?.waitUntil(
    (async () => {
      try {
        const result = await processingAgent.run({
          taskId,
          data: body.data,
        });

        c.var.logger.info('Background task completed', {
          taskId,
          status: result.status,
        });
      } catch (error) {
        c.var.logger.error('Background task failed', {
          taskId,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    })()
  );

  // Return immediately with task ID
  return c.json({
    accepted: true,
    taskId,
    message: 'Processing started in background',
  });
});

router.post('/track', async (c) => {
  const body = await c.req.json();

  // Fire-and-forget analytics - don't block the response
  c.executionCtx?.waitUntil(
    analyticsAgent.run({
      event: body.event,
      properties: body.properties,
      timestamp: new Date().toISOString(),
    })
  );

  // Return immediately
  return c.json({ tracked: true });
});

export default router;
```

**What this demonstrates:**
- Using `c.executionCtx?.waitUntil()` for background work
- Returning responses immediately without waiting
- Error handling in background tasks
- Fire-and-forget analytics pattern

**Try it:**
1. Submit a task and get immediate response with task ID
2. Check logs to see background processing complete later
3. Track analytics events without blocking responses

**Key insight:** `waitUntil()` is useful for non-blocking operations where the user doesn't need to wait for completion.

<Callout type="info">
Background tasks continue running even after the response is sent. Make sure to handle errors in background tasks since there's no way to report them to the user.
</Callout>

</TutorialStep>

## Advanced Patterns

### Combining Routes with Agent Calls

Routes can orchestrate multiple agents for complex workflows:

```typescript
import { createRouter } from '@agentuity/runtime';
import validationAgent from '../../agent/validation/agent';
import processingAgent from '../../agent/processing/agent';
import notificationAgent from '../../agent/notification/agent';

const router = createRouter();

router.post('/workflow', async (c) => {
  const body = await c.req.json();
  const startTime = Date.now();

  c.var.logger.info('Starting workflow', { input: body });

  // Step 1: Validate input
  const validation = await validationAgent.run({ data: body });
  if (!validation.valid) {
    return c.json({ error: 'Validation failed', details: validation.errors }, 400);
  }

  // Step 2: Process the validated data
  const result = await processingAgent.run({
    data: validation.sanitizedData,
  });

  // Step 3: Send notification in background
  c.executionCtx?.waitUntil(
    notificationAgent.run({
      type: 'workflow-complete',
      result: result.summary,
    })
  );

  const duration = Date.now() - startTime;
  c.var.logger.info('Workflow completed', { duration });

  return c.json({
    success: true,
    result: result.output,
    processingTime: `${duration}ms`,
  });
});

export default router;
```

### Route-Level Storage Access

Routes have access to the same storage APIs as agents through `c.var`:

```typescript
import { createRouter } from '@agentuity/runtime';

const router = createRouter();

router.get('/cached/:key', async (c) => {
  const key = c.req.param('key');

  // Check cache in route
  const cached = await c.var.kv.get('cache', key);
  if (cached.exists) {
    c.var.logger.info('Cache hit', { key });
    return c.json(await cached.data.json());
  }

  c.var.logger.info('Cache miss', { key });
  return c.json({ error: 'Not found' }, 404);
});

router.post('/cached/:key', async (c) => {
  const key = c.req.param('key');
  const body = await c.req.json();

  // Store in cache with 1-hour TTL
  await c.var.kv.set('cache', key, body, { ttl: 3600 });

  c.var.logger.info('Cached', { key });
  return c.json({ cached: true, key });
});

export default router;
```

### Error Handling in Routes

Consistent error handling improves API usability:

```typescript
import { createRouter } from '@agentuity/runtime';
import myAgent from '../../agent/my-agent/agent';

const router = createRouter();

router.post('/', myAgent.validator(), async (c) => {
  const data = c.req.valid('json');

  try {
    const result = await myAgent.run(data);
    return c.json({ success: true, data: result });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';

    c.var.logger.error('Agent execution failed', {
      error: message,
      input: data,
    });

    // Return appropriate status codes
    if (message.includes('not found')) {
      return c.json({ error: 'Resource not found' }, 404);
    }

    if (message.includes('unauthorized')) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    return c.json({ error: 'Internal server error' }, 500);
  }
});

export default router;
```

## Best Practices

### Keep Routes Thin

Routes should handle HTTP concerns only. Delegate all business logic to agents:

```typescript
// Good: Route handles HTTP, agent handles logic
router.post('/', agent.validator(), async (c) => {
  const data = c.req.valid('json');
  const result = await agent.run(data);
  return c.json(result);
});

// Avoid: Business logic in route
router.post('/', async (c) => {
  const body = await c.req.json();
  // Don't do complex processing here
  const processed = complexBusinessLogic(body);
  const aiResult = await callAI(processed);
  const saved = await saveToDatabase(aiResult);
  return c.json(saved);
});
```

### Use validator() for Type Safety

Always use `agent.validator()` when the agent has a schema. It provides:
- Automatic request validation
- Type-safe access to validated data
- Consistent error responses

### Log at Route Level for HTTP Debugging

Use `c.var.logger` to track HTTP-specific information:

```typescript
router.post('/', async (c) => {
  c.var.logger.info('Request received', {
    method: c.req.method,
    path: c.req.path,
    contentType: c.req.header('content-type'),
  });

  // ... route logic

  c.var.logger.info('Response sent', { status: 200 });
  return c.json(result);
});
```

### Choose the Right Trigger

| Trigger Type | Use Case |
|--------------|----------|
| **HTTP POST** | User actions, API calls, webhooks |
| **HTTP GET** | Data retrieval, health checks |
| **Cron** | Scheduled tasks, periodic jobs |
| **waitUntil()** | Background processing, analytics |

## Key Takeaways

- **Routes handle HTTP, agents handle logic**: Keep this separation clean
- **Use `agent.validator()`**: Automatic validation with type safety
- **Cron for scheduled tasks**: Background jobs run without user interaction
- **`waitUntil()` for background work**: Return immediately, process later
- **Route context (`c`)** differs from **agent context (`ctx`)**: Each is optimized for its purpose
- **Log at both levels**: Route logs for HTTP debugging, agent logs for business logic

## What's Next?

You've learned how to connect agents to the outside world through routes. But what about real-time communication? In the next module, we'll explore streaming and real-time connections: WebSockets, Server-Sent Events, and streaming responses.

---

**Ready for Module 8?** [Streaming and Real-Time Communication](./08-streaming-realtime)
