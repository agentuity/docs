---
title: "Module 3: Agent Memory"
description: How agents remember, learn, and build context over time
---

Without memory, an agent is just a stateless function. With memory, it becomes a system that learns, adapts, and evolves over time.

## The Memory Challenge

LLMs can't remember things on their own: the memory component must be added separately. [One of the biggest challenges](https://www.ibm.com/think/topics/ai-agent-memory) in AI memory design is optimizing retrieval efficiency, since storing too much data can slow down response times.

As highlighted in a recent [memory management blog post](https://medium.com/@nomannayeem/building-ai-agents-that-actually-remember-a-developers-guide-to-memory-management-in-2025-062fd0be80a1):

> "The difference between a chatbot and an agent is memory. A chatbot responds to the current message. An agent remembers your entire relationship."

This creates fundamental challenges:
- **Context Loss**: Users repeatedly explain their situation
- **No Learning**: Agents can't improve from past interactions
- **Limited Personalization**: Every user gets the same generic experience
- **Inefficient Operations**: Recomputing information that should be cached

## Understanding Agent Memory Types

<Callout type="info">
For implementation details on Agentuity's storage systems, see our guides on [Key-Value Storage](/Services/Storage/key-value), [Vector Database](/Services/Storage/vector), and [Object Storage](/Services/Storage/object).
</Callout>

### Memory Types Overview

Agent memory maps to multiple storage APIs, each serving different patterns:

| Memory Pattern | Storage API | Duration | Common Use Cases |
|----------------|-------------|----------|------------------|
| **Request State** | `ctx.state` | Single request | Temporary calculations, request context |
| **Session State** | `ctx.session.state` | Single session | Request metadata |
| **Thread State** | `ctx.thread.state` | ~1 hour (cookie) | Conversation history, user preferences |
| **Session Cache** | KV with TTL | Minutes-hours | Temporary cache, rate limiting |
| **Persistent Data** | KV (no TTL) | Permanent | User profiles, preferences, settings |
| **Knowledge Base** | Vector storage | Permanent | Semantic search, RAG, learned insights |
| **Durable Streams** | Stream storage | Permanent | Event logs, audit trails, data pipelines |
| **File Storage** | Object storage | Permanent | Documents, images, media, backups |

### Storage API Quick Reference

Agentuity provides multiple storage APIs, each optimized for different data types:

- **Thread State**: In-memory state that persists across requests within a conversation (~1 hour, cookie-based)
- **Key-Value (KV)**: Fast exact-match lookups. Use TTL for auto-expiring data (sessions), omit TTL for permanent storage (preferences)
- **Vector Storage**: Semantic similarity search using embeddings. Perfect for "find relevant information" use cases
- **Stream Storage**: Durable append-only streams for event logs, audit trails, and data pipelines
- **Object Storage**: Binary file storage with public URL generation. For media, documents, and large files

### Structured vs. Unstructured Memory

Choose your storage API based on how you need to query and retrieve data:

**Structured Memory (Key-Value Storage)**

Use when you need exact-match lookups with known keys:
- User preferences and profiles
- Session state and temporary cache
- Configuration settings and feature flags
- Counters, metrics, and structured data

**Unstructured Memory (Vector Storage)**

Use when you need semantic search across text content:
- Conversation history you want to search by meaning
- Knowledge bases and documentation
- User feedback and learned insights
- Any content requiring "find similar" functionality

**Binary Memory (Object Storage)**

Use for files and large binary content:
- User uploads and generated documents
- Images, videos, and media files
- Backups and archives
- Large datasets and exports

## Build Agent Memory Step-by-Step

Now let's get hands-on with memory patterns. Each step below focuses on one core concept, with simple code you can run immediately in Workbench. These tutorial steps teach platform-specific SDK patterns. The lab at the end shows all three storage types working together in a real docs Q&A agent.

### Step 1: Thread State for Conversations

<TutorialStep number={1} title="Thread State for Conversation Memory" estimatedTime="5 min">

Thread state persists across requests within a conversation, making it ideal for chat history and user preferences. It's automatically managed via cookies and lasts approximately 1 hour.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('ConversationMemory', {
  handler: async (ctx, input) => {
    const message = input.message;

    // Initialize conversation history on first request
    if (!ctx.thread.state.has('messages')) {
      ctx.thread.state.set('messages', []);
      ctx.thread.state.set('turnCount', 0);
    }

    // Get current conversation state
    const messages = ctx.thread.state.get('messages') as string[];
    const turnCount = ctx.thread.state.get('turnCount') as number;

    // Add new message
    messages.push(message);

    // Update thread state
    ctx.thread.state.set('messages', messages);
    ctx.thread.state.set('turnCount', turnCount + 1);

    ctx.logger.info('Conversation updated', {
      threadId: ctx.thread.id,
      turnCount: turnCount + 1,
    });

    return {
      threadId: ctx.thread.id,
      turnCount: turnCount + 1,
      history: messages,
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Using `ctx.thread.state.has()` to check for existing state
- Using `ctx.thread.state.get()` and `ctx.thread.state.set()` to manage state
- Accessing `ctx.thread.id` for the unique thread identifier
- Building conversation history that persists across requests

**Try it:**
1. Send "Hello, this is my first message" - initializes thread state
2. Send "Here is my second message" - retrieves and appends to history
3. Send "And a third message" - see all 3 messages stored
4. Close browser and reopen within 1 hour - state persists
5. Wait longer than 1 hour - thread state resets automatically

**Key insight:** Thread state is perfect for conversation context that should persist during a user session but doesn't need permanent storage.

<Callout type="info">
**Thread State vs KV Storage**: Use thread state for temporary conversation context (~1 hour). Use KV storage for data that should persist longer or be accessible across different threads.
</Callout>

</TutorialStep>

### Step 2: Session Memory with KV + TTL

<TutorialStep number={2} title="Session Memory with KV + TTL" estimatedTime="5 min">

For data that needs to persist longer than thread state, or be shared across threads, use Key-Value storage with TTL for automatic cleanup.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('SessionMemory', {
  handler: async (ctx, input) => {
    const sessionId = input.sessionId || 'default';
    const message = input.message;

    // Retrieve existing chat history
    const result = await ctx.kv.get('sessions', `chat-history-${sessionId}`);

    let messages: string[] = [];
    if (result.exists) {
      messages = await result.data.json();
    }

    // Append new message
    messages.push(message);

    // Store with 1-hour TTL for automatic cleanup
    await ctx.kv.set('sessions', `chat-history-${sessionId}`, messages, {
      ttl: 3600,
    });

    ctx.logger.info('Session updated', { sessionId, messageCount: messages.length });

    return {
      sessionId,
      messageCount: messages.length,
      history: messages,
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Storing an array of messages in KV storage with a simple key
- Checking `result.exists` to handle new vs returning sessions
- Setting TTL (3600 seconds = 1 hour) for automatic expiration
- Building conversation history by appending messages to an array

**Try it:**
1. Send "Hello, this is my first message" - creates new chat history
2. Send "Here is my second message" - retrieves and appends to history
3. Send "And a third message" - see all 3 messages stored
4. Wait 1 hour (or check back later) - session data expires automatically
5. Check Workbench KV viewer to see the `chat-history` key and stored messages

**Key insight:** TTL-based memory is perfect for temporary data like chat sessions, preventing manual cleanup and storage costs.

<Callout type="info">
**TTL vs Permanent Storage**: Include a `ttl` parameter (in seconds) for automatic expiration (e.g., `3600` = 1 hour), or omit it for permanent storage.
</Callout>

</TutorialStep>

### Step 3: Vector Storage Basics

<TutorialStep number={3} title="Vector Upsert & Basic Search" estimatedTime="6 min">

Vector storage enables semantic search: finding information by meaning rather than keywords. Documents are converted to embeddings automatically.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('VectorBasics', {
  handler: async (ctx, input) => {
    const query = input.query || 'What is Agentuity?';

    // Upsert some demo documents (auto-embedded)
    await ctx.vector.upsert('knowledge-base',
      {
        key: 'fact-1',
        document: 'Agentuity is an agent-native cloud platform for deploying AI agents',
        metadata: { category: 'platform' },
      },
      {
        key: 'fact-2',
        document: 'Agentuity provides key-value, vector, and object storage for agents',
        metadata: { category: 'storage' },
      },
      {
        key: 'fact-3',
        document: 'Agents can communicate with each other using typed messages',
        metadata: { category: 'communication' },
      }
    );

    // Search for relevant documents
    const results = await ctx.vector.search('knowledge-base', {
      query,
      limit: 3,
      similarity: 0.5,
    });

    ctx.logger.info('Vector search completed', { query, resultCount: results.length });

    // Clean up demo vectors
    await ctx.vector.delete('knowledge-base', 'fact-1', 'fact-2', 'fact-3');

    return {
      query,
      results: results.map(r => ({
        document: r.document,
        similarity: r.similarity,
        metadata: r.metadata,
      })),
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Upserting multiple documents with keys and metadata (text is auto-embedded)
- Searching with query text, limit, and similarity threshold
- Handling empty results gracefully
- Similarity scores (0-1, where 1 = perfect match)
- Cleanup by deleting demo vectors

**Try it:**
1. Run the agent with query "What is Agentuity?"
2. See semantic matches (finds "agent-native cloud platform")
3. Try "How does storage work?" - finds storage-related facts
4. Notice similarity scores in results

**Key insight:** Vector search finds meaning, not keywords. "What is Agentuity?" matches "agent-native cloud platform" even without exact words.

</TutorialStep>

### Step 4: Vector Metadata Filtering

<TutorialStep number={4} title="Vector Metadata Filtering" estimatedTime="5 min">

Combine semantic similarity with structured filters to narrow results by category, user, status, or any metadata field.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('VectorFiltering', {
  handler: async (ctx, input) => {
    const { query, category, inStock } = input;

    // Upsert product catalog
    await ctx.vector.upsert('products',
      {
        key: 'prod-1',
        document: 'Ergonomic standing desk with adjustable height',
        metadata: { category: 'furniture', price: 599, inStock: true },
      },
      {
        key: 'prod-2',
        document: 'Wireless mechanical keyboard with RGB lighting',
        metadata: { category: 'electronics', price: 149, inStock: true },
      },
      {
        key: 'prod-3',
        document: 'Executive office chair with lumbar support',
        metadata: { category: 'furniture', price: 399, inStock: false },
      },
      {
        key: 'prod-4',
        document: 'USB-C docking station hub',
        metadata: { category: 'electronics', price: 89, inStock: true },
      }
    );

    // Build metadata filter based on input
    const metadataFilter: Record<string, unknown> = {};
    if (category) metadataFilter.category = category;
    if (inStock !== undefined) metadataFilter.inStock = inStock;

    // Search with metadata filtering
    const results = await ctx.vector.search('products', {
      query: query || 'office furniture',
      limit: 5,
      similarity: 0.3,
      metadata: Object.keys(metadataFilter).length > 0 ? metadataFilter : undefined,
    });

    ctx.logger.info('Filtered search completed', { query, category, resultCount: results.length });

    // Clean up
    await ctx.vector.delete('products', 'prod-1', 'prod-2', 'prod-3', 'prod-4');

    return {
      query,
      filters: { category, inStock },
      results: results.map(r => ({
        document: r.document,
        similarity: r.similarity,
        metadata: r.metadata,
      })),
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Adding metadata to vectors (category, price, inStock, etc.)
- Filtering search results with `metadata` parameter
- Metadata filters use AND logic (all conditions must match)
- Lower similarity threshold (0.3) when using strict filters
- Post-processing results for additional filtering

**Try it:**
1. Send `{"query": "office furniture", "category": "furniture", "inStock": true}`
2. See only furniture items that are in stock
3. Try `{"query": "desk accessories", "category": "electronics"}`
4. Notice results filtered by both meaning AND category

**Key insight:** Metadata filtering is exact-match, not fuzzy. Use it to combine semantic search with business rules.

<Callout type="info">
**Metadata Filtering in Vector Search**: The `metadata` parameter in vector search is used to filter results, not just for returning metadata. When you specify `metadata: { user_id: userId }` in the search options, the search will only return vectors that match those metadata criteria. This is useful for isolating user-specific memories or filtering by any other metadata field you've stored.
</Callout>

</TutorialStep>

### Step 5: Stream Storage for Event Logs

<TutorialStep number={5} title="Stream Storage for Durable Events" estimatedTime="5 min">

Stream storage provides durable, append-only streams for event logs, audit trails, and data pipelines. Streams persist data reliably and can be read later.

```typescript
import { createAgent } from '@agentuity/runtime';

const agent = createAgent('StreamStorageDemo', {
  handler: async (ctx, input) => {
    const action = input.action;
    const streamName = 'audit-log';

    // Create a stream for logging events
    const stream = await ctx.stream.create(streamName, {
      contentType: 'application/json',
    });

    // Write audit event to the stream
    const event = {
      timestamp: new Date().toISOString(),
      action,
      sessionId: ctx.sessionId,
      threadId: ctx.thread.id,
    };

    await stream.write(JSON.stringify(event) + '\n');
    await stream.close();

    ctx.logger.info('Event logged to stream', { streamName, action });

    return {
      message: 'Event logged successfully',
      event,
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Creating a durable stream with `ctx.stream.create()`
- Writing structured event data to the stream
- Proper stream lifecycle (write, close)
- Including context like session and thread IDs in events

**Try it:**
1. Send `{"action": "user_login"}` - logs a login event
2. Send `{"action": "data_export"}` - logs an export event
3. Check Workbench to see events accumulating in the stream

**Key insight:** Streams are ideal for audit trails and event sourcing where you need a reliable, append-only log of activities.

<Callout type="info">
**When to Use Streams**: Use streams for audit logs, event sourcing, or any scenario where you need a durable, append-only log. For random-access data, use KV storage instead.
</Callout>

</TutorialStep>

### Step 6: Object Storage Basics

<TutorialStep number={6} title="Object Storage Basics" estimatedTime="5 min">

Files and media need different storage than structured data. Object storage handles binary content and provides shareable public URLs. Agentuity uses Bun's native S3 client for object storage.

```typescript
import { createAgent } from '@agentuity/runtime';
import { s3 } from 'bun';

const agent = createAgent('ObjectStorageBasics', {
  handler: async (ctx, input) => {
    const content = input.content || 'Hello from object storage!';
    const fileName = `demo-${Date.now()}.txt`;

    // Store file with auto-detected content type
    const file = s3.file(fileName);
    await file.write(content, { type: 'text/plain' });

    ctx.logger.info('File stored', { fileName });

    // Check existence and read back
    const exists = await file.exists();
    const retrievedContent = await file.text();

    // Generate temporary public URL (expires in 1 hour)
    const publicUrl = file.presign({
      expiresIn: 3600,
    });

    ctx.logger.info('Public URL generated', { fileName, expiresIn: '1 hour' });

    // Clean up demo file
    await file.delete();

    return {
      fileName,
      exists,
      content: retrievedContent,
      publicUrl,
      note: 'File deleted after demo - URL will not work',
    };
  },
});

export default agent;
```

**What this demonstrates:**
- Using Bun's native `s3` client for object storage
- Storing files with auto-detected content type (simplest approach)
- Retrieving stored objects and checking existence
- Creating temporary public URLs (expires in 1 hour)
- Cleanup by deleting demo files

**Try it:**
1. Send any text content
2. See file stored, retrieved, and public URL created
3. Access the URL in browser (works for 1 hour)
4. Notice file is deleted after demo (cleanup pattern)

**Key insight:** Public URLs expire automatically, perfect for temporary file sharing without permanent public access.

</TutorialStep>

## Lab: Try It All Together

You've learned the core memory patterns through focused steps. Now let's see them combined in a real-world agent that uses **multiple storage types together**:

- **Thread state** for conversation context
- **Vector storage** for semantic document search
- **KV storage** for tracking query history and caching
- **Object storage** for uploaded documentation files

### Key Implementation: Upload & Index Pattern

The core pattern shows how agents use all storage types together in a cohesive workflow:

```typescript
import { createAgent } from '@agentuity/runtime';
import { s3 } from 'bun';

const VECTOR_STORAGE_NAME = 'docs-knowledge';
const KV_STORAGE_NAME = 'docs-cache';

function chunkDocument(content: string, chunkSize: number = 500): string[] {
  const chunks: string[] = [];
  for (let i = 0; i < content.length; i += chunkSize) {
    chunks.push(content.slice(i, i + chunkSize));
  }
  return chunks;
}

async function handleUpload(
  ctx: AgentContext,
  fileContent: string,
  fileName: string
) {
  // 1. Store in object storage with proper UTF-8 encoding
  const file = s3.file(`documents/${fileName}`);
  await file.write(fileContent, { type: 'text/plain' });

  // 2. Chunk and embed for search (auto-embedded by platform)
  const chunks = chunkDocument(fileContent, 500);

  // Upsert all chunks at once
  await ctx.vector.upsert(
    VECTOR_STORAGE_NAME,
    ...chunks.map((chunk, i) => ({
      key: `${fileName}_chunk_${i}`,
      document: chunk,
      metadata: {
        sourceFile: fileName,
        chunkIndex: i,
        uploadedAt: new Date().toISOString(),
      },
    }))
  );

  ctx.logger.info('Document indexed', { fileName, chunks: chunks.length });

  return {
    status: 'indexed',
    chunks: chunks.length,
    file: fileName,
  };
}
```

### Key Implementation: Semantic Search with Context

Agents combine search results with thread state for intelligent responses:

```typescript
async function searchDocuments(
  ctx: AgentContext,
  query: string,
  limit: number = 5
) {
  // 1. Vector search for relevant chunks
  const searchResults = await ctx.vector.search(VECTOR_STORAGE_NAME, {
    query,
    limit,
    similarity: 0.5,
  });

  // 2. Track query history in thread state for this conversation
  if (!ctx.thread.state.has('queryHistory')) {
    ctx.thread.state.set('queryHistory', []);
  }
  const queryHistory = ctx.thread.state.get('queryHistory') as Array<{
    query: string;
    timestamp: string;
  }>;
  queryHistory.push({ query, timestamp: new Date().toISOString() });
  ctx.thread.state.set('queryHistory', queryHistory.slice(-10)); // Keep last 10

  // 3. Also persist to KV for cross-session analytics
  const kvHistory = await ctx.kv.get(KV_STORAGE_NAME, 'recent_queries');
  let recent: Array<{ query: string; timestamp: string }>;

  if (kvHistory.exists) {
    recent = await kvHistory.data.json();
    recent.push({ query, timestamp: new Date().toISOString() });
  } else {
    recent = [{ query, timestamp: new Date().toISOString() }];
  }

  // Store updated query history (keep last 100)
  await ctx.kv.set(KV_STORAGE_NAME, 'recent_queries', recent.slice(-100));

  ctx.logger.info('Search completed', { query, resultCount: searchResults.length });

  return searchResults;
}
```

### Key Implementation: AI-Powered Documentation Q&A

Combining search results with AI for intelligent documentation responses:

```typescript
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

async function buildSmartResponse(
  ctx: AgentContext,
  query: string,
  searchResults: VectorSearchResult[]
) {
  // Build context from top search results
  const docContext = searchResults
    .slice(0, 2)
    .map(result => result.document || '')
    .filter(content => content)
    .join('\n\n');

  // Generate AI response using AI SDK
  const { text: aiAnswer } = await generateText({
    model: openai('gpt-5-mini'),
    prompt: `Answer this question about Agentuity based on the documentation provided.

Documentation context:
${docContext || 'No relevant documentation found.'}

Question: ${query}

Provide a helpful, concise answer in 2-3 sentences. If no context is available, politely indicate that.`,
  });

  ctx.logger.info('AI response generated', { query });

  return aiAnswer;
}
```

### What This Agent Demonstrates

- **Semantic search**: Vector similarity for finding relevant documentation
- **User learning**: Tracking search patterns and feedback to improve responses
- **Context building**: Combining search results with conversation history
- **Feedback loops**: Learning from user interactions to boost helpful content
- **Personalization**: Adapting responses based on user's experience level

The complete examples show you how to build intelligent documentation agents that get smarter over time through user interaction.

### Testing Your Docs Q&A Agent

1. **Start Workbench:**
```bash
agentuity dev
```

2. **Test the documentation search:**
   - Ask questions about different documentation topics
   - Notice how semantic search finds relevant content
   - Test similar queries to see cached vs fresh results

3. **Observe the memory in action:**
   - Watch the logs to see vector search operations
   - Try different user patterns to see personalized responses
   - Test feedback loops by rating search results

## Memory at Scale

As your agents grow, consider these scaling strategies:

### Memory Access Patterns
- **Frequently accessed data**: Thread state (conversation context), KV storage (recent interactions, user profiles)
- **Searchable data**: Vector storage (conversation history, knowledge base)
- **Event data**: Stream storage (audit logs, analytics events)
- **Archived data**: Object storage (old files, backups)

### Organizing Memory at Scale

**Data Partitioning**: Use user IDs or tenant IDs to organize data in separate namespaces, keeping user data isolated.

**Smart Caching**: Use KV storage with short TTL (5-15 minutes) for expensive computations that might be repeated.

## Key Takeaways

- **Memory transforms agents** from stateless functions to learning systems
- **Choose the right storage**: Thread state for conversation context, KV for data, Vector for search, Stream for events, Object for files
- **TTL is key**: Use appropriate expiration times for different data types
- **Start simple**: Begin with basic patterns, add complexity as needed
- **Organize by user**: Keep data properly partitioned and isolated

## What's Next?

Now that your agents can remember, it's time to help them collaborate. In the next module, we'll explore agent-to-agent communication: how multiple specialized agents can work together to solve complex problems.

But first, experiment with memory patterns:
- Build an agent that learns user preferences over time
- Implement a knowledge base that grows from conversations
- Create memory cleanup strategies
- Test different TTL strategies for various use cases

Remember: Memory is what transforms an agent from a simple tool into a useful, effective, and adaptive system.

---

**Ready for Module 4?** [Agent-to-Agent Collaboration](./04-agent-collaboration)
