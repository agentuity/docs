---
title: Running Agents Without HTTP
description: Execute agents programmatically for cron jobs, bots, CLI tools, and background workers
---

Sometimes your agent logic needs to run without an incoming HTTP request. `createAgentContext()` gives standalone code the same infrastructure that HTTP handlers get automatically: tracing, sessions, and storage access.

<Callout type="warning" title="Agentuity Runtime Only">
`createAgentContext()` requires Agentuity's runtime initialization and only works within the Agentuity runtime (Discord bots, CLI tools, queue workers deployed alongside your agents). It will throw an error if called from external frameworks like Next.js or Express. To access storage from external backends, see [SDK Utilities for External Apps](/Cookbook/Patterns/server-utilities).
</Callout>

## Basic Usage

```typescript
import { createAgentContext } from '@agentuity/runtime';
import chatAgent from '@agent/chat';

const ctx = createAgentContext();
const result = await ctx.run(chatAgent, { message: 'Hello' });
```

The `run()` method executes your agent with full infrastructure support: tracing, session management, and access to all storage services.

For agents that don't require input:

```typescript
const result = await ctx.run(statusAgent);
```

<Callout type="info" title="Legacy invoke() Method">
The older `ctx.invoke(() => agent.run(input))` pattern still works but `ctx.run(agent, input)` is preferred for its cleaner syntax.
</Callout>

## Options

| Option | Type | Description |
|--------|------|-------------|
| `sessionId` | `string` | Custom session ID. Auto-generated from trace context if not provided |
| `trigger` | `string` | Trigger type for telemetry: `'discord'`, `'cron'`, `'websocket'`, `'manual'` |
| `thread` | `Thread` | Custom thread for conversation state |
| `session` | `Session` | Custom session instance |
| `parentContext` | `Context` | Parent OpenTelemetry context for distributed tracing |

## External Cron Job Example

For scheduled tasks managed outside of Agentuity:

```typescript
import { createApp, createAgentContext } from '@agentuity/runtime';
import cron from 'node-cron';
import cleanupAgent from '@agent/cleanup';

await createApp();

// Run cleanup every hour
cron.schedule('0 * * * *', async () => {
  const ctx = createAgentContext({ trigger: 'cron' });
  await ctx.run(cleanupAgent, { task: 'expired-sessions' });
});
```

<Callout type="info" title="Built-in Cron Support">
For most scheduled tasks, use the [`cron()` middleware](/Routes/cron) instead. It handles infrastructure automatically without needing `createAgentContext`. Use standalone execution only when you need external cron management.
</Callout>

## Multiple Agents in Sequence

Run multiple agents in sequence with the same context:

```typescript
const ctx = createAgentContext();

// First agent analyzes the input
const analysis = await ctx.run(analyzeAgent, { text: userInput });

// Second agent generates response based on analysis
const response = await ctx.run(respondAgent, {
  analysis: analysis.summary,
  sentiment: analysis.sentiment,
});
```

Each `ctx.run()` call shares the same session and tracing context.

## Reusing Contexts

Create a context once and reuse it for multiple invocations:

```typescript
const ctx = createAgentContext({ trigger: 'websocket' });

// Each run() gets its own session and tracing span
websocket.on('message', async (data) => {
  const result = await ctx.run(messageAgent, data);
  websocket.send(result);
});
```

## What's Included

<Callout type="info" title="Full Infrastructure Support">
Standalone contexts provide the same infrastructure as HTTP request handlers:

- **Tracing**: OpenTelemetry spans with proper hierarchy
- **Sessions**: Automatic save/restore via providers
- **Threads**: Conversation state management
- **Storage**: Full access to `kv`, `stream`, `vector`
- **Background tasks**: `waitUntil` support for fire-and-forget work
- **Session events**: Start/complete events for observability
</Callout>

## Detecting Runtime Context

Use `isInsideAgentRuntime()` to check if code is running within the Agentuity runtime:

```typescript
import { isInsideAgentRuntime, createAgentContext } from '@agentuity/runtime';
import myAgent from '@agent/my-agent';

async function processRequest(data: unknown) {
  if (isInsideAgentRuntime()) {
    // Already in runtime context, call agent directly
    return myAgent.run(data);
  }

  // Outside runtime, create context first
  const ctx = createAgentContext();
  return ctx.run(myAgent, data);
}
```

This is useful for writing utility functions that work both inside agent handlers and in standalone scripts.

## Next Steps

- [Calling Other Agents](/Agents/calling-other-agents): Agent-to-agent communication patterns
- [Cron Routes](/Routes/cron): Built-in scheduled task support
- [State Management](/Agents/state-management): Thread and session state
