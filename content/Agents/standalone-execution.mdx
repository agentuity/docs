---
title: Running Agents Without HTTP
description: Execute agents programmatically for cron jobs, bots, CLI tools, and background workers
---

Sometimes your agent logic needs to run without an incoming HTTP request. `createAgentContext()` gives standalone code the same infrastructure that HTTP handlers get automatically: tracing, sessions, and storage access.

<Callout type="warning" title="Agentuity Runtime Only">
`createAgentContext()` requires Agentuity's runtime initialization and only works within the Agentuity runtime (Discord bots, CLI tools, queue workers deployed alongside your agents). It will throw an error if called from external frameworks like Next.js or Express. To access storage from external backends, see [SDK Utilities for External Apps](/Learn/Cookbook/Patterns/server-utilities).
</Callout>

## Basic Usage

```typescript
import { createAgentContext } from '@agentuity/runtime';
import chatAgent from '@agent/chat';

const ctx = createAgentContext();
const result = await ctx.invoke(() => chatAgent.run({ message: 'Hello' }));
```

The `invoke()` method executes your agent with full infrastructure support: tracing, session management, and access to all storage services.

## Options

| Option | Type | Description |
|--------|------|-------------|
| `sessionId` | `string` | Custom session ID. Auto-generated from trace context if not provided |
| `trigger` | `string` | Trigger type for telemetry: `'discord'`, `'cron'`, `'websocket'`, `'manual'` |
| `thread` | `Thread` | Custom thread for conversation state |
| `session` | `Session` | Custom session instance |
| `parentContext` | `Context` | Parent OpenTelemetry context for distributed tracing |

## External Cron Job Example

For scheduled tasks managed outside of Agentuity:

```typescript
import { createApp, createAgentContext } from '@agentuity/runtime';
import cron from 'node-cron';
import cleanupAgent from '@agent/cleanup';

await createApp();

// Run cleanup every hour
cron.schedule('0 * * * *', async () => {
  const ctx = createAgentContext({ trigger: 'cron' });

  await ctx.invoke(async () => {
    await cleanupAgent.run({ task: 'expired-sessions' });
  });
});
```

<Callout type="info" title="Built-in Cron Support">
For most scheduled tasks, use the [`cron()` middleware](/Build/Routes/cron) instead. It handles infrastructure automatically without needing `createAgentContext`. Use standalone execution only when you need external cron management.
</Callout>

## Multiple Agents in Sequence

Run multiple agents within a single `invoke()` call to share the same session and tracing context:

```typescript
const ctx = createAgentContext();

const result = await ctx.invoke(async () => {
  // First agent analyzes the input
  const analysis = await analyzeAgent.run({ text: userInput });

  // Second agent generates response based on analysis
  const response = await respondAgent.run({
    analysis: analysis.summary,
    sentiment: analysis.sentiment,
  });

  return response;
});
```

## Reusing Contexts

Create a context once and reuse it for multiple invocations:

```typescript
const ctx = createAgentContext({ trigger: 'websocket' });

// Each invoke() gets its own session and tracing span
websocket.on('message', async (data) => {
  const result = await ctx.invoke(() => messageAgent.run(data));
  websocket.send(result);
});
```

## What's Included

<Callout type="info" title="Full Infrastructure Support">
Standalone contexts provide the same infrastructure as HTTP request handlers:

- **Tracing**: OpenTelemetry spans with proper hierarchy
- **Sessions**: Automatic save/restore via providers
- **Threads**: Conversation state management
- **Storage**: Full access to `kv`, `stream`, `vector`
- **Background tasks**: `waitUntil` support for fire-and-forget work
- **Session events**: Start/complete events for observability
</Callout>

## Next Steps

- [Calling Other Agents](/Build/Agents/calling-other-agents): Agent-to-agent communication patterns
- [Cron Routes](/Build/Routes/cron): Built-in scheduled task support
- [State Management](/Build/Agents/state-management): Thread and session state
